<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R-Studio BioStat Simulator: Máster Data Science</title>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;600&family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        /* --- CONFIGURACIÓN NIVEL EXPERTO --- */
        :root {
            /* Paleta RStudio Dark Theme (Dracula/Tomorrow Night inspired) */
            --bg-app: #121212;
            --bg-sidebar: #1e1e1e;
            --bg-panel: #282a36;
            --bg-editor: #1e1e1e;
            
            --text-main: #f8f8f2;
            --text-muted: #6272a4;
            
            /* Syntax Highlighting R */
            --r-function: #50fa7b;
            --r-keyword: #ff79c6;
            --r-string: #f1fa8c;
            --r-number: #bd93f9;
            --r-operator: #ff79c6;
            --r-comment: #6272a4;
            --r-param: #8be9fd;
            --r-var: #f8f8f2;

            --accent: #bd93f9;
            --border: #44475a;
        }
        
        * { 
            box-sizing: border-box; 
            margin: 0; 
            padding: 0; 
        }
        
        body { 
            background: var(--bg-app); 
            font-family: 'Inter', sans-serif; 
            color: var(--text-main); 
            height: 100vh; 
            display: flex; 
            overflow: hidden;
        }

        /* --- SIDEBAR --- */
        .sidebar { 
            width: 280px; 
            background: var(--bg-sidebar); 
            display: flex; 
            flex-direction: column; 
            border-right: 1px solid var(--border);
            flex-shrink: 0;
        }
        
        .header-brand { 
            padding: 20px; 
            background: linear-gradient(135deg, #2c3e50 0%, #000000 100%); 
            border-bottom: 1px solid var(--border);
        }
        
        .header-brand h2 { 
            font-size: 1.1rem; 
            font-weight: 700; 
            letter-spacing: 0.5px; 
            color: #fff; 
            margin-bottom: 5px;
        }
        .header-brand span { 
            font-size: 0.75rem; 
            color: var(--r-param); 
            font-family: 'Fira Code'; 
            display: block; 
        }
        
        .menu-scroll { 
            flex: 1; 
            overflow-y: auto; 
            padding: 10px 0; 
        }
        
        .menu-item {
            padding: 12px 20px;
            cursor: pointer;
            border-left: 3px solid transparent;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 0.85rem;
            color: #ccc;
        }
        
        .menu-item:hover { 
            background: rgba(255,255,255,0.05); 
            color: #fff; 
        }
        .menu-item.active { 
            background: rgba(189, 147, 249, 0.1); 
            border-left-color: var(--r-keyword); 
            color: #fff; 
            font-weight: 600;
        }
        .menu-icon { 
            width: 20px; 
            text-align: center; 
            color: var(--r-function); 
        }

        /* --- LAYOUT PRINCIPAL --- */
        .main-workspace { 
            flex: 1; 
            display: grid; 
            grid-template-columns: 40% 60%;
            height: 100%;
        }

        /* --- COLUMNA IZQUIERDA --- */
        .left-col {
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border);
            height: 100%; /* Aseguramos altura completa */
            overflow: hidden; /* Evita desbordes feos */
        }

                .panel-editor {
            flex: 3;
            display: flex;
            flex-direction: column;
            border-bottom: 1px solid var(--border);
            background: var(--bg-editor);
            min-height: 0; /* CLAVE: Permite que el flex encoja si es necesario */
        }

        .panel-theory {
            flex: 2;
            background: var(--bg-panel);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0; /* CLAVE: Permite calcular el scroll correctamente */
        }
        
        /* --- COLUMNA DERECHA --- */
        .right-col {
            display: flex;
            flex-direction: column;
            background: #f8f9fa;
        }

        .controls-bar {
            background: #fff;
            padding: 12px 20px;
            border-bottom: 1px solid #ddd;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            min-height: 60px;
        }

        .viz-canvas {
    flex: 1;
    padding: 20px;
    overflow: auto; /* Permite scroll si el gráfico es grande */
    display: flex;
    justify-content: center;
    align-items: center; /* Centra el gráfico */
    background: #ffffff; /* BLANCO PURO */
        }

        /* --- COMPONENTES UI --- */
        .panel-header {
            padding: 10px 15px;
            background: #191919;
            border-bottom: 1px solid #333;
            font-family: 'Inter', sans-serif;
            font-size: 0.75rem;
            font-weight: 600;
            color: #999;
            text-transform: uppercase;
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            letter-spacing: 0.5px;
        }

        /* Editor de Código */
        .code-content {
            flex: 1;
            padding: 15px;
            font-family: 'Fira Code', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            overflow: auto;
            color: #f8f8f2;
            white-space: pre;
            tab-size: 2;
        }

        /* Highlighting Classes */
        .c-kwd { color: var(--r-keyword); font-weight: bold; }
        .c-fn { color: var(--r-function); }
        .c-str { color: var(--r-string); }
        .c-num { color: var(--r-number); }
        .c-op { color: var(--r-operator); }
        .c-com { color: var(--r-comment); font-style: italic; }
        .c-arg { color: var(--r-param); font-style: italic; }
        .c-var { color: var(--r-var); }

        /* Caja de Teoría */
        .theory-content {
            flex: 1; /* OBLIGA a ocupar el espacio restante */
            padding: 20px;
            overflow-y: auto; /* Activa el scroll si el texto es largo */
            color: #dcdcdc;
            font-size: 0.9rem;
            line-height: 1.6;
        }
        .theory-content h3 { 
            color: var(--r-function); 
            margin-bottom: 10px; 
            font-size: 1.1rem; 
        }
        .theory-content p { 
            margin-bottom: 12px; 
        }
        .theory-highlight { 
            background: rgba(80, 250, 123, 0.1); 
            border-left: 3px solid var(--r-function); 
            padding: 12px; 
            margin: 15px 0; 
            border-radius: 0 4px 4px 0;
            font-size: 0.85rem;
        }

        /* Controles */
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #ddd;
        }
        
        select, input[type="range"] {
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.85rem;
            background: white;
            color: #333;
            outline: none;
            font-family: 'Inter', sans-serif;
            min-width: 150px;
        }
        
        label { 
            color: #555; 
            font-size: 0.8rem; 
            font-weight: 600; 
            margin-right: 5px; 
        }
        
        /* Scrollbars */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #191919; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }

        /* SVG Styles */
        .axis { stroke: #333; stroke-width: 1.5; }
        .grid { stroke: #e0e0e0; stroke-width: 0.5; }
        .data-point { fill: #3498db; opacity: 0.7; }
        .regression-line { stroke: #e74c3c; stroke-width: 2; fill: none; }
        .confidence-band { fill: #e74c3c; opacity: 0.1; }
        
        /* Responsive */
        @media (max-width: 1200px) {
            .main-workspace {
                grid-template-columns: 50% 50%;
            }
        }
        
        @media (max-width: 900px) {
            body {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 200px;
            }
            .main-workspace {
                grid-template-columns: 1fr;
            }
        }
        /* Botón de volver */
        .sidebar-footer {
            margin-top: auto;
            padding: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .back-button-elegant {
            width: 100%;
            padding: 12px;
            background: rgba(0, 122, 204, 0.2);
            border: 1px solid #007acc;
            color: #007acc;
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
            font-size: 0.9rem;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s ease;
        }
        .back-button-elegant:hover {
            background: #007acc;
            color: white;
            box-shadow: 0 0 15px rgba(0, 122, 204, 0.5);
        }

    </style>
</head>
<body>

<div class="sidebar">
    <div class="header-brand">
        <h2><i class="fas fa-dna"></i> Estadística y R para Ciencias de la Salud</h2>
        <span>Máster en Bioinformática (UNIR)</span>
    </div>
    <div class="menu-scroll" id="menuArea">
        <!-- Menú dinámico -->
    </div>
    <div class="sidebar-footer">
        <button onclick="window.close()" class="back-button-elegant">
            <i class="fas fa-arrow-left"></i> VOLVER
        </button>
    </div>
</div>

<div class="main-workspace">
    
    <div class="left-col">
        <div class="panel-editor">
            <div class="panel-header">
                <span><i class="fas fa-file-code"></i> Source (script.R)</span>
                <span style="color:var(--r-function); font-size:0.7rem;">
                    <i class="fas fa-circle" style="font-size:0.5rem"></i> R Session Active
                </span>
            </div>
            <div class="code-content" id="codeArea">
                <!-- Código dinámico -->
            </div>
        </div>
        
        <div class="panel-theory">
            <div class="panel-header">
                <span><i class="fas fa-book-open"></i> Explicación Académica & Output</span>
            </div>
            <div class="theory-content" id="theoryArea">
                <!-- Teoría dinámica -->
            </div>
        </div>
    </div>

    <div class="right-col">
        <div class="controls-bar" id="controlsArea">
            <!-- Controles dinámicos -->
        </div>
        <div class="viz-canvas" id="vizArea">
            <!-- Visualización dinámica -->
        </div>
    </div>

</div>

<script>
    // =================================================================
    // CORE SYSTEM
    // =================================================================
    
    let currentLessonId = 1;
    const appState = {};

    const svgNS = "http://www.w3.org/2000/svg";
    
    function createSVG(w, h, viewBox) {
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("width", w);
        svg.setAttribute("height", h);
        svg.setAttribute("viewBox", viewBox);
        svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
        return svg;
    }

    // =================================================================
    // BASE DE CONOCIMIENTO (TEMARIO COMPLETO)
    // =================================================================
    
    const lessons = [
        {
            id: 1,
            title: "1. Introducción a R: Estructuras de Datos",
            icon: "fa-cubes",
            controls: [
                {id: 'struct', type: 'select', label: 'Estructura a Analizar', 
                 options: ['Vector (c)', 'Matriz (matrix)', 'Dataframe (data.frame)', 'Lista (list)']}
            ],
            code: (p) => {
                if(p.struct.includes('Vector')) {
                    return `<span class="c-com"># 1. EL VECTOR: La unidad atómica de R</span>
<span class="c-com"># Debe ser HOMOGÉNEO (mismo tipo de dato)</span>

<span class="c-var">pacientes_glucosa</span> <span class="c-op"><-</span> <span class="c-fn">c</span>(<span class="c-num">95</span>, <span class="c-num">110</span>, <span class="c-num">88</span>, <span class="c-num">145</span>, <span class="c-num">120</span>)

<span class="c-com"># Acceso por índice (R empieza en 1)</span>
<span class="c-fn">print</span>(<span class="c-var">pacientes_glucosa</span>[<span class="c-num">2</span>]) <span class="c-com"># Resultado: 110</span>

<span class="c-fn">class</span>(<span class="c-var">pacientes_glucosa</span>) <span class="c-com"># "numeric"</span>`;
                }
                
                if(p.struct.includes('Matriz')) {
                    return `<span class="c-com"># 2. LA MATRIZ: 2 Dimensiones, Homogénea</span>
<span class="c-com"># Útil para Heatmaps (Genes en filas, Muestras en col)</span>

<span class="c-var">datos_genes</span> <span class="c-op"><-</span> <span class="c-fn">matrix</span>(
  <span class="c-arg">data</span> = <span class="c-fn">c</span>(<span class="c-num">1.2</span>, <span class="c-num">2.3</span>, <span class="c-num">0.5</span>, 
              <span class="c-num">1.1</span>, <span class="c-num">2.4</span>, <span class="c-num">0.6</span>, 
              <span class="c-num">3.5</span>, <span class="c-num">1.1</span>, <span class="c-num">0.2</span>),
  <span class="c-arg">nrow</span> = <span class="c-num">3</span>, <span class="c-arg">byrow</span> = <span class="c-kwd">TRUE</span>
)

<span class="c-fn">colnames</span>(<span class="c-var">datos_genes</span>) <span class="c-op"><-</span> <span class="c-fn">c</span>(<span class="c-str">"M1"</span>, <span class="c-str">"M2"</span>, <span class="c-str">"M3"</span>)
<span class="c-fn">rownames</span>(<span class="c-var">datos_genes</span>) <span class="c-op"><-</span> <span class="c-fn">c</span>(<span class="c-str">"BRCA1"</span>, <span class="c-str">"TP53"</span>, <span class="c-str">"EGFR"</span>)

<span class="c-com"># Acceso: [fila, columna]</span>
<span class="c-var">datos_genes</span>[<span class="c-num">1</span>, <span class="c-num">2</span>] <span class="c-com"># Fila 1, Columna 2 -> 2.3</span>`;
                }
                
                if(p.struct.includes('Dataframe')) {
                    return `<span class="c-com"># 3. EL DATAFRAME: Tablas clínicas reales</span>
<span class="c-com"># HETEROGÉNEO: Mezcla texto, números y factores</span>

<span class="c-var">df_clinico</span> <span class="c-op"><-</span> <span class="c-fn">data.frame</span>(
  <span class="c-arg">ID</span> = <span class="c-num">1</span>:<span class="c-num">4</span>,
  <span class="c-arg">Grupo</span> = <span class="c-fn">factor</span>(<span class="c-fn">c</span>(<span class="c-str">"Ctrl"</span>, <span class="c-str">"Trat"</span>, <span class="c-str">"Trat"</span>, <span class="c-str">"Ctrl"</span>)),
  <span class="c-arg">Edad</span> = <span class="c-fn">c</span>(<span class="c-num">25</span>, <span class="c-num">34</span>, <span class="c-num">28</span>, <span class="c-num">52</span>),
  <span class="c-arg">Alta</span> = <span class="c-fn">c</span>(<span class="c-kwd">F</span>, <span class="c-kwd">T</span>, <span class="c-kwd">T</span>, <span class="c-kwd">F</span>)
)

<span class="c-com"># Acceso a columna completa con $</span>
<span class="c-var">df_clinico</span><span class="c-op">$</span>Edad <span class="c-com"># c(25, 34, 28, 52)</span>`;
                }
                
                return `<span class="c-com"># 4. LA LISTA: El "Super Contenedor"</span>
<span class="c-com"># Jerárquica: Guarda objetos de diferente tamaño</span>

<span class="c-var">resultado</span> <span class="c-op"><-</span> <span class="c-fn">list</span>(
  <span class="c-arg">meta</span> = <span class="c-str">"Estudio Fase 3"</span>,
  <span class="c-arg">valores</span> = <span class="c-fn">c</span>(<span class="c-num">10</span>, <span class="c-num">20</span>, <span class="c-num">30</span>),
  <span class="c-arg">tabla</span> = <span class="c-var">df_clinico</span>
)

<span class="c-com"># R devuelve modelos estadísticos (lm, glm, pca) como listas</span>
<span class="c-var">resultado</span><span class="c-op">[[</span><span class="c-num">2</span><span class="c-op">]]</span> <span class="c-com"># Accede al segundo objeto</span>`;
            },
            explain: (p) => {
                const theories = {
                    'Vector (c)': `<h3>1. El Vector (Atomic Vector)</h3>
                    <p>Es una secuencia ordenada de datos del <b>mismo tipo</b>.</p>
                    <div class="theory-highlight">
                        <b>Simulación Visual:</b><br>
                        Observa cómo cada casilla tiene un <b>Índice [i]</b> abajo. R empieza a contar desde 1, no desde 0.
                    </div>`,
                    
                    'Matriz (matrix)': `<h3>2. La Matriz (Heatmap)</h3>
                    <p>Estructura rectangular (Filas x Columnas) de datos <b>numéricos</b>.</p>
                    <div class="theory-highlight">
                        <b>Uso Bioinformático:</b><br>
                        Se usa para representar niveles de expresión. En la simulación, los colores más intensos indican valores más altos (como un Heatmap).
                    </div>`,
                    
                    'Dataframe (data.frame)': `<h3>3. El Dataframe</h3>
                    <p>Una colección de vectores (columnas) que pueden ser de <b>diferentes tipos</b>.</p>
                    <div class="theory-highlight">
                        <b>Tipos de Datos:</b><br>
                        • <span style="color:#3498db"><b>Int:</b></span> Números enteros (ID)<br>
                        • <span style="color:#e74c3c"><b>Fct:</b></span> Categorías (Grupo)<br>
                        • <span style="color:#2ecc71"><b>Num:</b></span> Continuos (Edad)<br>
                        • <span style="color:#f39c12"><b>Lgl:</b></span> Lógica T/F (Alta)
                    </div>`,
                    
                    'Lista (list)': `<h3>4. La Lista (Jerarquía)</h3>
                    <p>No es una tabla, es un <b>contenedor flexible</b>. Puede contener vectores, dataframes e incluso otras listas.</p>
                    <div class="theory-highlight">
                        <b>Analogía:</b><br>
                        Si el vector es un átomo, la lista es la molécula compleja. Es lo que devuelve cualquier test estadístico (ej. <code>lm()</code>).
                    </div>`
                };
                return theories[p.struct] || theories['Vector (c)'];
            },
            render: (p, div) => {
                // --- SETUP DEL LIENZO SVG ---
                div.style.alignItems = "flex-start";
                div.style.justifyContent = "center";
                div.style.paddingTop = "20px";
                div.innerHTML = '';
                
                // Lienzo base de 600x400
                const svg = createSVG("100%", "400", "0 0 600 400");
                svg.style.display = "block";
                
                // Fondo blanco
                const bg = document.createElementNS(svgNS, "rect");
                bg.setAttribute("width", "600");
                bg.setAttribute("height", "400");
                bg.setAttribute("fill", "white");
                svg.appendChild(bg);
                
                const type = p.struct.split(' ')[0];

                // Título
                const title = document.createElementNS(svgNS, "text");
                title.setAttribute("x", "300");
                title.setAttribute("y", "40");
                title.setAttribute("text-anchor", "middle");
                title.setAttribute("font-size", "16");
                title.setAttribute("font-weight", "bold");
                title.setAttribute("fill", "#2c3e50");
                title.textContent = `Estructura: ${type}`;
                svg.appendChild(title);

                if(type === 'Vector') {
                    // --- SIMULACIÓN VECTOR (CINTA DE MEMORIA) ---
                    const data = [95, 110, 88, 145, 120];
                    const startX = 100;
                    const startY = 150;
                    const boxSize = 80;

                    const label = document.createElementNS(svgNS, "text");
                    label.setAttribute("x", "100"); label.setAttribute("y", "130");
                    label.setAttribute("font-size", "12"); label.setAttribute("fill", "#7f8c8d");
                    label.textContent = "numeric vector (homogéneo)";
                    svg.appendChild(label);

                    data.forEach((val, i) => {
                        const g = document.createElementNS(svgNS, "g");
                        
                        // Caja del valor
                        const rect = document.createElementNS(svgNS, "rect");
                        rect.setAttribute("x", startX + i * boxSize);
                        rect.setAttribute("y", startY);
                        rect.setAttribute("width", boxSize);
                        rect.setAttribute("height", boxSize);
                        rect.setAttribute("fill", "#3498db");
                        rect.setAttribute("stroke", "white");
                        rect.setAttribute("stroke-width", "2");
                        g.appendChild(rect);
                        
                        // Valor
                        const text = document.createElementNS(svgNS, "text");
                        text.setAttribute("x", startX + i * boxSize + boxSize/2);
                        text.setAttribute("y", startY + boxSize/2 + 5);
                        text.setAttribute("text-anchor", "middle");
                        text.setAttribute("font-size", "18");
                        text.setAttribute("fill", "white");
                        text.setAttribute("font-weight", "bold");
                        text.textContent = val;
                        g.appendChild(text);
                        
                        // Índice
                        const idxBox = document.createElementNS(svgNS, "rect");
                        idxBox.setAttribute("x", startX + i * boxSize);
                        idxBox.setAttribute("y", startY + boxSize + 5);
                        idxBox.setAttribute("width", boxSize);
                        idxBox.setAttribute("height", "25");
                        idxBox.setAttribute("fill", "#ecf0f1");
                        g.appendChild(idxBox);

                        const idxText = document.createElementNS(svgNS, "text");
                        idxText.setAttribute("x", startX + i * boxSize + boxSize/2);
                        idxText.setAttribute("y", startY + boxSize + 22);
                        idxText.setAttribute("text-anchor", "middle");
                        idxText.setAttribute("font-size", "12");
                        idxText.setAttribute("fill", "#7f8c8d");
                        idxText.setAttribute("font-family", "monospace");
                        idxText.textContent = `[${i+1}]`;
                        g.appendChild(idxText);
                        
                        svg.appendChild(g);
                    });

                } else if (type === 'Matriz') {
                    // --- SIMULACIÓN MATRIZ (HEATMAP) ---
                    const matrixData = [
                        [1.2, 2.3, 0.5],
                        [1.1, 2.4, 0.6],
                        [3.5, 1.1, 0.2]
                    ];
                    const rows = ["BRCA1", "TP53", "EGFR"];
                    const cols = ["M1", "M2", "M3"];
                    
                    const startX = 150;
                    const startY = 100;
                    const cellSize = 80;
                    
                    cols.forEach((c, i) => {
                        const text = document.createElementNS(svgNS, "text");
                        text.setAttribute("x", startX + i * cellSize + cellSize/2);
                        text.setAttribute("y", startY - 10);
                        text.setAttribute("text-anchor", "middle");
                        text.setAttribute("font-weight", "bold");
                        text.setAttribute("fill", "#2c3e50");
                        text.textContent = c;
                        svg.appendChild(text);
                    });
                    
                    matrixData.forEach((row, r) => {
                        const rText = document.createElementNS(svgNS, "text");
                        rText.setAttribute("x", startX - 15);
                        rText.setAttribute("y", startY + r * cellSize + cellSize/2 + 5);
                        rText.setAttribute("text-anchor", "end");
                        rText.setAttribute("font-weight", "bold");
                        rText.setAttribute("fill", "#2c3e50");
                        rText.textContent = rows[r];
                        svg.appendChild(rText);
                        
                        row.forEach((val, c) => {
                            const g = document.createElementNS(svgNS, "g");
                            const opacity = (val / 3.5).toFixed(2);
                            
                            const rect = document.createElementNS(svgNS, "rect");
                            rect.setAttribute("x", startX + c * cellSize);
                            rect.setAttribute("y", startY + r * cellSize);
                            rect.setAttribute("width", cellSize);
                            rect.setAttribute("height", cellSize);
                            rect.setAttribute("fill", "#e74c3c"); 
                            rect.setAttribute("fill-opacity", Math.max(0.1, opacity));
                            rect.setAttribute("stroke", "white");
                            rect.setAttribute("stroke-width", "2");
                            g.appendChild(rect);
                            
                            const text = document.createElementNS(svgNS, "text");
                            text.setAttribute("x", startX + c * cellSize + cellSize/2);
                            text.setAttribute("y", startY + r * cellSize + cellSize/2 + 5);
                            text.setAttribute("text-anchor", "middle");
                            text.setAttribute("font-size", "16");
                            text.setAttribute("font-weight", "bold");
                            text.setAttribute("fill", "#2c3e50");
                            text.textContent = val;
                            g.appendChild(text);
                            
                            svg.appendChild(g);
                        });
                    });
                    
                    const note = document.createElementNS(svgNS, "text");
                    note.setAttribute("x", "300"); note.setAttribute("y", "380");
                    note.setAttribute("text-anchor", "middle"); note.setAttribute("fill", "#7f8c8d");
                    note.textContent = "Los valores numéricos determinan la intensidad del color (Heatmap)";
                    svg.appendChild(note);

                } else if (type === 'Dataframe') {
                    // --- SIMULACIÓN DATAFRAME ---
                    const startX = 100;
                    const startY = 80;
                    const colWidth = 90;
                    const rowHeight = 40;
                    
                    const headers = [
                        {name: "ID", type: "int", color: "#3498db"},
                        {name: "Grupo", type: "fct", color: "#e74c3c"},
                        {name: "Edad", type: "num", color: "#2ecc71"},
                        {name: "Alta", type: "lgl", color: "#f39c12"}
                    ];
                    
                    const data = [
                        ["1", "Ctrl", "25", "F"],
                        ["2", "Trat", "34", "T"],
                        ["3", "Trat", "28", "T"],
                        ["4", "Ctrl", "52", "F"]
                    ];
                    
                    headers.forEach((h, i) => {
                        const g = document.createElementNS(svgNS, "g");
                        const x = startX + i * colWidth;
                        
                        const rect = document.createElementNS(svgNS, "rect");
                        rect.setAttribute("x", x); rect.setAttribute("y", startY);
                        rect.setAttribute("width", colWidth); rect.setAttribute("height", rowHeight);
                        rect.setAttribute("fill", "#2c3e50");
                        rect.setAttribute("stroke", "white");
                        g.appendChild(rect);
                        
                        const text = document.createElementNS(svgNS, "text");
                        text.setAttribute("x", x + colWidth/2); text.setAttribute("y", startY + 18);
                        text.setAttribute("text-anchor", "middle"); text.setAttribute("fill", "white");
                        text.setAttribute("font-size", "12"); text.textContent = h.name;
                        g.appendChild(text);
                        
                        const typeRect = document.createElementNS(svgNS, "rect");
                        typeRect.setAttribute("x", x + colWidth/2 - 15); typeRect.setAttribute("y", startY + 24);
                        typeRect.setAttribute("width", "30"); typeRect.setAttribute("height", "12");
                        typeRect.setAttribute("rx", "6"); typeRect.setAttribute("fill", h.color);
                        g.appendChild(typeRect);
                        
                        const typeText = document.createElementNS(svgNS, "text");
                        typeText.setAttribute("x", x + colWidth/2); typeText.setAttribute("y", startY + 33);
                        typeText.setAttribute("text-anchor", "middle");
                        typeText.setAttribute("font-size", "9"); typeText.setAttribute("fill", "white");
                        typeText.setAttribute("font-weight", "bold"); typeText.textContent = h.type;
                        g.appendChild(typeText);
                        
                        svg.appendChild(g);
                    });
                    
                    data.forEach((row, r) => {
                        row.forEach((cell, c) => {
                            const x = startX + c * colWidth;
                            const y = startY + rowHeight + r * rowHeight;
                            
                            const rect = document.createElementNS(svgNS, "rect");
                            rect.setAttribute("x", x); rect.setAttribute("y", y);
                            rect.setAttribute("width", colWidth); rect.setAttribute("height", rowHeight);
                            rect.setAttribute("fill", r % 2 === 0 ? "#ecf0f1" : "white");
                            rect.setAttribute("stroke", "#bdc3c7");
                            svg.appendChild(rect);
                            
                            const text = document.createElementNS(svgNS, "text");
                            text.setAttribute("x", x + colWidth/2); text.setAttribute("y", y + 25);
                            text.setAttribute("text-anchor", "middle"); 
                            text.setAttribute("fill", "#2c3e50");
                            if(c === 1) text.setAttribute("font-weight", "bold");
                            if(c === 3) text.setAttribute("fill", cell === "T" ? "#27ae60" : "#e74c3c");
                            
                            text.textContent = cell;
                            svg.appendChild(text);
                        });
                    });

                } else if (type === 'Lista') {
                    // --- SIMULACIÓN LISTA (DISEÑO ARREGLADO: TARJETAS VERTICALES) ---
                    const startX = 120;
                    const startY = 80;
                    const cardWidth = 360;
                    const cardHeight = 65;
                    const gap = 15;
                    
                    const items = [
                        {key: "$info_hospital", val: '"Hospital General"', type: "character", color: "#3498db"},
                        {key: "$fecha", val: "2023-10-27", type: "date", color: "#e74c3c"},
                        {key: "$estadisticas", val: "media: 120 | sd: 15", type: "numeric", color: "#2ecc71"},
                        {key: "$datos_brutos", val: "[Dataframe 4x4]", type: "data.frame", color: "#f39c12"}
                    ];
                    
                    // Texto header
                    const headerInfo = document.createElementNS(svgNS, "text");
                    headerInfo.setAttribute("x", "300"); headerInfo.setAttribute("y", "65");
                    headerInfo.setAttribute("text-anchor", "middle");
                    headerInfo.setAttribute("font-size", "12"); headerInfo.setAttribute("fill", "#7f8c8d");
                    headerInfo.textContent = "List of length 4";
                    svg.appendChild(headerInfo);

                    items.forEach((item, i) => {
                        const y = startY + i * (cardHeight + gap);
                        const group = document.createElementNS(svgNS, "g");
                        
                        // Sombra
                        const shadow = document.createElementNS(svgNS, "rect");
                        shadow.setAttribute("x", startX + 3); shadow.setAttribute("y", y + 3);
                        shadow.setAttribute("width", cardWidth); shadow.setAttribute("height", cardHeight);
                        shadow.setAttribute("rx", "6"); shadow.setAttribute("fill", "#ecf0f1");
                        group.appendChild(shadow);

                        // Tarjeta blanca
                        const card = document.createElementNS(svgNS, "rect");
                        card.setAttribute("x", startX); card.setAttribute("y", y);
                        card.setAttribute("width", cardWidth); card.setAttribute("height", cardHeight);
                        card.setAttribute("rx", "6"); card.setAttribute("fill", "white");
                        card.setAttribute("stroke", "#bdc3c7"); card.setAttribute("stroke-width", "1");
                        group.appendChild(card);
                        
                        // Barra color
                        const bar = document.createElementNS(svgNS, "path");
                        bar.setAttribute("d", `M ${startX} ${y+6} L ${startX} ${y+cardHeight-6} L ${startX+6} ${y+cardHeight-6} L ${startX+6} ${y+6} Z`);
                        bar.setAttribute("stroke", item.color); bar.setAttribute("stroke-width", "4");
                        bar.setAttribute("stroke-linecap", "round");
                        group.appendChild(bar);
                        
                        // Clave ($...)
                        const keyText = document.createElementNS(svgNS, "text");
                        keyText.setAttribute("x", startX + 25); keyText.setAttribute("y", y + 25);
                        keyText.setAttribute("font-family", "monospace"); keyText.setAttribute("font-size", "13");
                        keyText.setAttribute("fill", "#7f8c8d");
                        keyText.textContent = item.key;
                        group.appendChild(keyText);
                        
                        // Valor
                        const valText = document.createElementNS(svgNS, "text");
                        valText.setAttribute("x", startX + 25); valText.setAttribute("y", y + 48);
                        valText.setAttribute("font-weight", "bold"); valText.setAttribute("font-size", "14");
                        valText.setAttribute("fill", "#2c3e50");
                        valText.textContent = item.val;
                        group.appendChild(valText);
                        
                        // Tipo (Badge)
                        const typeRect = document.createElementNS(svgNS, "rect");
                        typeRect.setAttribute("x", startX + cardWidth - 90); typeRect.setAttribute("y", y + 20);
                        typeRect.setAttribute("width", "75"); typeRect.setAttribute("height", "25");
                        typeRect.setAttribute("rx", "12"); typeRect.setAttribute("fill", item.color);
                        typeRect.setAttribute("opacity", "0.1");
                        group.appendChild(typeRect);
                        
                        const typeText = document.createElementNS(svgNS, "text");
                        typeText.setAttribute("x", startX + cardWidth - 52); typeText.setAttribute("y", y + 36);
                        typeText.setAttribute("text-anchor", "middle"); typeText.setAttribute("font-size", "10");
                        typeText.setAttribute("font-weight", "bold"); typeText.setAttribute("fill", item.color);
                        typeText.textContent = item.type;
                        group.appendChild(typeText);

                        svg.appendChild(group);
                    });
                }
                
                div.appendChild(svg);
            }
        },
                {
            id: 2,
            title: "2. Tidyverse: Manipulación de Datos",
            icon: "fa-filter",
            controls: [
                {id: 'func', type: 'select', label: 'Verbo dplyr', 
                 options: ['filter()', 'select()', 'mutate()', 'group_by() %>% summarize()']}
            ],
            code: (p) => {
                const base = `<span class="c-kwd">library</span>(tidyverse)

<span class="c-com"># Dataset: 'pacientes' con columnas: ID, Grupo, Edad, IMC, Estado</span>
`;
                
                switch(p.func) {
                    case 'filter()':
                        return base + `<span class="c-var">subgrupo</span> <span class="c-op"><-</span> <span class="c-var">pacientes</span> <span class="c-op">%>%</span>
  <span class="c-fn">filter</span>(Grupo <span class="c-op">==</span> <span class="c-str">"Control"</span> <span class="c-op">&</span> Edad <span class="c-op">></span> <span class="c-num">50</span>)

<span class="c-com"># Resultado: Solo filas que cumplen ambas condiciones</span>`;
                    
                    case 'select()':
                        return base + `<span class="c-var">datos_reducidos</span> <span class="c-op"><-</span> <span class="c-var">pacientes</span> <span class="c-op">%>%</span>
  <span class="c-fn">select</span>(ID, IMC)

<span class="c-com"># También: select(-Estado) para eliminar columnas</span>`;
                    
                    case 'mutate()':
                        return base + `<span class="c-var">pacientes_riesgo</span> <span class="c-op"><-</span> <span class="c-var">pacientes</span> <span class="c-op">%>%</span>
  <span class="c-fn">mutate</span>(
    <span class="c-arg">Riesgo</span> = <span class="c-fn">ifelse</span>(IMC <span class="c-op">></span> <span class="c-num">30</span>, <span class="c-str">"Alto"</span>, <span class="c-str">"Normal"</span>),
    <span class="c-arg">IMC_ajustado</span> = IMC <span class="c-op">*</span> <span class="c-num">0.95</span>
  )`;
                    
                    default:
                        return base + `<span class="c-var">resumen_estudio</span> <span class="c-op"><-</span> <span class="c-var">pacientes</span> <span class="c-op">%>%</span>
  <span class="c-fn">group_by</span>(Grupo) <span class="c-op">%>%</span>
  <span class="c-fn">summarize</span>(
    <span class="c-arg">Media_Edad</span> = <span class="c-fn">mean</span>(Edad, <span class="c-arg">na.rm</span>=<span class="c-kwd">TRUE</span>),
    <span class="c-arg">Max_IMC</span> = <span class="c-fn">max</span>(IMC),
    <span class="c-arg">Total_n</span> = <span class="c-fn">n</span>()
  )`;
                }
            },
            explain: (p) => {
                const verb = p.func.replace('()', '');
                return `<h3>La Filosofía Tidyverse</h3>
                <p>El paquete <code>tidyverse</code> proporciona una gramática coherente para manipulación de datos.</p>
                <div class="theory-highlight">
                    <b>El Operador Pipe (<code>%>%</code>)</b><br>
                    Se lee como "y entonces...". Encadena operaciones de izquierda a derecha.
                </div>
                <p><b>Verbo seleccionado: <code>${verb}</code></b></p>
                <ul>
                    <li><b>filter:</b> Selecciona filas basadas en condiciones lógicas.</li>
                    <li><b>select:</b> Selecciona columnas por nombre o patrón.</li>
                    <li><b>mutate:</b> Crea nuevas columnas o modifica existentes.</li>
                    <li><b>group_by + summarize:</b> Agrupa datos y calcula estadísticas por grupo.</li>
                </ul>`;
            },
            render: (p, div) => {
                // 1. CORRECCIÓN DE ALINEACIÓN: Pegar todo arriba
                div.style.alignItems = "flex-start";
                div.style.justifyContent = "center";
                div.style.paddingTop = "20px";
                div.innerHTML = '';
                
                // 2. LIENZO MÁS ANCHO (750px) para que quepan las tablas lado a lado
                // Usamos height="400" fijo para evitar scroll innecesario
                const svg = createSVG("100%", "400", "0 0 750 400");
                svg.style.display = "block";
                
                // Fondo
                const bg = document.createElementNS(svgNS, "rect");
                bg.setAttribute("width", "750");
                bg.setAttribute("height", "400");
                bg.setAttribute("fill", "white");
                svg.appendChild(bg);
                
                // Título
                const title = document.createElementNS(svgNS, "text");
                title.setAttribute("x", "375"); // Centrado en 750
                title.setAttribute("y", "30");
                title.setAttribute("text-anchor", "middle");
                title.setAttribute("font-size", "16");
                title.setAttribute("font-weight", "bold");
                title.setAttribute("fill", "#2c3e50");
                title.textContent = `Transformación: ${p.func}`;
                svg.appendChild(title);
                
                // Datos base
                const data = [
                    {ID: 1, Grupo: "Ctrl", Edad: 25, IMC: 22},
                    {ID: 2, Grupo: "Trat", Edad: 55, IMC: 31},
                    {ID: 3, Grupo: "Ctrl", Edad: 60, IMC: 28},
                    {ID: 4, Grupo: "Trat", Edad: 30, IMC: 29}
                ];
                
                // --- COORDENADAS AJUSTADAS ---
                const leftX = 30;   // Tabla izquierda pegada al borde
                const rightX = 380; // Tabla derecha con suficiente margen
                const tableY = 70;  // Bajamos un poco para no chocar con título
                
                // Dibujar tabla original
                drawTable(svg, leftX, tableY, "Datos Originales", data, p.func);
                
                // Flecha de transformación
                const arrowY = tableY + 70;
                const arrow = document.createElementNS(svgNS, "path");
                arrow.setAttribute("d", `M ${leftX + 250} ${arrowY} L ${rightX - 20} ${arrowY}`);
                arrow.setAttribute("stroke", "#e67e22");
                arrow.setAttribute("stroke-width", "3");
                arrow.setAttribute("fill", "none");
                arrow.setAttribute("marker-end", "url(#arrow_tid)");
                svg.appendChild(arrow);
                
                // Dibujar tabla transformada
                drawTransformedTable(svg, rightX, tableY, p.func, data);
                
                // Definir marcador
                const defs = document.createElementNS(svgNS, "defs");
                defs.innerHTML = `<marker id="arrow_tid" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#e67e22"/>
                </marker>`;
                svg.appendChild(defs);
                
                div.appendChild(svg);
                
                // --- FUNCIONES INTERNAS ACTUALIZADAS ---
                function drawTable(svg, x, y, title, data, func) {
                    const titleText = document.createElementNS(svgNS, "text");
                    titleText.setAttribute("x", x + 120);
                    titleText.setAttribute("y", y - 10);
                    titleText.setAttribute("text-anchor", "middle");
                    titleText.setAttribute("font-size", "12");
                    titleText.setAttribute("fill", "#7f8c8d");
                    titleText.textContent = title;
                    svg.appendChild(titleText);
                    
                    const headers = ["ID", "Grupo", "Edad", "IMC"];
                    headers.forEach((h, i) => {
                        const rect = document.createElementNS(svgNS, "rect");
                        rect.setAttribute("x", x + i * 60); rect.setAttribute("y", y);
                        rect.setAttribute("width", 60); rect.setAttribute("height", 30);
                        rect.setAttribute("fill", "#2c3e50"); rect.setAttribute("rx", "4");
                        svg.appendChild(rect);
                        
                        const text = document.createElementNS(svgNS, "text");
                        text.setAttribute("x", x + i * 60 + 30); text.setAttribute("y", y + 20);
                        text.setAttribute("text-anchor", "middle"); text.setAttribute("font-size", "11");
                        text.setAttribute("fill", "white"); text.textContent = h;
                        svg.appendChild(text);
                    });
                    
                    data.forEach((row, rIndex) => {
                        const cells = [row.ID, row.Grupo, row.Edad, row.IMC];
                        let rowFill = "#ecf0f1";
                        if (func === 'filter()' && row.Edad > 50 && row.Grupo === "Ctrl") {
                            rowFill = "#d4edda";
                        } else if (func === 'filter()') {
                            rowFill = "#f8d7da";
                        }
                        
                        cells.forEach((cell, cIndex) => {
                            const rect = document.createElementNS(svgNS, "rect");
                            rect.setAttribute("x", x + cIndex * 60); rect.setAttribute("y", y + 30 + rIndex * 30);
                            rect.setAttribute("width", 60); rect.setAttribute("height", 30);
                            rect.setAttribute("fill", rowFill); rect.setAttribute("stroke", "#bdc3c7");
                            rect.setAttribute("stroke-width", "1");
                            svg.appendChild(rect);
                            
                            const text = document.createElementNS(svgNS, "text");
                            text.setAttribute("x", x + cIndex * 60 + 30); text.setAttribute("y", y + 30 + rIndex * 30 + 20);
                            text.setAttribute("text-anchor", "middle"); text.setAttribute("font-size", "11");
                            text.setAttribute("fill", "#2c3e50"); text.textContent = cell;
                            svg.appendChild(text);
                        });
                    });
                }
                
                function drawTransformedTable(svg, x, y, func, data) {
                    let title = "";
                    let transformedData = [];
                    // Mapeo seguro de columnas para evitar errores undefined
                    let headers = [];
                    let keys = []; 

                    switch(func) {
                        case 'filter()':
                            title = "filter(Grupo=='Ctrl' & Edad>50)";
                            transformedData = data.filter(d => d.Grupo === "Ctrl" && d.Edad > 50);
                            headers = ["ID", "Grupo", "Edad", "IMC"];
                            keys = ["ID", "Grupo", "Edad", "IMC"];
                            break;
                        case 'select()':
                            title = "select(ID, IMC)";
                            transformedData = data.map(d => ({ID: d.ID, IMC: d.IMC}));
                            headers = ["ID", "IMC"];
                            keys = ["ID", "IMC"];
                            break;
                        case 'mutate()':
                            title = "mutate(Riesgo = ...)";
                            transformedData = data.map(d => ({
                                ...d,
                                Riesgo: d.IMC > 30 ? "Alto" : "Normal"
                            }));
                            // Abreviamos Grupo a Grp para ahorrar espacio
                            headers = ["ID", "Grp", "Edad", "IMC", "Riesgo"];
                            keys = ["ID", "Grupo", "Edad", "IMC", "Riesgo"];
                            break;
                        case 'group_by() %>% summarize()':
                            title = "summarize(media...)";
                            const grupos = {};
                            data.forEach(d => {
                                if (!grupos[d.Grupo]) grupos[d.Grupo] = {count: 0, totalIMC: 0};
                                grupos[d.Grupo].count++;
                                grupos[d.Grupo].totalIMC += d.IMC;
                            });
                            transformedData = Object.keys(grupos).map(g => ({
                                Grupo: g,
                                n: grupos[g].count,
                                Media_IMC: (grupos[g].totalIMC / grupos[g].count).toFixed(1)
                            }));
                            headers = ["Grupo", "n", "Media"];
                            keys = ["Grupo", "n", "Media_IMC"];
                            break;
                    }
                    
                    const titleText = document.createElementNS(svgNS, "text");
                    titleText.setAttribute("x", x + 100);
                    titleText.setAttribute("y", y - 10);
                    titleText.setAttribute("text-anchor", "middle");
                    titleText.setAttribute("font-size", "12");
                    titleText.setAttribute("fill", "#27ae60");
                    titleText.textContent = title;
                    svg.appendChild(titleText);
                    
                    // Dibujar Encabezados
                    headers.forEach((h, i) => {
                        const rect = document.createElementNS(svgNS, "rect");
                        rect.setAttribute("x", x + i * 60); rect.setAttribute("y", y);
                        rect.setAttribute("width", 60); rect.setAttribute("height", 30);
                        rect.setAttribute("fill", "#27ae60"); rect.setAttribute("rx", "4");
                        svg.appendChild(rect);
                        
                        const text = document.createElementNS(svgNS, "text");
                        text.setAttribute("x", x + i * 60 + 30); text.setAttribute("y", y + 20);
                        text.setAttribute("text-anchor", "middle"); text.setAttribute("font-size", "10");
                        text.setAttribute("fill", "white"); text.textContent = h;
                        svg.appendChild(text);
                    });
                    
                    // Dibujar Filas
                    transformedData.forEach((row, rIndex) => {
                        // Extraer valores usando las llaves correctas
                        const cells = keys.map(k => row[k]);
                        
                        cells.forEach((cell, cIndex) => {
                            const rect = document.createElementNS(svgNS, "rect");
                            rect.setAttribute("x", x + cIndex * 60); rect.setAttribute("y", y + 30 + rIndex * 30);
                            rect.setAttribute("width", 60); rect.setAttribute("height", 30);
                            rect.setAttribute("fill", "#d4edda"); rect.setAttribute("stroke", "#c3e6cb");
                            rect.setAttribute("stroke-width", "1");
                            svg.appendChild(rect);
                            
                            const text = document.createElementNS(svgNS, "text");
                            text.setAttribute("x", x + cIndex * 60 + 30); text.setAttribute("y", y + 30 + rIndex * 30 + 20);
                            text.setAttribute("text-anchor", "middle"); text.setAttribute("font-size", "11");
                            text.setAttribute("fill", "#155724"); text.textContent = cell;
                            svg.appendChild(text);
                        });
                    });
                }
                        }
        },
        {
            id: 3,
            title: "3. Gráficos Profesionales: ggplot2",
            icon: "fa-chart-area",
            controls: [
                {id: 'geom', type: 'select', label: 'Geometría', 
                 options: ['geom_point()', 'geom_boxplot()', 'geom_histogram()', 'geom_smooth()']}
            ],
            code: (p) => {
                const base = `<span class="c-kwd">library</span>(ggplot2)

<span class="c-com"># La gramática de gráficos: Data + Aesthetics + Geometry</span>
`;
                
                switch(p.geom) {
                    case 'geom_point()':
                        return base + `<span class="c-fn">ggplot</span>(
  <span class="c-arg">data</span> = pacientes,
  <span class="c-fn">aes</span>(<span class="c-arg">x</span> = Edad, <span class="c-arg">y</span> = Glucosa, <span class="c-arg">color</span> = Grupo)
) <span class="c-op">+</span>
  <span class="c-fn">geom_point</span>(<span class="c-arg">size</span> = <span class="c-num">3</span>, <span class="c-arg">alpha</span> = <span class="c-num">0.8</span>) <span class="c-op">+</span>
  <span class="c-fn">theme_minimal</span>() <span class="c-op">+</span>
  <span class="c-fn">labs</span>(<span class="c-arg">title</span> = <span class="c-str">"Edad vs Glucosa"</span>)`;
                    
                    case 'geom_boxplot()':
                        return base + `<span class="c-fn">ggplot</span>(pacientes, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = Grupo, <span class="c-arg">y</span> = Glucosa)) <span class="c-op">+</span>
  <span class="c-fn">geom_boxplot</span>(<span class="c-arg">fill</span> = <span class="c-str">"steelblue"</span>, <span class="c-arg">alpha</span> = <span class="c-num">0.7</span>) <span class="c-op">+</span>
  <span class="c-fn">theme_bw</span>()`;
                    
                    case 'geom_histogram()':
                        return base + `<span class="c-fn">ggplot</span>(pacientes, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = Glucosa)) <span class="c-op">+</span>
  <span class="c-fn">geom_histogram</span>(
    <span class="c-arg">bins</span> = <span class="c-num">20</span>,
    <span class="c-arg">fill</span> = <span class="c-str">"#3498db"</span>,
    <span class="c-arg">color</span> = <span class="c-str">"white"</span>
  ) <span class="c-op">+</span>
  <span class="c-fn">labs</span>(<span class="c-arg">y</span> = <span class="c-str">"Frecuencia"</span>)`;
                    
                    case 'geom_smooth()':
                        return base + `<span class="c-fn">ggplot</span>(pacientes, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = Edad, <span class="c-arg">y</span> = Glucosa)) <span class="c-op">+</span>
  <span class="c-fn">geom_point</span>() <span class="c-op">+</span>
  <span class="c-fn">geom_smooth</span>(<span class="c-arg">method</span> = <span class="c-str">"lm"</span>, <span class="c-arg">se</span> = <span class="c-kwd">TRUE</span>)`;
                }
            },
            explain: (p) => {
                return `<h3>ggplot2: El estándar en visualización</h3>
                <p><code>ggplot2</code> construye gráficos capa por capa:</p>
                <ol>
                    <li><b>Lienzo:</b> <code>ggplot(data)</code></li>
                    <li><b>Estética (aes):</b> Mapea variables a propiedades visuales</li>
                    <li><b>Geometría (geom):</b> Decide cómo representar los datos (${p.geom})</li>
                </ol>
                <div class="theory-highlight">
                    <b>Filosofía de capas:</b><br>
                    Puedes superponer múltiples geometrías:<br>
                    <code>ggplot(...) + geom_point() + geom_smooth()</code>
                </div>`;
            },
            render: (p, div) => {
                div.innerHTML = '';
                const svg = createSVG("100%", "100%", "0 0 500 350");
                
                // Fondo
                const bg = document.createElementNS(svgNS, "rect");
                bg.setAttribute("width", "500");
                bg.setAttribute("height", "350");
                bg.setAttribute("fill", "white");
                svg.appendChild(bg);
                
                // Ejes
                const drawAxes = () => {
                    const g = document.createElementNS(svgNS, "g");
                    
                    // Eje Y
                    const yAxis = document.createElementNS(svgNS, "line");
                    yAxis.setAttribute("x1", "50");
                    yAxis.setAttribute("y1", "50");
                    yAxis.setAttribute("x2", "50");
                    yAxis.setAttribute("y2", "300");
                    yAxis.setAttribute("stroke", "#333");
                    yAxis.setAttribute("stroke-width", "1.5");
                    g.appendChild(yAxis);
                    
                    // Eje X
                    const xAxis = document.createElementNS(svgNS, "line");
                    xAxis.setAttribute("x1", "50");
                    xAxis.setAttribute("y1", "300");
                    xAxis.setAttribute("x2", "450");
                    xAxis.setAttribute("y2", "300");
                    xAxis.setAttribute("stroke", "#333");
                    xAxis.setAttribute("stroke-width", "1.5");
                    g.appendChild(xAxis);
                    
                    // Etiquetas
                    const xLabel = document.createElementNS(svgNS, "text");
                    xLabel.setAttribute("x", "250");
                    xLabel.setAttribute("y", "330");
                    xLabel.setAttribute("text-anchor", "middle");
                    xLabel.setAttribute("font-size", "12");
                    xLabel.setAttribute("fill", "#333");
                    xLabel.textContent = "Edad (años)";
                    g.appendChild(xLabel);
                    
                    const yLabel = document.createElementNS(svgNS, "text");
                    yLabel.setAttribute("x", "20");
                    yLabel.setAttribute("y", "175");
                    yLabel.setAttribute("text-anchor", "middle");
                    yLabel.setAttribute("font-size", "12");
                    yLabel.setAttribute("fill", "#333");
                    yLabel.setAttribute("transform", "rotate(-90 20,175)");
                    yLabel.textContent = "Glucosa (mg/dL)";
                    g.appendChild(yLabel);
                    
                    return g;
                };
                
                svg.appendChild(drawAxes());
                
                // Generar datos según la geometría
                if (p.geom === 'geom_point()' || p.geom === 'geom_smooth()') {
                    // Datos correlacionados
                    for (let i = 0; i < 40; i++) {
                        const age = 20 + Math.random() * 60;
                        const baseGlucose = 80 + age * 0.5;
                        const glucose = baseGlucose + (Math.random() - 0.5) * 30;
                        
                        const point = document.createElementNS(svgNS, "circle");
                        point.setAttribute("cx", 50 + (age - 20) * 6);
                        point.setAttribute("cy", 300 - (glucose - 80) * 2);
                        point.setAttribute("r", "4");
                        point.setAttribute("fill", i % 2 === 0 ? "#e74c3c" : "#3498db");
                        point.setAttribute("opacity", "0.7");
                        svg.appendChild(point);
                    }
                    
                    if (p.geom === 'geom_smooth()') {
                        // Línea de regresión
                        const line = document.createElementNS(svgNS, "path");
                        line.setAttribute("d", "M 50 280 L 450 140");
                        line.setAttribute("stroke", "#e74c3c");
                        line.setAttribute("stroke-width", "3");
                        line.setAttribute("fill", "none");
                        svg.appendChild(line);
                        
                        // Banda de confianza
                        const band = document.createElementNS(svgNS, "path");
                        band.setAttribute("d", "M 50 270 L 450 130 L 450 150 L 50 290 Z");
                        band.setAttribute("fill", "#e74c3c");
                        band.setAttribute("opacity", "0.2");
                        svg.appendChild(band);
                    }
                }
                else if (p.geom === 'geom_boxplot()') {
                    // Dibujar boxplots
                    const drawBoxplot = (x, values, color) => {
                        const g = document.createElementNS(svgNS, "g");
                        
                        // Calcular estadísticas
                        const sorted = [...values].sort((a, b) => a - b);
                        const q1 = sorted[Math.floor(sorted.length * 0.25)];
                        const median = sorted[Math.floor(sorted.length * 0.5)];
                        const q3 = sorted[Math.floor(sorted.length * 0.75)];
                        const iqr = q3 - q1;
                        const min = Math.max(sorted[0], q1 - 1.5 * iqr);
                        const max = Math.min(sorted[sorted.length - 1], q3 + 1.5 * iqr);
                        
                        // Caja
                        const box = document.createElementNS(svgNS, "rect");
                        box.setAttribute("x", x - 20);
                        box.setAttribute("y", 300 - q3 * 2);
                        box.setAttribute("width", "40");
                        box.setAttribute("height", (q3 - q1) * 2);
                        box.setAttribute("fill", color);
                        box.setAttribute("opacity", "0.7");
                        g.appendChild(box);
                        
                        // Mediana
                        const medianLine = document.createElementNS(svgNS, "line");
                        medianLine.setAttribute("x1", x - 20);
                        medianLine.setAttribute("y1", 300 - median * 2);
                        medianLine.setAttribute("x2", x + 20);
                        medianLine.setAttribute("y2", 300 - median * 2);
                        medianLine.setAttribute("stroke", "white");
                        medianLine.setAttribute("stroke-width", "2");
                        g.appendChild(medianLine);
                        
                        // Bigotes
                        const whiskerTop = document.createElementNS(svgNS, "line");
                        whiskerTop.setAttribute("x1", x);
                        whiskerTop.setAttribute("y1", 300 - max * 2);
                        whiskerTop.setAttribute("x2", x);
                        whiskerTop.setAttribute("y2", 300 - q3 * 2);
                        whiskerTop.setAttribute("stroke", "#333");
                        whiskerTop.setAttribute("stroke-width", "1.5");
                        g.appendChild(whiskerTop);
                        
                        const whiskerBottom = document.createElementNS(svgNS, "line");
                        whiskerBottom.setAttribute("x1", x);
                        whiskerBottom.setAttribute("y1", 300 - q1 * 2);
                        whiskerBottom.setAttribute("x2", x);
                        whiskerBottom.setAttribute("y2", 300 - min * 2);
                        whiskerBottom.setAttribute("stroke", "#333");
                        whiskerBottom.setAttribute("stroke-width", "1.5");
                        g.appendChild(whiskerBottom);
                        
                        // Extremos
                        const capTop = document.createElementNS(svgNS, "line");
                        capTop.setAttribute("x1", x - 10);
                        capTop.setAttribute("y1", 300 - max * 2);
                        capTop.setAttribute("x2", x + 10);
                        capTop.setAttribute("y2", 300 - max * 2);
                        capTop.setAttribute("stroke", "#333");
                        capTop.setAttribute("stroke-width", "1.5");
                        g.appendChild(capTop);
                        
                        const capBottom = document.createElementNS(svgNS, "line");
                        capBottom.setAttribute("x1", x - 10);
                        capBottom.setAttribute("y1", 300 - min * 2);
                        capBottom.setAttribute("x2", x + 10);
                        capBottom.setAttribute("y2", 300 - min * 2);
                        capBottom.setAttribute("stroke", "#333");
                        capBottom.setAttribute("stroke-width", "1.5");
                        g.appendChild(capBottom);
                        
                        return g;
                    };
                    
                    // Datos para Control y Tratamiento
                    const controlData = Array.from({length: 30}, () => 85 + Math.random() * 20);
                    const treatmentData = Array.from({length: 30}, () => 75 + Math.random() * 15);
                    
                    svg.appendChild(drawBoxplot(200, controlData, "#3498db"));
                    svg.appendChild(drawBoxplot(300, treatmentData, "#e74c3c"));
                    
                    // Etiquetas
                    const controlLabel = document.createElementNS(svgNS, "text");
                    controlLabel.setAttribute("x", "200");
                    controlLabel.setAttribute("y", "320");
                    controlLabel.setAttribute("text-anchor", "middle");
                    controlLabel.setAttribute("font-size", "12");
                    controlLabel.setAttribute("fill", "#3498db");
                    controlLabel.textContent = "Control";
                    svg.appendChild(controlLabel);
                    
                    const treatmentLabel = document.createElementNS(svgNS, "text");
                    treatmentLabel.setAttribute("x", "300");
                    treatmentLabel.setAttribute("y", "320");
                    treatmentLabel.setAttribute("text-anchor", "middle");
                    treatmentLabel.setAttribute("font-size", "12");
                    treatmentLabel.setAttribute("fill", "#e74c3c");
                    treatmentLabel.textContent = "Tratamiento";
                    svg.appendChild(treatmentLabel);
                }
                else if (p.geom === 'geom_histogram()') {
                    // Generar datos normalmente distribuidos
                    const data = Array.from({length: 100}, () => {
                        return 80 + (Math.random() + Math.random() + Math.random() - 1.5) * 20;
                    });
                    
                    // Crear bins
                    const bins = Array(20).fill(0);
                    data.forEach(value => {
                        const binIndex = Math.min(19, Math.floor((value - 60) / 5));
                        if (binIndex >= 0 && binIndex < 20) {
                            bins[binIndex]++;
                        }
                    });
                    
                    // Dibujar histograma
                    const maxCount = Math.max(...bins);
                    bins.forEach((count, i) => {
                        if (count > 0) {
                            const bar = document.createElementNS(svgNS, "rect");
                            bar.setAttribute("x", 50 + i * 20);
                            bar.setAttribute("y", 300 - (count / maxCount) * 200);
                            bar.setAttribute("width", "18");
                            bar.setAttribute("height", (count / maxCount) * 200);
                            bar.setAttribute("fill", "#3498db");
                            bar.setAttribute("opacity", "0.8");
                            svg.appendChild(bar);
                        }
                    });
                }
                
                // Título
                const title = document.createElementNS(svgNS, "text");
                title.setAttribute("x", "250");
                title.setAttribute("y", "30");
                title.setAttribute("text-anchor", "middle");
                title.setAttribute("font-size", "14");
                title.setAttribute("font-weight", "bold");
                title.setAttribute("fill", "#2c3e50");
                title.textContent = `Gráfico: ${p.geom}`;
                svg.appendChild(title);
                
                div.appendChild(svg);
            }
        },
        {
            id: 4,
            title: "4. Fundamentos: Distribución Normal",
            icon: "fa-bell",
            controls: [
                {id: 'sd', type: 'range', label: 'Desviación Estándar (σ)', 
                 min: 5, max: 50, val: 15, step: 1}
            ],
            code: (p) => {
                return `<span class="c-com"># Generación de una Distribución Normal (Gaussiana)</span>
<span class="c-var">mu</span> <span class="c-op"><-</span> <span class="c-num">100</span>     <span class="c-com"># Media (Centro)</span>
<span class="c-var">sigma</span> <span class="c-op"><-</span> <span class="c-num">${p.sd}</span>   <span class="c-com"># Desviación Estándar</span>

<span class="c-com"># Generar secuencia del Eje X</span>
<span class="c-var">x</span> <span class="c-op"><-</span> <span class="c-fn">seq</span>(<span class="c-var">mu</span> - <span class="c-num">4</span>*<span class="c-var">sigma</span>, <span class="c-var">mu</span> + <span class="c-num">4</span>*<span class="c-var">sigma</span>, <span class="c-arg">length</span>=<span class="c-num">1000</span>)

<span class="c-com"># Calcular densidad de probabilidad</span>
<span class="c-var">y</span> <span class="c-op"><-</span> <span class="c-fn">dnorm</span>(<span class="c-var">x</span>, <span class="c-arg">mean</span>=<span class="c-var">mu</span>, <span class="c-arg">sd</span>=<span class="c-var">sigma</span>)

<span class="c-fn">plot</span>(<span class="c-var">x</span>, <span class="c-var">y</span>, <span class="c-arg">type</span>=<span class="c-str">"l"</span>, <span class="c-arg">col</span>=<span class="c-str">"blue"</span>, <span class="c-arg">lwd</span>=<span class="c-num">2</span>,
     <span class="c-arg">main</span>=<span class="c-str">"Campana de Gauss"</span>)
<span class="c-com"># Regla 68-95-99.7: El 95% de datos está entre µ ± 2σ</span>`;
            },
            explain: (p) => {
                const sd = parseInt(p.sd);
                return `<h3>La Distribución Normal</h3>
                <p>Modelo matemático fundamental en bioestadística. Muchos tests (T-test, ANOVA) asumen que los datos siguen esta distribución.</p>
                <ul>
                    <li><b>Media ($\\mu$):</b> Centro de la distribución (100)</li>
                    <li><b>Desviación Estándar ($\\sigma$):</b> Dispersión de los datos (${sd})</li>
                </ul>
                <div class="theory-highlight">
                    <b>Regla empírica 68-95-99.7:</b><br>
                    • 68% de datos en $\\mu \\pm \\sigma$ (${100 - sd} a ${100 + sd})<br>
                    • 95% de datos en $\\mu \\pm 2\\sigma$ (${100 - 2*sd} a ${100 + 2*sd})<br>
                    • 99.7% de datos en $\\mu \\pm 3\\sigma$ (${100 - 3*sd} a ${100 + 3*sd})
                </div>`;
            },
            render: (p, div) => {
                div.innerHTML = '';
                const svg = createSVG("100%", "100%", "0 0 500 350");
                
                // Fondo
                const bg = document.createElementNS(svgNS, "rect");
                bg.setAttribute("width", "500");
                bg.setAttribute("height", "350");
                bg.setAttribute("fill", "white");
                svg.appendChild(bg);
                
                const mu = 100;
                const sigma = parseInt(p.sd);
                
                // Ejes
                const axes = document.createElementNS(svgNS, "g");
                
                // Eje X
                const xAxis = document.createElementNS(svgNS, "line");
                xAxis.setAttribute("x1", "50");
                xAxis.setAttribute("y1", "300");
                xAxis.setAttribute("x2", "450");
                xAxis.setAttribute("y2", "300");
                xAxis.setAttribute("stroke", "#333");
                xAxis.setAttribute("stroke-width", "1.5");
                axes.appendChild(xAxis);
                
                // Eje Y
                const yAxis = document.createElementNS(svgNS, "line");
                yAxis.setAttribute("x1", "50");
                yAxis.setAttribute("y1", "50");
                yAxis.setAttribute("x2", "50");
                yAxis.setAttribute("y2", "300");
                yAxis.setAttribute("stroke", "#333");
                yAxis.setAttribute("stroke-width", "1.5");
                axes.appendChild(yAxis);
                
                // Marca de media
                const meanLine = document.createElementNS(svgNS, "line");
                meanLine.setAttribute("x1", "250");
                meanLine.setAttribute("y1", "50");
                meanLine.setAttribute("x2", "250");
                meanLine.setAttribute("y2", "300");
                meanLine.setAttribute("stroke", "#e74c3c");
                meanLine.setAttribute("stroke-width", "1");
                meanLine.setAttribute("stroke-dasharray", "5,5");
                axes.appendChild(meanLine);
                
                svg.appendChild(axes);
                
                // Calcular y dibujar curva normal
                const curve = document.createElementNS(svgNS, "path");
                let pathData = "";
                
                for (let i = 0; i <= 400; i += 2) {
                    const x = mu - 4*sigma + (i/400) * 8*sigma;
                    const xScaled = 50 + (i/400) * 400;
                    
                    // Fórmula densidad normal
                    const exponent = -0.5 * Math.pow((x - mu) / sigma, 2);
                    const y = (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(exponent);
                    const yScaled = 300 - y * 5000; // Escalar para visualización
                    
                    if (i === 0) {
                        pathData = `M ${xScaled} ${yScaled}`;
                    } else {
                        pathData += ` L ${xScaled} ${yScaled}`;
                    }
                }
                
                curve.setAttribute("d", pathData);
                curve.setAttribute("fill", "none");
                curve.setAttribute("stroke", "#3498db");
                curve.setAttribute("stroke-width", "3");
                svg.appendChild(curve);
                
                // Área bajo la curva (68%)
                const area68 = document.createElementNS(svgNS, "path");
                let areaPath = "";
                
                for (let i = 150; i <= 250; i += 2) {
                    const x = mu - 4*sigma + (i/400) * 8*sigma;
                    const xScaled = 50 + (i/400) * 400;
                    
                    if (x >= mu - sigma && x <= mu + sigma) {
                        const exponent = -0.5 * Math.pow((x - mu) / sigma, 2);
                        const y = (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(exponent);
                        const yScaled = 300 - y * 5000;
                        
                        if (areaPath === "") {
                            areaPath = `M ${xScaled} ${yScaled}`;
                        } else {
                            areaPath += ` L ${xScaled} ${yScaled}`;
                        }
                    }
                }
                
                // Completar el área
                const startX = 50 + ((mu - sigma - (mu - 4*sigma)) / (8*sigma)) * 400;
                const endX = 50 + ((mu + sigma - (mu - 4*sigma)) / (8*sigma)) * 400;
                areaPath += ` L ${endX} 300 L ${startX} 300 Z`;
                
                area68.setAttribute("d", areaPath);
                area68.setAttribute("fill", "#3498db");
                area68.setAttribute("opacity", "0.3");
                svg.appendChild(area68);
                
                // Etiquetas
                const labels = document.createElementNS(svgNS, "g");
                
                // Media
                const meanLabel = document.createElementNS(svgNS, "text");
                meanLabel.setAttribute("x", "250");
                meanLabel.setAttribute("y", "320");
                meanLabel.setAttribute("text-anchor", "middle");
                meanLabel.setAttribute("font-size", "12");
                meanLabel.setAttribute("fill", "#e74c3c");
                meanLabel.textContent = `μ = ${mu}`;
                labels.appendChild(meanLabel);
                
                // Sigma
                const sigmaLabel = document.createElementNS(svgNS, "text");
                sigmaLabel.setAttribute("x", "250");
                sigmaLabel.setAttribute("y", "40");
                sigmaLabel.setAttribute("text-anchor", "middle");
                sigmaLabel.setAttribute("font-size", "12");
                sigmaLabel.setAttribute("fill", "#3498db");
                sigmaLabel.textContent = `σ = ${sigma}`;
                labels.appendChild(sigmaLabel);
                
                // Área 68%
                const areaLabel = document.createElementNS(svgNS, "text");
                areaLabel.setAttribute("x", "250");
                areaLabel.setAttribute("y", "280");
                areaLabel.setAttribute("text-anchor", "middle");
                areaLabel.setAttribute("font-size", "11");
                areaLabel.setAttribute("fill", "#2c3e50");
                areaLabel.textContent = "68% de los datos";
                labels.appendChild(areaLabel);
                
                svg.appendChild(labels);
                
                // Título
                const title = document.createElementNS(svgNS, "text");
                title.setAttribute("x", "250");
                title.setAttribute("y", "30");
                title.setAttribute("text-anchor", "middle");
                title.setAttribute("font-size", "14");
                title.setAttribute("font-weight", "bold");
                title.setAttribute("fill", "#2c3e50");
                title.textContent = "Distribución Normal N(100, σ²)";
                svg.appendChild(title);
                
                div.appendChild(svg);
            }
        },
        {
            id: 5,
            title: "5. Descriptiva: Robustez Estadística",
            icon: "fa-calculator",
            controls: [
                {id: 'outlier', type: 'select', label: 'Datos Atípicos', 
                 options: ['Sin Outliers', 'Con Outlier Extremo']}
            ],
            code: (p) => {
                const data = p.outlier === 'Sin Outliers' ? 
                    "c(12, 13, 12, 14, 15)" : 
                    "c(12, 13, 12, 14, 15, 150)";
                
                return `<span class="c-com"># Comparación Media vs Mediana</span>
<span class="c-var">nivel_proteina</span> <span class="c-op"><-</span> ${data}

<span class="c-com"># 1. Media (Sensible a extremos)</span>
<span class="c-var">media</span> <span class="c-op"><-</span> <span class="c-fn">mean</span>(<span class="c-var">nivel_proteina</span>)

<span class="c-com"># 2. Mediana (Robusta)</span>
<span class="c-var">mediana</span> <span class="c-op"><-</span> <span class="c-fn">median</span>(<span class="c-var">nivel_proteina</span>)

<span class="c-fn">print</span>(<span class="c-fn">paste</span>(<span class="c-str">"Media:"</span>, <span class="c-fn">round</span>(<span class="c-var">media</span>, <span class="c-num">2</span>)))
<span class="c-fn">print</span>(<span class="c-fn">paste</span>(<span class="c-str">"Mediana:"</span>, <span class="c-var">mediana</span>))

<span class="c-com"># 3. Desviación estándar (también sensible)</span>
<span class="c-var">sd</span> <span class="c-op"><-</span> <span class="c-fn">sd</span>(<span class="c-var">nivel_proteina</span>)
<span class="c-fn">print</span>(<span class="c-fn">paste</span>(<span class="c-str">"SD:"</span>, <span class="c-fn">round</span>(<span class="c-var">sd</span>, <span class="c-num">2</span>)))`;
            },
            explain: (p) => {
                const isOutlier = p.outlier === 'Con Outlier Extremo';
                return `<h3>Medidas de Tendencia Central</h3>
                <p><b>Media:</b> Promedio aritmético. Sensible a valores extremos.</p>
                <p><b>Mediana:</b> Valor central ordenado (percentil 50). Robusta a outliers.</p>
                <p><b>Desviación Estándar:</b> Mide dispersión. También sensible a outliers.</p>
                
                <div class="theory-highlight">
                    ${isOutlier ? 
                    '<b>¡CUIDADO CON OUTLIERS!</b><br>El valor 150 distorsiona completamente la media y la desviación estándar, haciendo que no representen la mayoría de los datos. La mediana se mantiene estable.' : 
                    'Sin outliers, ambas medidas son similares y representativas.'}
                </div>`;
            },
            render: (p, div) => {
    div.innerHTML = '';
    const svg = createSVG("100%", "100%", "0 0 500 350"); // Aumenté un poco la altura para que quepa todo bien
    
    // Fondo
    const bg = document.createElementNS(svgNS, "rect");
    bg.setAttribute("width", "500");
    bg.setAttribute("height", "350");
    bg.setAttribute("fill", "white");
    svg.appendChild(bg);
    
    // Datos
    let data = [12, 13, 12, 14, 15];
    if (p.outlier === 'Con Outlier Extremo') {
        data.push(150);
    }
    
    // Calcular estadísticas
    const sum = data.reduce((a, b) => a + b, 0);
    const mean = sum / data.length;
    const sorted = [...data].sort((a, b) => a - b);
    const median = sorted[Math.floor(sorted.length / 2)];
    
    // --- LÓGICA DE ESCALA DINÁMICA (Para arreglar el bug del 150) ---
    // Usamos el valor máximo para definir qué tan "alto" es el gráfico
    const maxVal = Math.max(...data);
    const chartHeight = 200; // Espacio vertical disponible para dibujar puntos
    const yBase = 280;       // Posición vertical de la línea base (eje X)
    
    // Si hay outlier (max > 20), escalamos dinámicamente. Si no, escala fija para que se vea bonito.
    const scale = maxVal > 20 ? (chartHeight / (maxVal * 1.1)) : 8; 
    
    const offset = 60; // Margen izquierdo
    
    // 1. TÍTULO DEL GRÁFICO (Recuperado)
    const title = document.createElementNS(svgNS, "text");
    title.setAttribute("x", "250");
    title.setAttribute("y", "30");
    title.setAttribute("text-anchor", "middle");
    title.setAttribute("font-size", "14");
    title.setAttribute("font-weight", "bold");
    title.setAttribute("fill", "#2c3e50");
    title.textContent = "Media vs Mediana - Sensibilidad a Outliers";
    svg.appendChild(title);

    // 2. DIBUJAR PUNTOS Y ETIQUETAS
    data.forEach((value, i) => {
        const isOutlier = value > 20; // Detección simple para color
        
        // Distribuir horizontalmente
        const xStep = 380 / (data.length); 
        const cx = offset + i * xStep + 20;
        const cy = yBase - value * scale;
        
        // Línea vertical tenue (opcional, estilo lollipop)
        /* const line = document.createElementNS(svgNS, "line");
        line.setAttribute("x1", cx); line.setAttribute("y1", yBase);
        line.setAttribute("x2", cx); line.setAttribute("y2", cy);
        line.setAttribute("stroke", "#eee");
        svg.appendChild(line); 
        */

        // Círculo
        const point = document.createElementNS(svgNS, "circle");
        point.setAttribute("cx", cx);
        point.setAttribute("cy", cy);
        point.setAttribute("r", isOutlier ? "8" : "6");
        point.setAttribute("fill", isOutlier ? "#e74c3c" : "#3498db");
        point.setAttribute("opacity", "0.9");
        svg.appendChild(point);
        
        // Etiqueta del VALOR (Encima del punto)
        const label = document.createElementNS(svgNS, "text");
        label.setAttribute("x", cx);
        label.setAttribute("y", cy - 12);
        label.setAttribute("text-anchor", "middle");
        label.setAttribute("font-size", "10");
        label.setAttribute("fill", isOutlier ? "#e74c3c" : "#2c3e50");
        label.textContent = value.toString();
        svg.appendChild(label);
        
        // Etiqueta del ÍNDICE [1] (Debajo del eje, Recuperado)
        const index = document.createElementNS(svgNS, "text");
        index.setAttribute("x", cx);
        index.setAttribute("y", yBase + 25); // Debajo de la línea base
        index.setAttribute("text-anchor", "middle");
        index.setAttribute("font-size", "10");
        index.setAttribute("fill", "#95a5a6"); // Color gris suave
        index.textContent = `[${i + 1}]`;
        svg.appendChild(index);
    });
    
    // 3. LÍNEAS DE MEDIA Y MEDIANA
    const meanY = yBase - mean * scale;
    const medianY = yBase - median * scale;

    // Línea Media (Roja discontinua)
    const meanLine = document.createElementNS(svgNS, "line");
    meanLine.setAttribute("x1", "50");
    meanLine.setAttribute("y1", meanY);
    meanLine.setAttribute("x2", "480");
    meanLine.setAttribute("y2", meanY);
    meanLine.setAttribute("stroke", "#e74c3c");
    meanLine.setAttribute("stroke-width", "2");
    meanLine.setAttribute("stroke-dasharray", "5,5");
    svg.appendChild(meanLine);
    
    // Línea Mediana (Verde discontinua)
    const medianLine = document.createElementNS(svgNS, "line");
    medianLine.setAttribute("x1", "50");
    medianLine.setAttribute("y1", medianY);
    medianLine.setAttribute("x2", "480");
    medianLine.setAttribute("y2", medianY);
    medianLine.setAttribute("stroke", "#27ae60");
    medianLine.setAttribute("stroke-width", "2");
    medianLine.setAttribute("stroke-dasharray", "5,5");
    svg.appendChild(medianLine);
    
    // 4. ETIQUETAS A LA DERECHA (Con lógica para que no se encimen)
    // Si están muy cerca (menos de 15px), separamos los textos verticalmente
    const dist = Math.abs(meanY - medianY);
    let txtMeanY = meanY - 5;
    let txtMedianY = medianY - 5;
    
    if (dist < 20) {
        // Conflicto visual: movemos la mediana abajo y la media arriba
        txtMeanY = meanY - 8;
        txtMedianY = medianY + 15;
    }

    // Texto Media
    const meanLabel = document.createElementNS(svgNS, "text");
    meanLabel.setAttribute("x", "495"); // Pegado a la derecha
    meanLabel.setAttribute("y", txtMeanY);
    meanLabel.setAttribute("text-anchor", "end");
    meanLabel.setAttribute("font-size", "11");
    meanLabel.setAttribute("fill", "#e74c3c");
    meanLabel.setAttribute("font-weight", "bold");
    meanLabel.textContent = `Media: ${mean.toFixed(2)}`;
    svg.appendChild(meanLabel);
    
    // Texto Mediana
    const medianLabel = document.createElementNS(svgNS, "text");
    medianLabel.setAttribute("x", "495");
    medianLabel.setAttribute("y", txtMedianY);
    medianLabel.setAttribute("text-anchor", "end");
    medianLabel.setAttribute("font-size", "11");
    medianLabel.setAttribute("fill", "#27ae60");
    medianLabel.setAttribute("font-weight", "bold");
    medianLabel.textContent = `Mediana: ${median}`;
    svg.appendChild(medianLabel);
    
    // 5. EJE Y (Línea vertical izquierda)
    const yAxis = document.createElementNS(svgNS, "line");
    yAxis.setAttribute("x1", "50");
    yAxis.setAttribute("y1", "50");
    yAxis.setAttribute("x2", "50");
    yAxis.setAttribute("y2", yBase);
    yAxis.setAttribute("stroke", "#333");
    yAxis.setAttribute("stroke-width", "1.5");
    svg.appendChild(yAxis);

    // EJE X (Línea horizontal base)
    const xAxis = document.createElementNS(svgNS, "line");
    xAxis.setAttribute("x1", "50");
    xAxis.setAttribute("y1", yBase);
    xAxis.setAttribute("x2", "490");
    xAxis.setAttribute("y2", yBase);
    xAxis.setAttribute("stroke", "#333");
    xAxis.setAttribute("stroke-width", "1.5");
    svg.appendChild(xAxis);
    
    // 6. LEYENDA (Recuperada al pie del gráfico)
    const legend = document.createElementNS(svgNS, "g");
    legend.setAttribute("transform", "translate(50, 320)"); // Posición inferior
    
    // Item Media
    const meanLegend = document.createElementNS(svgNS, "rect");
    meanLegend.setAttribute("x", "0"); meanLegend.setAttribute("y", "0");
    meanLegend.setAttribute("width", "15"); meanLegend.setAttribute("height", "15");
    meanLegend.setAttribute("fill", "#e74c3c");
    legend.appendChild(meanLegend);
    
    const meanLegendText = document.createElementNS(svgNS, "text");
    meanLegendText.setAttribute("x", "25"); meanLegendText.setAttribute("y", "12");
    meanLegendText.setAttribute("font-size", "11"); meanLegendText.setAttribute("fill", "#333");
    meanLegendText.textContent = "Media (sensible)";
    legend.appendChild(meanLegendText);
    
    // Item Mediana
    const medianLegend = document.createElementNS(svgNS, "rect");
    medianLegend.setAttribute("x", "150"); medianLegend.setAttribute("y", "0");
    medianLegend.setAttribute("width", "15"); medianLegend.setAttribute("height", "15");
    medianLegend.setAttribute("fill", "#27ae60");
    legend.appendChild(medianLegend);
    
    const medianLegendText = document.createElementNS(svgNS, "text");
    medianLegendText.setAttribute("x", "175"); medianLegendText.setAttribute("y", "12");
    medianLegendText.setAttribute("font-size", "11"); medianLegendText.setAttribute("fill", "#333");
    medianLegendText.textContent = "Mediana (robusta)";
    legend.appendChild(medianLegendText);
    
    svg.appendChild(legend);
    
    div.appendChild(svg);
}
        },
        {
            id: 6,
            title: "6. Inferencial: Pruebas de Hipótesis",
            icon: "fa-vial",
            controls: [
                {id: 'test', type: 'select', label: 'Tipo de Prueba', 
                 options: ['T-Student (2 grupos)', 'ANOVA (3+ grupos)', 'Chi-cuadrado (categóricos)']}
            ],
            code: (p) => {
                switch(p.test) {
                    case 'T-Student (2 grupos)':
                        return `<span class="c-com"># T-test para comparar medias de 2 grupos independientes</span>
<span class="c-var">control</span> <span class="c-op"><-</span> <span class="c-fn">c</span>(<span class="c-num">85</span>, <span class="c-num">88</span>, <span class="c-num">92</span>, <span class="c-num">78</span>, <span class="c-num">90</span>)
<span class="c-var">tratamiento</span> <span class="c-op"><-</span> <span class="c-fn">c</span>(<span class="c-num">75</span>, <span class="c-num">72</span>, <span class="c-num">68</span>, <span class="c-num">80</span>, <span class="c-num">70</span>)

<span class="c-var">resultado_t</span> <span class="c-op"><-</span> <span class="c-fn">t.test</span>(<span class="c-var">control</span>, <span class="c-var">tratamiento</span>)

<span class="c-fn">print</span>(<span class="c-var">resultado_t</span>)`;

                    case 'ANOVA (3+ grupos)':
                        return `<span class="c-com"># ANOVA: Comparar medias de 3 o más grupos</span>
<span class="c-var">grupo_a</span> <span class="c-op"><-</span> <span class="c-fn">c</span>(<span class="c-num">15</span>, <span class="c-num">18</span>, <span class="c-num">16</span>, <span class="c-num">17</span>, <span class="c-num">20</span>)
<span class="c-var">grupo_b</span> <span class="c-op"><-</span> <span class="c-fn">c</span>(<span class="c-num">12</span>, <span class="c-num">14</span>, <span class="c-num">11</span>, <span class="c-num">13</span>, <span class="c-num">15</span>)
<span class="c-var">grupo_c</span> <span class="c-op"><-</span> <span class="c-fn">c</span>(<span class="c-num">8</span>, <span class="c-num">10</span>, <span class="c-num">9</span>, <span class="c-num">7</span>, <span class="c-num">11</span>)

<span class="c-var">datos_long</span> <span class="c-op"><-</span> <span class="c-fn">data.frame</span>(
  <span class="c-arg">valor</span> = <span class="c-fn">c</span>(<span class="c-var">grupo_a</span>, <span class="c-var">grupo_b</span>, <span class="c-var">grupo_c</span>),
  <span class="c-arg">grupo</span> = <span class="c-fn">factor</span>(<span class="c-fn">rep</span>(<span class="c-fn">c</span>(<span class="c-str">"A"</span>, <span class="c-str">"B"</span>, <span class="c-str">"C"</span>), <span class="c-arg">each</span>=<span class="c-num">5</span>))
)

<span class="c-var">anova_result</span> <span class="c-op"><-</span> <span class="c-fn">aov</span>(valor <span class="c-op">~</span> grupo, <span class="c-arg">data</span> = <span class="c-var">datos_long</span>)
<span class="c-fn">summary</span>(<span class="c-var">anova_result</span>)`;

                    case 'Chi-cuadrado (categóricos)':
                        return `<span class="c-com"># Chi-cuadrado: Asociación entre variables categóricas</span>
<span class="c-com"># Tabla de contingencia: Fuma vs Cáncer</span>
<span class="c-var">tabla</span> <span class="c-op"><-</span> <span class="c-fn">matrix</span>(<span class="c-fn">c</span>(<span class="c-num">30</span>, <span class="c-num">10</span>, <span class="c-num">20</span>, <span class="c-num">40</span>), 
                     <span class="c-arg">nrow</span>=<span class="c-num">2</span>,
                     <span class="c-arg">dimnames</span>=<span class="c-fn">list</span>(
                       <span class="c-arg">Fuma</span> = <span class="c-fn">c</span>(<span class="c-str">"Sí"</span>, <span class="c-str">"No"</span>),
                       <span class="c-arg">Cancer</span> = <span class="c-fn">c</span>(<span class="c-str">"Sí"</span>, <span class="c-str">"No"</span>)
                     ))

<span class="c-fn">print</span>(<span class="c-var">tabla</span>)

<span class="c-var">chi_test</span> <span class="c-op"><-</span> <span class="c-fn">chisq.test</span>(<span class="c-var">tabla</span>)
<span class="c-fn">print</span>(<span class="c-var">chi_test</span>)`;
                }
            },
            explain: (p) => {
                const tests = {
                    'T-Student (2 grupos)': `<h3>Prueba T de Student</h3>
                    <p>Compara las medias de dos grupos independientes. Supuestos:</p>
                    <ul>
                        <li>Normalidad de los datos en cada grupo</li>
                        <li>Homogeneidad de varianzas (prueba de Levene)</li>
                        <li>Observaciones independientes</li>
                    </ul>
                    <div class="theory-highlight">
                        <b>Interpretación del p-valor:</b><br>
                        • p &lt; 0.05: Diferencias estadísticamente significativas<br>
                        • p ≥ 0.05: No hay evidencia suficiente para rechazar H₀
                    </div>`,
                    
                    'ANOVA (3+ grupos)': `<h3>ANOVA (Análisis de Varianza)</h3>
                    <p>Compara medias de tres o más grupos simultáneamente.</p>
                    <p><b>Hipótesis:</b><br>
                    • H₀: µ₁ = µ₂ = µ₃ (todas las medias son iguales)<br>
                    • H₁: Al menos una media es diferente</p>
                    <div class="theory-highlight">
                        <b>Post-hoc:</b><br>
                        Si ANOVA es significativo, se necesitan pruebas post-hoc (Tukey HSD) para identificar qué grupos difieren.
                    </div>`,
                    
                    'Chi-cuadrado (categóricos)': `<h3>Prueba Chi-cuadrado de Independencia</h3>
                    <p>Evalúa si existe asociación entre dos variables categóricas.</p>
                    <p><b>Supuestos:</b><br>
                    • Frecuencias esperadas ≥ 5 en el 80% de las celdas<br>
                    • Observaciones independientes</p>
                    <div class="theory-highlight">
                        <b>Odds Ratio (OR):</b><br>
                        Mide la fuerza de asociación. OR = 1 (no asociación), OR > 1 (asociación positiva), OR < 1 (asociación negativa).
                    </div>`
                };
                return tests[p.test];
            },
            render: (p, div) => {
    div.innerHTML = '';
    const svg = createSVG("100%", "100%", "0 0 500 400");
    
    // Fondo blanco limpio
    const bg = document.createElementNS(svgNS, "rect");
    bg.setAttribute("width", "500");
    bg.setAttribute("height", "400");
    bg.setAttribute("fill", "white");
    svg.appendChild(bg);
    
    // Título (Bajado un poco para dar aire)
    const title = document.createElementNS(svgNS, "text");
    title.setAttribute("x", "250");
    title.setAttribute("y", "40"); // Bajado de 30 a 40
    title.setAttribute("text-anchor", "middle");
    title.setAttribute("font-size", "14");
    title.setAttribute("font-weight", "bold");
    title.setAttribute("fill", "#2c3e50");
    title.textContent = `Prueba Estadística: ${p.test}`;
    svg.appendChild(title);
    
    if (p.test === 'T-Student (2 grupos)') {
        // Datos
        const control = [85, 88, 92, 78, 90];
        const tratamiento = [75, 72, 68, 80, 70];
        
        // --- CORRECCIÓN MATEMÁTICA ---
        // Los datos van de 68 a 92.
        // Queremos que 92 esté arriba (pero no en el techo) y 68 abajo.
        // Fórmula: Base (350px) - (Valor * Escala)
        // 90 * 3 = 270 -> 350 - 270 = 80 (Perfecto, debajo del título)
        // 70 * 3 = 210 -> 350 - 210 = 140 (En el medio)
        const scaleY = (val) => 350 - (val * 3);

        const drawBoxplot = (x, values, label, color) => {
            const g = document.createElementNS(svgNS, "g");
            const sorted = [...values].sort((a, b) => a - b);
            const q1 = sorted[1];
            const median = sorted[2];
            const q3 = sorted[3];
            
            // Caja
            const boxTop = scaleY(q3);
            const boxBottom = scaleY(q1);
            const boxHeight = Math.abs(boxBottom - boxTop);
            
            const box = document.createElementNS(svgNS, "rect");
            box.setAttribute("x", x - 30);
            box.setAttribute("y", boxTop);
            box.setAttribute("width", "60");
            box.setAttribute("height", boxHeight);
            box.setAttribute("fill", color);
            box.setAttribute("opacity", "0.5");
            box.setAttribute("stroke", color); // Borde para definir mejor
            g.appendChild(box);
            
            // Mediana
            const medianLine = document.createElementNS(svgNS, "line");
            medianLine.setAttribute("x1", x - 30);
            medianLine.setAttribute("y1", scaleY(median));
            medianLine.setAttribute("x2", x + 30);
            medianLine.setAttribute("y2", scaleY(median));
            medianLine.setAttribute("stroke", "#fff");
            medianLine.setAttribute("stroke-width", "3");
            g.appendChild(medianLine);
            
            // Puntos (Jitter/Ruido para que no se encimen)
            values.forEach((val, i) => {
                const point = document.createElementNS(svgNS, "circle");
                point.setAttribute("cx", x - 20 + (i % 3) * 15); // Zigzag horizontal
                point.setAttribute("cy", scaleY(val));
                point.setAttribute("r", "4");
                point.setAttribute("fill", "#2c3e50");
                point.setAttribute("stroke", "white"); // Borde blanco para resaltar
                g.appendChild(point);
            });
            
            // Etiqueta Grupo
            const labelText = document.createElementNS(svgNS, "text");
            labelText.setAttribute("x", x);
            labelText.setAttribute("y", "370");
            labelText.setAttribute("text-anchor", "middle");
            labelText.setAttribute("font-size", "12");
            labelText.setAttribute("fill", "#2c3e50");
            labelText.setAttribute("font-weight", "bold");
            labelText.textContent = label;
            g.appendChild(labelText);
            
            // Etiqueta Media
            const mean = values.reduce((a, b) => a + b) / values.length;
            const meanText = document.createElementNS(svgNS, "text");
            meanText.setAttribute("x", x);
            meanText.setAttribute("y", "385");
            meanText.setAttribute("text-anchor", "middle");
            meanText.setAttribute("font-size", "10");
            meanText.setAttribute("fill", color);
            meanText.textContent = `Media: ${mean.toFixed(1)}`;
            g.appendChild(meanText);
            
            return g;
        };
        
        svg.appendChild(drawBoxplot(150, control, "Control", "#3498db"));
        svg.appendChild(drawBoxplot(350, tratamiento, "Tratamiento", "#e74c3c"));
        
        // Línea de diferencia (Ajustada visualmente)
        const diffLine = document.createElementNS(svgNS, "line");
        diffLine.setAttribute("x1", "180"); diffLine.setAttribute("y1", "110");
        diffLine.setAttribute("x2", "320"); diffLine.setAttribute("y2", "110");
        diffLine.setAttribute("stroke", "#27ae60");
        diffLine.setAttribute("stroke-width", "2");
        diffLine.setAttribute("stroke-dasharray", "5,5");
        svg.appendChild(diffLine);
        
        const diffText = document.createElementNS(svgNS, "text");
        diffText.setAttribute("x", "250"); diffText.setAttribute("y", "100");
        diffText.setAttribute("text-anchor", "middle"); diffText.setAttribute("font-size", "10");
        diffText.setAttribute("fill", "#27ae60"); diffText.textContent = "Diferencia significativa";
        svg.appendChild(diffText);
        
        // Resultado T-test al pie
        const resultText = document.createElementNS(svgNS, "text");
        resultText.setAttribute("x", "250");
        resultText.setAttribute("y", "395");
        resultText.setAttribute("text-anchor", "middle");
        resultText.setAttribute("font-size", "12");
        resultText.setAttribute("fill", "#27ae60");
        resultText.setAttribute("font-weight", "bold");
        resultText.textContent = "T-test: p = 0.021* (H0 rechazada)";
        svg.appendChild(resultText);

    } else if (p.test === 'ANOVA (3+ grupos)') {
        // --- CORRECCIÓN TAMBIÉN PARA ANOVA ---
        // Aplicamos la misma lógica de escala Y
        const scaleY = (val) => 350 - (val * 8); // Datos son más pequeños (8-20), multiplicamos por más
        
        const grupos = { 'A': [15,18,16,17,20], 'B': [12,14,11,13,15], 'C': [8,10,9,7,11] };
        
        Object.entries(grupos).forEach(([grupo, values], i) => {
            const x = 100 + i * 150;
            const colors = ['#3498db', '#e74c3c', '#2ecc71'];
            const g = document.createElementNS(svgNS, "g");
            
            // Puntos
            values.forEach((val, j) => {
                const point = document.createElementNS(svgNS, "circle");
                point.setAttribute("cx", x - 20 + j * 10);
                point.setAttribute("cy", scaleY(val));
                point.setAttribute("r", "5");
                point.setAttribute("fill", colors[i]);
                point.setAttribute("opacity", "0.6");
                g.appendChild(point);
            });
            
            // Media
            const mean = values.reduce((a, b) => a + b) / values.length;
            const meanLine = document.createElementNS(svgNS, "line");
            meanLine.setAttribute("x1", x - 30); meanLine.setAttribute("y1", scaleY(mean));
            meanLine.setAttribute("x2", x + 30); meanLine.setAttribute("y2", scaleY(mean));
            meanLine.setAttribute("stroke", colors[i]); meanLine.setAttribute("stroke-width", "4");
            g.appendChild(meanLine);
            
            const label = document.createElementNS(svgNS, "text");
            label.setAttribute("x", x); label.setAttribute("y", "380");
            label.setAttribute("text-anchor", "middle"); label.setAttribute("font-size", "12");
            label.setAttribute("fill", colors[i]); label.setAttribute("font-weight", "bold");
            label.textContent = `Grupo ${grupo}`;
            g.appendChild(label);
            svg.appendChild(g);
        });
        
        const anovaResult = document.createElementNS(svgNS, "text");
        anovaResult.setAttribute("x", "250"); anovaResult.setAttribute("y", "60");
        anovaResult.setAttribute("text-anchor", "middle"); anovaResult.setAttribute("font-size", "12");
        anovaResult.setAttribute("fill", "#e74c3c");
        anovaResult.textContent = "ANOVA: F = 25.6, p < 0.001";
        svg.appendChild(anovaResult);

    } else if (p.test === 'Chi-cuadrado (categóricos)') {
        // (Este bloque estaba bien, lo dejamos tal cual para no romperlo)
        const tabla = [[30, 10], [20, 40]];
        const labels = {rows: ['Fuma: Sí', 'Fuma: No'], cols: ['Cáncer: Sí', 'Cáncer: No']};
        const tableGroup = document.createElementNS(svgNS, "g");
        tableGroup.setAttribute("transform", "translate(150, 100)");
        
        labels.cols.forEach((col, i) => {
           const text = document.createElementNS(svgNS, "text");
           text.setAttribute("x", 100 + i * 100); text.setAttribute("y", "-20");
           text.setAttribute("text-anchor", "middle"); text.setAttribute("font-size", "10"); text.setAttribute("fill", "#2c3e50"); text.textContent = col; tableGroup.appendChild(text);
        });
        labels.rows.forEach((row, i) => {
           const text = document.createElementNS(svgNS, "text");
           text.setAttribute("x", "-20"); text.setAttribute("y", 50 + i * 60);
           text.setAttribute("text-anchor", "end"); text.setAttribute("font-size", "10"); text.setAttribute("fill", "#2c3e50"); text.textContent = row; tableGroup.appendChild(text);
        });
        tabla.forEach((row, i) => {
           row.forEach((cell, j) => {
               const rect = document.createElementNS(svgNS, "rect");
               rect.setAttribute("x", j * 100); rect.setAttribute("y", i * 60);
               rect.setAttribute("width", "80"); rect.setAttribute("height", "50");
               rect.setAttribute("fill", i === 0 ? "#3498db" : "#e74c3c");
               rect.setAttribute("opacity", "0.7"); rect.setAttribute("rx", "4");
               tableGroup.appendChild(rect);
               const text = document.createElementNS(svgNS, "text");
               text.setAttribute("x", j * 100 + 40); text.setAttribute("y", i * 60 + 30);
               text.setAttribute("text-anchor", "middle"); text.setAttribute("font-size", "14"); text.setAttribute("fill", "white"); text.setAttribute("font-weight", "bold"); text.textContent = cell.toString();
               tableGroup.appendChild(text);
           });
        });
        svg.appendChild(tableGroup);
        const OR = (tabla[0][0] * tabla[1][1]) / (tabla[0][1] * tabla[1][0]);
        const orText = document.createElementNS(svgNS, "text");
        orText.setAttribute("x", "250"); orText.setAttribute("y", "320");
        orText.setAttribute("text-anchor", "middle"); orText.setAttribute("font-size", "12"); orText.setAttribute("fill", "#27ae60"); orText.setAttribute("font-weight", "bold"); orText.textContent = `Odds Ratio (OR) = ${OR.toFixed(2)}`; svg.appendChild(orText);
        const chiText = document.createElementNS(svgNS, "text");
        chiText.setAttribute("x", "250"); chiText.setAttribute("y", "340");
        chiText.setAttribute("text-anchor", "middle"); chiText.setAttribute("font-size", "12"); chiText.setAttribute("fill", "#e74c3c"); chiText.textContent = "Chi-cuadrado: χ² = 12.5, p = 0.0004"; svg.appendChild(chiText);
    }
    
    div.appendChild(svg);
}
        },
        {
            id: 7,
            title: "7. Modelos: Regresión Lineal",
            icon: "fa-chart-line",
            controls: [
                {id: 'model', type: 'select', label: 'Tipo de Modelo', 
                 options: ['Regresión Simple', 'Regresión Múltiple', 'ANCOVA']}
            ],
            code: (p) => {
                switch(p.model) {
                    case 'Regresión Simple':
                        return `<span class="c-com"># Regresión lineal simple: Y = β₀ + β₁X + ε</span>
<span class="c-var">datos</span> <span class="c-op"><-</span> <span class="c-fn">data.frame</span>(
  <span class="c-arg">Edad</span> = <span class="c-fn">c</span>(<span class="c-num">25</span>, <span class="c-num">34</span>, <span class="c-num">28</span>, <span class="c-num">52</span>, <span class="c-num">47</span>, <span class="c-num">30</span>),
  <span class="c-arg">Glucosa</span> = <span class="c-fn">c</span>(<span class="c-num">95</span>, <span class="c-num">110</span>, <span class="c-num">88</span>, <span class="c-num">145</span>, <span class="c-num">130</span>, <span class="c-num">100</span>)
)

<span class="c-var">modelo_simple</span> <span class="c-op"><-</span> <span class="c-fn">lm</span>(Glucosa <span class="c-op">~</span> Edad, <span class="c-arg">data</span> = <span class="c-var">datos</span>)

<span class="c-fn">summary</span>(<span class="c-var">modelo_simple</span>) <span class="c-com"># Coeficientes, R², p-valores</span>

<span class="c-com"># Predicción para nueva observación</span>
<span class="c-fn">predict</span>(<span class="c-var">modelo_simple</span>, <span class="c-fn">data.frame</span>(<span class="c-arg">Edad</span>=<span class="c-num">40</span>))`;

                    case 'Regresión Múltiple':
                        return `<span class="c-com"># Regresión múltiple: Y = β₀ + β₁X₁ + β₂X₂ + ε</span>
<span class="c-var">datos</span> <span class="c-op"><-</span> <span class="c-fn">data.frame</span>(
  <span class="c-arg">Edad</span> = <span class="c-fn">c</span>(<span class="c-num">25</span>, <span class="c-num">34</span>, <span class="c-num">28</span>, <span class="c-num">52</span>, <span class="c-num">47</span>, <span class="c-num">30</span>),
  <span class="c-arg">IMC</span> = <span class="c-fn">c</span>(<span class="c-num">22</span>, <span class="c-num">25</span>, <span class="c-num">23</span>, <span class="c-num">31</span>, <span class="c-num">28</span>, <span class="c-num">24</span>),
  <span class="c-arg">Glucosa</span> = <span class="c-fn">c</span>(<span class="c-num">95</span>, <span class="c-num">110</span>, <span class="c-num">88</span>, <span class="c-num">145</span>, <span class="c-num">130</span>, <span class="c-num">100</span>)
)

<span class="c-var">modelo_multiple</span> <span class="c-op"><-</span> <span class="c-fn">lm</span>(Glucosa <span class="c-op">~</span> Edad <span class="c-op">+</span> IMC, <span class="c-arg">data</span> = <span class="c-var">datos</span>)

<span class="c-fn">summary</span>(<span class="c-var">modelo_multiple</span>) <span class="c-com"># Interpretación: "manteniendo constante..."</span>

<span class="c-com"># Verificar multicolinealidad</span>
<span class="c-kwd">library</span>(car)
<span class="c-fn">vif</span>(<span class="c-var">modelo_multiple</span>) <span class="c-com"># VIF > 10 indica problema</span>`;

                    case 'ANCOVA':
                        return `<span class="c-com"># ANCOVA: ANOVA + covariables</span>
<span class="c-var">datos</span> <span class="c-op"><-</span> <span class="c-fn">data.frame</span>(
  <span class="c-arg">Grupo</span> = <span class="c-fn">factor</span>(<span class="c-fn">rep</span>(<span class="c-fn">c</span>(<span class="c-str">"Control"</span>, <span class="c-str">"Tratamiento"</span>), <span class="c-arg">each</span>=<span class="c-num">10</span>)),
  <span class="c-arg">Edad</span> = <span class="c-fn">c</span>(<span class="c-num">25</span>, <span class="c-num">34</span>, <span class="c-num">28</span>, <span class="c-num">52</span>, <span class="c-num">47</span>, <span class="c-num">30</span>, <span class="c-num">35</span>, <span class="c-num">40</span>, <span class="c-num">45</span>, <span class="c-num">50</span>,
              <span class="c-num">22</span>, <span class="c-num">29</span>, <span class="c-num">33</span>, <span class="c-num">38</span>, <span class="c-num">41</span>, <span class="c-num">36</span>, <span class="c-num">39</span>, <span class="c-num">44</span>, <span class="c-num">48</span>, <span class="c-num">31</span>),
  <span class="c-arg">Resultado</span> = <span class="c-fn">c</span>(<span class="c-num">85</span>, <span class="c-num">88</span>, <span class="c-num">92</span>, <span class="c-num">78</span>, <span class="c-num">90</span>, <span class="c-num">82</span>, <span class="c-num">87</span>, <span class="c-num">89</span>, <span class="c-num">84</span>, <span class="c-num">86</span>,
                 <span class="c-num">75</span>, <span class="c-num">72</span>, <span class="c-num">68</span>, <span class="c-num">80</span>, <span class="c-num">70</span>, <span class="c-num">74</span>, <span class="c-num">77</span>, <span class="c-num">73</span>, <span class="c-num">79</span>, <span class="c-num">71</span>)
)

<span class="c-var">modelo_ancova</span> <span class="c-op"><-</span> <span class="c-fn">lm</span>(Resultado <span class="c-op">~</span> Grupo <span class="c-op">+</span> Edad, <span class="c-arg">data</span> = <span class="c-var">datos</span>)
<span class="c-fn">anova</span>(<span class="c-var">modelo_ancova</span>) <span class="c-com"># Efecto del Grupo ajustado por Edad</span>`;
                }
            },
            explain: (p) => {
                const models = {
                    'Regresión Simple': `<h3>Regresión Lineal Simple</h3>
                    <p>Modela la relación entre una variable dependiente (Y) y una independiente (X).</p>
                    <p><b>Ecuación:</b> $Y = \\beta_0 + \\beta_1X + \\epsilon$</p>
                    <ul>
                        <li>$\\beta_0$: Intercepto (valor de Y cuando X=0)</li>
                        <li>$\\beta_1$: Pendiente (cambio en Y por unidad de X)</li>
                        <li>$\\epsilon$: Error aleatorio</li>
                    </ul>
                    <div class="theory-highlight">
                        <b>R² (coeficiente de determinación):</b><br>
                        Proporción de la variabilidad de Y explicada por el modelo (0-1). R² = 0.75 significa que el 75% de la variación en Y se explica por X.
                    </div>`,
                    
                    'Regresión Múltiple': `<h3>Regresión Lineal Múltiple</h3>
                    <p>Extiende la regresión simple incluyendo múltiples predictores.</p>
                    <p><b>Ecuación:</b> $Y = \\beta_0 + \\beta_1X_1 + \\beta_2X_2 + ... + \\beta_kX_k + \\epsilon$</p>
                    <p><b>Interpretación clave:</b> "Manteniendo constantes las demás variables..."</p>
                    <div class="theory-highlight">
                        <b>Problemas comunes:</b><br>
                        1. Multicolinealidad: Predictores altamente correlacionados (VIF > 10)<br>
                        2. Sobredispersión: Más variabilidad de la esperada<br>
                        3. Heterocedasticidad: Varianza no constante
                    </div>`,
                    
                    'ANCOVA': `<h3>ANCOVA (Análisis de Covarianza)</h3>
                    <p>Combina ANOVA y regresión para comparar grupos ajustando por covariables.</p>
                    <p><b>Aplicación típica:</b> Ensayos clínicos donde se quiere controlar por edad, sexo, etc.</p>
                    <div class="theory-highlight">
                        <b>Supuestos ANCOVA:</b><br>
                        1. Linealidad entre covariable y variable respuesta<br>
                        2. Homogeneidad de pendientes (no interacción Grupo × Covariable)<br>
                        3. Normalidad y homocedasticidad de residuos
                    </div>`
                };
                return models[p.model];
            },
            render: (p, div) => {
                div.innerHTML = '';
                const svg = createSVG("100%", "100%", "0 0 500 400");
                
                // Fondo
                const bg = document.createElementNS(svgNS, "rect");
                bg.setAttribute("width", "500");
                bg.setAttribute("height", "400");
                bg.setAttribute("fill", "white");
                svg.appendChild(bg);
                
                // Título
                const title = document.createElementNS(svgNS, "text");
                title.setAttribute("x", "250");
                title.setAttribute("y", "30");
                title.setAttribute("text-anchor", "middle");
                title.setAttribute("font-size", "14");
                title.setAttribute("font-weight", "bold");
                title.setAttribute("fill", "#2c3e50");
                title.textContent = `Modelo: ${p.model}`;
                svg.appendChild(title);
                
                if (p.model === 'Regresión Simple') {
                    // Datos y regresión simple
                    const datos = [
                        {x: 25, y: 95},
                        {x: 34, y: 110},
                        {x: 28, y: 88},
                        {x: 52, y: 145},
                        {x: 47, y: 130},
                        {x: 30, y: 100}
                    ];
                    
                    // Calcular regresión
                    const n = datos.length;
                    const sumX = datos.reduce((sum, d) => sum + d.x, 0);
                    const sumY = datos.reduce((sum, d) => sum + d.y, 0);
                    const sumXY = datos.reduce((sum, d) => sum + d.x * d.y, 0);
                    const sumX2 = datos.reduce((sum, d) => sum + d.x * d.x, 0);
                    
                    const beta1 = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                    const beta0 = (sumY - beta1 * sumX) / n;
                    
                    // Ejes
                    const axes = document.createElementNS(svgNS, "g");
                    
                    // Eje X
                    const xAxis = document.createElementNS(svgNS, "line");
                    xAxis.setAttribute("x1", "50");
                    xAxis.setAttribute("y1", "300");
                    xAxis.setAttribute("x2", "450");
                    xAxis.setAttribute("y2", "300");
                    xAxis.setAttribute("stroke", "#333");
                    xAxis.setAttribute("stroke-width", "1.5");
                    axes.appendChild(xAxis);
                    
                    // Eje Y
                    const yAxis = document.createElementNS(svgNS, "line");
                    yAxis.setAttribute("x1", "50");
                    yAxis.setAttribute("y1", "50");
                    yAxis.setAttribute("x2", "50");
                    yAxis.setAttribute("y2", "300");
                    yAxis.setAttribute("stroke", "#333");
                    yAxis.setAttribute("stroke-width", "1.5");
                    axes.appendChild(xAxis);
                    
                    svg.appendChild(axes);
                    
                    // Línea de regresión
                    const x1 = 20, x2 = 60;
                    const y1 = beta0 + beta1 * x1;
                    const y2 = beta0 + beta1 * x2;
                    
                    const line = document.createElementNS(svgNS, "line");
                    line.setAttribute("x1", 50 + (x1 - 20) * 8);
                    line.setAttribute("y1", 300 - (y1 - 80) * 2);
                    line.setAttribute("x2", 50 + (x2 - 20) * 8);
                    line.setAttribute("y2", 300 - (y2 - 80) * 2);
                    line.setAttribute("stroke", "#e74c3c");
                    line.setAttribute("stroke-width", "3");
                    svg.appendChild(line);
                    
                    // Puntos
                    datos.forEach(d => {
                        const point = document.createElementNS(svgNS, "circle");
                        point.setAttribute("cx", 50 + (d.x - 20) * 8);
                        point.setAttribute("cy", 300 - (d.y - 80) * 2);
                        point.setAttribute("r", "5");
                        point.setAttribute("fill", "#3498db");
                        point.setAttribute("opacity", "0.8");
                        svg.appendChild(point);
                    });
                    
                    // Ecuación
                    const eqText = document.createElementNS(svgNS, "text");
                    eqText.setAttribute("x", "250");
                    eqText.setAttribute("y", "370");
                    eqText.setAttribute("text-anchor", "middle");
                    eqText.setAttribute("font-size", "12");
                    eqText.setAttribute("fill", "#e74c3c");
                    eqText.textContent = `Glucosa = ${beta0.toFixed(1)} + ${beta1.toFixed(2)}×Edad`;
                    svg.appendChild(eqText);
                    
                    // R² simulado
                    const r2Text = document.createElementNS(svgNS, "text");
                    r2Text.setAttribute("x", "250");
                    r2Text.setAttribute("y", "390");
                    r2Text.setAttribute("text-anchor", "middle");
                    r2Text.setAttribute("font-size", "12");
                    r2Text.setAttribute("fill", "#27ae60");
                    r2Text.textContent = "R² = 0.82 (82% de variabilidad explicada)";
                    svg.appendChild(r2Text);
                    
                } else if (p.model === 'Regresión Múltiple') {
                    // Representación 3D simplificada
                    const planeGroup = document.createElementNS(svgNS, "g");
                    
                    // Dibujar plano de regresión (perspectiva)
                    const plane = document.createElementNS(svgNS, "polygon");
                    plane.setAttribute("points", "100,150 400,150 350,350 150,350");
                    plane.setAttribute("fill", "#3498db");
                    plane.setAttribute("opacity", "0.3");
                    plane.setAttribute("stroke", "#2980b9");
                    plane.setAttribute("stroke-width", "1");
                    planeGroup.appendChild(plane);
                    
                    // Ejes
                    const axisX = document.createElementNS(svgNS, "line");
                    axisX.setAttribute("x1", "50");
                    axisX.setAttribute("y1", "250");
                    axisX.setAttribute("x2", "450");
                    axisX.setAttribute("y2", "250");
                    axisX.setAttribute("stroke", "#333");
                    axisX.setAttribute("stroke-width", "1.5");
                    planeGroup.appendChild(axisX);
                    
                    const axisY = document.createElementNS(svgNS, "line");
                    axisY.setAttribute("x1", "250");
                    axisY.setAttribute("y1", "50");
                    axisY.setAttribute("x2", "250");
                    axisY.setAttribute("y2", "400");
                    axisY.setAttribute("stroke", "#333");
                    axisY.setAttribute("stroke-width", "1.5");
                    planeGroup.appendChild(axisY);
                    
                    svg.appendChild(planeGroup);
                    
                    // Etiquetas de ejes
                    const xLabel = document.createElementNS(svgNS, "text");
                    xLabel.setAttribute("x", "450");
                    xLabel.setAttribute("y", "270");
                    xLabel.setAttribute("text-anchor", "end");
                    xLabel.setAttribute("font-size", "10");
                    xLabel.setAttribute("fill", "#2c3e50");
                    xLabel.textContent = "Edad (X₁)";
                    svg.appendChild(xLabel);
                    
                    const yLabel = document.createElementNS(svgNS, "text");
                    yLabel.setAttribute("x", "270");
                    yLabel.setAttribute("y", "50");
                    yLabel.setAttribute("font-size", "10");
                    yLabel.setAttribute("fill", "#2c3e50");
                    yLabel.textContent = "IMC (X₂)";
                    svg.appendChild(yLabel);
                    
                    const zLabel = document.createElementNS(svgNS, "text");
                    zLabel.setAttribute("x", "100");
                    zLabel.setAttribute("y", "50");
                    zLabel.setAttribute("font-size", "10");
                    zLabel.setAttribute("fill", "#2c3e50");
                    zLabel.textContent = "Glucosa (Y)";
                    svg.appendChild(zLabel);
                    
                    // Ecuación
                    const eqText = document.createElementNS(svgNS, "text");
                    eqText.setAttribute("x", "250");
                    eqText.setAttribute("y", "30");
                    eqText.setAttribute("text-anchor", "middle");
                    eqText.setAttribute("font-size", "12");
                    eqText.setAttribute("fill", "#e74c3c");
                    eqText.textContent = "Y = 50.2 + 1.8X₁ + 2.1X₂";
                    svg.appendChild(eqText);
                    
                } else if (p.model === 'ANCOVA') {
                    // Datos para ANCOVA
                    const control = [
                        {x: 25, y: 85}, {x: 34, y: 88}, {x: 28, y: 92}, 
                        {x: 52, y: 78}, {x: 47, y: 90}
                    ];
                    const tratamiento = [
                        {x: 22, y: 75}, {x: 29, y: 72}, {x: 33, y: 68},
                        {x: 38, y: 80}, {x: 41, y: 70}
                    ];
                    
                    // Calcular regresión para cada grupo
                    const calcRegression = (datos) => {
                        const n = datos.length;
                        const sumX = datos.reduce((sum, d) => sum + d.x, 0);
                        const sumY = datos.reduce((sum, d) => sum + d.y, 0);
                        const sumXY = datos.reduce((sum, d) => sum + d.x * d.y, 0);
                        const sumX2 = datos.reduce((sum, d) => sum + d.x * d.x, 0);
                        
                        const beta1 = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                        const beta0 = (sumY - beta1 * sumX) / n;
                        
                        return {beta0, beta1};
                    };
                    
                    const regControl = calcRegression(control);
                    const regTratamiento = calcRegression(tratamiento);
                    
                    // Dibujar puntos
                    control.forEach(d => {
                        const point = document.createElementNS(svgNS, "circle");
                        point.setAttribute("cx", 50 + d.x * 5);
                        point.setAttribute("cy", 300 - d.y * 2);
                        point.setAttribute("r", "5");
                        point.setAttribute("fill", "#3498db");
                        point.setAttribute("opacity", "0.8");
                        svg.appendChild(point);
                    });
                    
                    tratamiento.forEach(d => {
                        const point = document.createElementNS(svgNS, "circle");
                        point.setAttribute("cx", 50 + d.x * 5);
                        point.setAttribute("cy", 300 - d.y * 2);
                        point.setAttribute("r", "5");
                        point.setAttribute("fill", "#e74c3c");
                        point.setAttribute("opacity", "0.8");
                        svg.appendChild(point);
                    });
                    
                    // Líneas de regresión
                    const lineControl = document.createElementNS(svgNS, "line");
                    lineControl.setAttribute("x1", "50");
                    lineControl.setAttribute("y1", 300 - (regControl.beta0 + regControl.beta1 * 20) * 2);
                    lineControl.setAttribute("x2", "300");
                    lineControl.setAttribute("y2", 300 - (regControl.beta0 + regControl.beta1 * 55) * 2);
                    lineControl.setAttribute("stroke", "#3498db");
                    lineControl.setAttribute("stroke-width", "2");
                    svg.appendChild(lineControl);
                    
                    const lineTratamiento = document.createElementNS(svgNS, "line");
                    lineTratamiento.setAttribute("x1", "50");
                    lineTratamiento.setAttribute("y1", 300 - (regTratamiento.beta0 + regTratamiento.beta1 * 20) * 2);
                    lineTratamiento.setAttribute("x2", "300");
                    lineTratamiento.setAttribute("y2", 300 - (regTratamiento.beta0 + regTratamiento.beta1 * 55) * 2);
                    lineTratamiento.setAttribute("stroke", "#e74c3c");
                    lineTratamiento.setAttribute("stroke-width", "2");
                    svg.appendChild(lineTratamiento);
                    
                    // Ajuste paralelo (ANCOVA asume pendientes iguales)
                    const lineAjustada = document.createElementNS(svgNS, "line");
                    lineAjustada.setAttribute("x1", "50");
                    lineAjustada.setAttribute("y1", "220");
                    lineAjustada.setAttribute("x2", "300");
                    lineAjustada.setAttribute("y2", "180");
                    lineAjustada.setAttribute("stroke", "#27ae60");
                    lineAjustada.setAttribute("stroke-width", "3");
                    lineAjustada.setAttribute("stroke-dasharray", "5,5");
                    svg.appendChild(lineAjustada);
                    
                    // Resultado ANCOVA
                    const resultText = document.createElementNS(svgNS, "text");
                    resultText.setAttribute("x", "250");
                    resultText.setAttribute("y", "380");
                    resultText.setAttribute("text-anchor", "middle");
                    resultText.setAttribute("font-size", "12");
                    resultText.setAttribute("fill", "#27ae60");
                    resultText.textContent = "ANCOVA: Efecto Grupo p = 0.008** (ajustado por Edad)";
                    svg.appendChild(resultText);
                }
                
                div.appendChild(svg);
            }
        },
        {
            id: 8,
            title: "8. Modelos Avanzados: GLM y Regularización",
            icon: "fa-project-diagram",
            controls: [
                {id: 'advanced', type: 'select', label: 'Modelo Avanzado', 
                 options: ['Regresión Logística', 'Modelos Mixtos (GLMM)', 'LASSO/Ridge']}
            ],
            code: (p) => {
                switch(p.advanced) {
                    case 'Regresión Logística':
                        return `<span class="c-com"># Regresión Logística: Resultado binario (0/1)</span>
<span class="c-var">datos</span> <span class="c-op"><-</span> <span class="c-fn">data.frame</span>(
  <span class="c-arg">Edad</span> = <span class="c-fn">c</span>(<span class="c-num">25</span>, <span class="c-num">34</span>, <span class="c-num">52</span>, <span class="c-num">47</span>, <span class="c-num">30</span>, <span class="c-num">62</span>, <span class="c-num">41</span>, <span class="c-num">38</span>),
  <span class="c-arg">IMC</span> = <span class="c-fn">c</span>(<span class="c-num">22</span>, <span class="c-num">25</span>, <span class="c-num">31</span>, <span class="c-num">28</span>, <span class="c-num">24</span>, <span class="c-num">32</span>, <span class="c-num">27</span>, <span class="c-num">26</span>),
  <span class="c-arg">Diabetes</span> = <span class="c-fn">c</span>(<span class="c-num">0</span>, <span class="c-num">0</span>, <span class="c-num">1</span>, <span class="c-num">1</span>, <span class="c-num">0</span>, <span class="c-num">1</span>, <span class="c-num">0</span>, <span class="c-num">0</span>)
)

<span class="c-var">modelo_logit</span> <span class="c-op"><-</span> <span class="c-fn">glm</span>(Diabetes <span class="c-op">~</span> Edad <span class="c-op">+</span> IMC, 
                     <span class="c-arg">family</span> = <span class="c-fn">binomial</span>(<span class="c-arg">link</span> = <span class="c-str">"logit"</span>),
                     <span class="c-arg">data</span> = <span class="c-var">datos</span>)

<span class="c-fn">summary</span>(<span class="c-var">modelo_logit</span>)

<span class="c-com"># Odds Ratios (exponenciar coeficientes)</span>
<span class="c-fn">exp</span>(<span class="c-fn">coef</span>(<span class="c-var">modelo_logit</span>))`;

                    case 'Modelos Mixtos (GLMM)':
                        return `<span class="c-com"># Modelos Mixtos: Datos jerárquicos/longitudinales</span>
<span class="c-kwd">library</span>(lme4)

<span class="c-var">datos_long</span> <span class="c-op"><-</span> <span class="c-fn">data.frame</span>(
  <span class="c-arg">Paciente</span> = <span class="c-fn">factor</span>(<span class="c-fn">rep</span>(<span class="c-num">1</span>:<span class="c-num">10</span>, <span class="c-arg">each</span>=<span class="c-num">3</span>)),  <span class="c-com"># 3 mediciones por paciente</span>
  <span class="c-arg">Tiempo</span> = <span class="c-fn">rep</span>(<span class="c-fn">c</span>(<span class="c-num">0</span>, <span class="c-num">3</span>, <span class="c-num">6</span>), <span class="c-num">10</span>),  <span class="c-com"># Meses</span>
  <span class="c-arg">Hospital</span> = <span class="c-fn">factor</span>(<span class="c-fn">rep</span>(<span class="c-fn">c</span>(<span class="c-str">"A"</span>,<span class="c-str">"B"</span>), <span class="c-arg">each</span>=<span class="c-num">15</span>)),  <span class="c-com"># 2 hospitales</span>
  <span class="c-arg">Glucosa</span> = <span class="c-fn">rnorm</span>(<span class="c-num">30</span>, <span class="c-num">100</span>, <span class="c-num">15</span>)
)

<span class="c-com"># GLMM con intercepto aleatorio por Paciente</span>
<span class="c-var">modelo_mixto</span> <span class="c-op"><-</span> <span class="c-fn">lmer</span>(Glucosa <span class="c-op">~</span> Tiempo <span class="c-op">+</span> (<span class="c-num">1</span> | Paciente) <span class="c-op">+</span> (<span class="c-num">1</span> | Hospital),
                    <span class="c-arg">data</span> = <span class="c-var">datos_long</span>)

<span class="c-fn">summary</span>(<span class="c-var">modelo_mixto</span>)`;

                    case 'LASSO/Ridge':
                        return `<span class="c-com"># Regularización: LASSO y Ridge para selección de variables</span>
<span class="c-kwd">library</span>(glmnet)

<span class="c-com"># Datos con muchas variables (p > n)</span>
<span class="c-var">X</span> <span class="c-op"><-</span> <span class="c-fn">matrix</span>(<span class="c-fn">rnorm</span>(<span class="c-num">100</span>*<span class="c-num">50</span>), <span class="c-num">100</span>, <span class="c-num">50</span>)  <span class="c-com"># 100 obs, 50 vars</span>
<span class="c-var">y</span> <span class="c-op"><-</span> X[,<span class="c-num">1</span>] <span class="c-op">+</span> <span class="c-num">2</span>*X[,<span class="c-num">2</span>] <span class="c-op">+</span> <span class="c-fn">rnorm</span>(<span class="c-num">100</span>)  <span class="c-com"># Solo 2 variables relevantes</span>

<span class="c-com"># LASSO (L1) - Algunos coeficientes a cero</span>
<span class="c-var">lasso_model</span> <span class="c-op"><-</span> <span class="c-fn">glmnet</span>(X, y, <span class="c-arg">alpha</span> = <span class="c-num">1</span>)  <span class="c-com"># alpha=1: LASSO</span>

<span class="c-com"># Ridge (L2) - Todos coeficientes pequeños</span>
<span class="c-var">ridge_model</span> <span class="c-op"><-</span> <span class="c-fn">glmnet</span>(X, y, <span class="c-arg">alpha</span> = <span class="c-num">0</span>)  <span class="c-com"># alpha=0: Ridge</span>

<span class="c-com"># Validación cruzada para lambda óptimo</span>
<span class="c-var">cv_lasso</span> <span class="c-op"><-</span> <span class="c-fn">cv.glmnet</span>(X, y, <span class="c-arg">alpha</span> = <span class="c-num">1</span>)
<span class="c-fn">plot</span>(<span class="c-var">cv_lasso</span>)`;
                }
            },
            explain: (p) => {
                const models = {
                    'Regresión Logística': `<h3>Regresión Logística Binaria</h3>
                    <p>Modela la probabilidad de un evento binario (0/1) usando la función logit.</p>
                    <p><b>Función logit:</b> $logit(p) = \\ln\\left(\\frac{p}{1-p}\\right) = \\beta_0 + \\beta_1X_1 + ...$</p>
                    <p><b>Odds Ratio (OR):</b> $OR = e^{\\beta}$</p>
                    <div class="theory-highlight">
                        <b>Interpretación OR:</b><br>
                        • OR = 1: Sin efecto<br>
                        • OR > 1: Factor de riesgo (por cada OR, aumenta la probabilidad)<br>
                        • OR < 1: Factor protector
                    </div>`,
                    
                    'Modelos Mixtos (GLMM)': `<h3>Modelos Lineales Mixtos Generalizados (GLMM)</h3>
                    <p>Para datos con estructura jerárquica o correlacionados.</p>
                    <p><b>Componentes:</b><br>
                    • <b>Efectos fijos:</b> Parámetros que describen la población promedio<br>
                    • <b>Efectos aleatorios:</b> Variabilidad entre grupos/individuos</p>
                    <div class="theory-highlight">
                        <b>Aplicaciones típicas:</b><br>
                        1. Estudios longitudinales (medidas repetidas)<br>
                        2. Pacientes anidados en hospitales<br>
                        3. Diseños de bloques aleatorizados
                    </div>`,
                    
                    'LASSO/Ridge': `<h3>Regularización: LASSO y Ridge</h3>
                    <p>Técnicas para evitar sobreajuste en modelos con muchas variables.</p>
                    <p><b>LASSO (L1):</b> $\\min\\left(\\text{RSS} + \\lambda\\sum|\\beta_j|\\right)$<br>
                    • Pone algunos coeficientes a cero → selección de variables</p>
                    <p><b>Ridge (L2):</b> $\\min\\left(\\text{RSS} + \\lambda\\sum\\beta_j^2\\right)$<br>
                    • Reduce coeficientes pero no a cero → maneja multicolinealidad</p>
                    <div class="theory-highlight">
                        <b>Elastic Net:</b><br>
                        Combinación de LASSO y Ridge: $\\alpha$ controla la mezcla (0=Ridge, 1=LASSO)
                    </div>`
                };
                return models[p.advanced];
            },
            render: (p, div) => {
                div.innerHTML = '';
                const svg = createSVG("100%", "100%", "0 0 500 400");
                
                // Fondo
                const bg = document.createElementNS(svgNS, "rect");
                bg.setAttribute("width", "500");
                bg.setAttribute("height", "400");
                bg.setAttribute("fill", "white");
                svg.appendChild(bg);
                
                // Título
                const title = document.createElementNS(svgNS, "text");
                title.setAttribute("x", "250");
                title.setAttribute("y", "30");
                title.setAttribute("text-anchor", "middle");
                title.setAttribute("font-size", "14");
                title.setAttribute("font-weight", "bold");
                title.setAttribute("fill", "#2c3e50");
                title.textContent = `Modelo Avanzado: ${p.advanced}`;
                svg.appendChild(title);
                
                if (p.advanced === 'Regresión Logística') {
                    // Función sigmoide
                    const sigmoid = (x) => 1 / (1 + Math.exp(-x));
                    
                    // Dibujar función sigmoide
                    const curve = document.createElementNS(svgNS, "path");
                    let pathData = "";
                    
                    for (let i = 0; i <= 400; i++) {
                        const x = -4 + (i / 400) * 8;
                        const y = sigmoid(x);
                        const xScaled = 50 + i;
                        const yScaled = 350 - y * 200;
                        
                        if (i === 0) {
                            pathData = `M ${xScaled} ${yScaled}`;
                        } else {
                            pathData += ` L ${xScaled} ${yScaled}`;
                        }
                    }
                    
                    curve.setAttribute("d", pathData);
                    curve.setAttribute("fill", "none");
                    curve.setAttribute("stroke", "#e74c3c");
                    curve.setAttribute("stroke-width", "3");
                    svg.appendChild(curve);
                    
                    // Ejes
                    const xAxis = document.createElementNS(svgNS, "line");
                    xAxis.setAttribute("x1", "50");
                    xAxis.setAttribute("y1", "350");
                    xAxis.setAttribute("x2", "450");
                    xAxis.setAttribute("y2", "350");
                    xAxis.setAttribute("stroke", "#333");
                    xAxis.setAttribute("stroke-width", "1.5");
                    svg.appendChild(xAxis);
                    
                    const yAxis = document.createElementNS(svgNS, "line");
                    yAxis.setAttribute("x1", "250");
                    yAxis.setAttribute("y1", "50");
                    yAxis.setAttribute("x2", "250");
                    yAxis.setAttribute("y2", "350");
                    yAxis.setAttribute("stroke", "#333");
                    yAxis.setAttribute("stroke-width", "1.5");
                    svg.appendChild(yAxis);
                    
                    // Puntos de datos (0 y 1)
                    for (let i = 0; i < 20; i++) {
                        const x = -3 + Math.random() * 6;
                        const prob = sigmoid(x);
                        const y = Math.random() < prob ? 1 : 0;
                        
                        const point = document.createElementNS(svgNS, "circle");
                        point.setAttribute("cx", 250 + x * 50);
                        point.setAttribute("cy", 350 - y * 150 - 25);
                        point.setAttribute("r", "4");
                        point.setAttribute("fill", y === 1 ? "#e74c3c" : "#3498db");
                        point.setAttribute("opacity", "0.7");
                        svg.appendChild(point);
                    }
                    
                    // Etiquetas
                    const xLabel = document.createElementNS(svgNS, "text");
                    xLabel.setAttribute("x", "450");
                    xLabel.setAttribute("y", "370");
                    xLabel.setAttribute("text-anchor", "end");
                    xLabel.setAttribute("font-size", "10");
                    xLabel.setAttribute("fill", "#2c3e50");
                    xLabel.textContent = "Score lineal (β₀ + ΣβᵢXᵢ)";
                    svg.appendChild(xLabel);
                    
                    const yLabel = document.createElementNS(svgNS, "text");
                    yLabel.setAttribute("x", "260");
                    yLabel.setAttribute("y", "40");
                    yLabel.setAttribute("font-size", "10");
                    yLabel.setAttribute("fill", "#2c3e50");
                    yLabel.textContent = "Probabilidad P(Y=1)";
                    svg.appendChild(yLabel);
                    
                    // Umbral de decisión (0.5)
                    const threshold = document.createElementNS(svgNS, "line");
                    threshold.setAttribute("x1", "50");
                    threshold.setAttribute("y1", "250");
                    threshold.setAttribute("x2", "450");
                    threshold.setAttribute("y2", "250");
                    threshold.setAttribute("stroke", "#27ae60");
                    threshold.setAttribute("stroke-width", "1");
                    threshold.setAttribute("stroke-dasharray", "5,5");
                    svg.appendChild(threshold);
                    
                    const thresholdText = document.createElementNS(svgNS, "text");
                    thresholdText.setAttribute("x", "470");
                    thresholdText.setAttribute("y", "255");
                    thresholdText.setAttribute("text-anchor", "end");
                    thresholdText.setAttribute("font-size", "10");
                    thresholdText.setAttribute("fill", "#27ae60");
                    thresholdText.textContent = "Umbral 0.5";
                    svg.appendChild(thresholdText);
                    
                } else if (p.advanced === 'Modelos Mixtos (GLMM)') {
                    // Representación de datos jerárquicos
                    const hospitales = ['A', 'B', 'C'];
                    const pacientesPorHospital = 4;
                    
                    let yOffset = 80;
                    
                    hospitales.forEach((hospital, hIdx) => {
                        // Grupo hospital
                        const hospitalGroup = document.createElementNS(svgNS, "g");
                        
                        // Rectángulo hospital
                        const rect = document.createElementNS(svgNS, "rect");
                        rect.setAttribute("x", "50");
                        rect.setAttribute("y", yOffset);
                        rect.setAttribute("width", "400");
                        rect.setAttribute("height", "80");
                        rect.setAttribute("fill", hIdx === 0 ? "#3498db" : hIdx === 1 ? "#e74c3c" : "#2ecc71");
                        rect.setAttribute("opacity", "0.2");
                        rect.setAttribute("rx", "8");
                        hospitalGroup.appendChild(rect);
                        
                        // Etiqueta hospital
                        const label = document.createElementNS(svgNS, "text");
                        label.setAttribute("x", "70");
                        label.setAttribute("y", yOffset + 20);
                        label.setAttribute("font-size", "12");
                        label.setAttribute("fill", "#2c3e50");
                        label.setAttribute("font-weight", "bold");
                        label.textContent = `Hospital ${hospital} (Efecto aleatorio: ${(hIdx - 1) * 5})`;
                        hospitalGroup.appendChild(label);
                        
                        // Pacientes dentro del hospital
                        for (let p = 0; p < pacientesPorHospital; p++) {
                            const pacienteGroup = document.createElementNS(svgNS, "g");
                            
                            // Círculo paciente
                            const paciente = document.createElementNS(svgNS, "circle");
                            paciente.setAttribute("cx", 100 + p * 80);
                            paciente.setAttribute("cy", yOffset + 50);
                            paciente.setAttribute("r", "15");
                            paciente.setAttribute("fill", hIdx === 0 ? "#2980b9" : hIdx === 1 ? "#c0392b" : "#27ae60");
                            paciente.setAttribute("opacity", "0.7");
                            pacienteGroup.appendChild(paciente);
                            
                            // Etiqueta paciente
                            const pacienteLabel = document.createElementNS(svgNS, "text");
                            pacienteLabel.setAttribute("x", 100 + p * 80);
                            pacienteLabel.setAttribute("y", yOffset + 85);
                            pacienteLabel.setAttribute("text-anchor", "middle");
                            pacienteLabel.setAttribute("font-size", "9");
                            pacienteLabel.setAttribute("fill", "#2c3e50");
                            pacienteLabel.textContent = `Paciente ${String.fromCharCode(65 + p)}`;
                            pacienteGroup.appendChild(pacienteLabel);
                            
                            // Mediciones longitudinales
                            for (let t = 0; t < 3; t++) {
                                const medida = document.createElementNS(svgNS, "circle");
                                medida.setAttribute("cx", 100 + p * 80 - 10 + t * 10);
                                medida.setAttribute("cy", yOffset + 50 - 10 + t * 10);
                                medida.setAttribute("r", "3");
                                medida.setAttribute("fill", "#f1c40f");
                                medida.setAttribute("opacity", "0.9");
                                pacienteGroup.appendChild(medida);
                            }
                            
                            hospitalGroup.appendChild(pacienteGroup);
                        }
                        
                        svg.appendChild(hospitalGroup);
                        yOffset += 100;
                    });
                    
                    // Línea de efecto fijo
                    const fixedEffect = document.createElementNS(svgNS, "line");
                    fixedEffect.setAttribute("x1", "50");
                    fixedEffect.setAttribute("y1", "60");
                    fixedEffect.setAttribute("x2", "450");
                    fixedEffect.setAttribute("y2", "60");
                    fixedEffect.setAttribute("stroke", "#2c3e50");
                    fixedEffect.setAttribute("stroke-width", "2");
                    fixedEffect.setAttribute("stroke-dasharray", "5,5");
                    svg.appendChild(fixedEffect);
                    
                    const fixedLabel = document.createElementNS(svgNS, "text");
                    fixedLabel.setAttribute("x", "470");
                    fixedLabel.setAttribute("y", "65");
                    fixedLabel.setAttribute("text-anchor", "end");
                    fixedLabel.setAttribute("font-size", "10");
                    fixedLabel.setAttribute("fill", "#2c3e50");
                    fixedLabel.textContent = "Efecto fijo (media población)";
                    svg.appendChild(fixedLabel);
                    
                } else if (p.advanced === 'LASSO/Ridge') {
                    // Comparación coeficientes
                    const coeffGroup = document.createElementNS(svgNS, "g");
                    
                    // 20 variables simuladas
                    const nVars = 20;
                    const trueCoeffs = [2.5, -1.8, 0, 0, 0, 1.2, 0, 0, 0, -0.8, 0, 0, 0, 0, 0, 0.5, 0, 0, 0, 0];
                    
                    // Coeficientes LASSO (algunos a cero)
                    const lassoCoeffs = trueCoeffs.map((c, i) => {
                        if (c === 0) return Math.random() < 0.7 ? 0 : Math.random() * 0.3;
                        return c * (0.8 + Math.random() * 0.4);
                    });
                    
                    // Coeficientes Ridge (todos pequeños)
                    const ridgeCoeffs = trueCoeffs.map((c, i) => {
                        if (c === 0) return (Math.random() - 0.5) * 0.4;
                        return c * (0.6 + Math.random() * 0.3);
                    });
                    
                    // Dibujar coeficientes
                    [trueCoeffs, lassoCoeffs, ridgeCoeffs].forEach((coeffs, modelIdx) => {
                        const yBase = 100 + modelIdx * 80;
                        const colors = ['#2c3e50', '#e74c3c', '#3498db'];
                        const labels = ['Verdaderos', 'LASSO (L1)', 'Ridge (L2)'];
                        
                        // Etiqueta modelo
                        const modelLabel = document.createElementNS(svgNS, "text");
                        modelLabel.setAttribute("x", "30");
                        modelLabel.setAttribute("y", yBase - 10);
                        modelLabel.setAttribute("font-size", "11");
                        modelLabel.setAttribute("fill", colors[modelIdx]);
                        modelLabel.setAttribute("font-weight", "bold");
                        modelLabel.textContent = labels[modelIdx];
                        coeffGroup.appendChild(modelLabel);
                        
                        // Barras de coeficientes
                        coeffs.forEach((coeff, i) => {
                            const x = 80 + i * 20;
                            const height = Math.abs(coeff) * 15;
                            const y = coeff >= 0 ? yBase - height : yBase;
                            
                            const bar = document.createElementNS(svgNS, "rect");
                            bar.setAttribute("x", x);
                            bar.setAttribute("y", y);
                            bar.setAttribute("width", "15");
                            bar.setAttribute("height", height);
                            bar.setAttribute("fill", coeff === 0 ? "#95a5a6" : colors[modelIdx]);
                            bar.setAttribute("opacity", "0.8");
                            coeffGroup.appendChild(bar);
                            
                            // Etiqueta variable
                            if (modelIdx === 0 && i % 4 === 0) {
                                const varLabel = document.createElementNS(svgNS, "text");
                                varLabel.setAttribute("x", x + 7.5);
                                varLabel.setAttribute("y", yBase + 20);
                                varLabel.setAttribute("text-anchor", "middle");
                                varLabel.setAttribute("font-size", "8");
                                varLabel.setAttribute("fill", "#7f8c8d");
                                varLabel.textContent = `X${i + 1}`;
                                coeffGroup.appendChild(varLabel);
                            }
                        });
                    });
                    
                    svg.appendChild(coeffGroup);
                    
                    // Explicación
                    const explanation = document.createElementNS(svgNS, "text");
                    explanation.setAttribute("x", "250");
                    explanation.setAttribute("y", "380");
                    explanation.setAttribute("text-anchor", "middle");
                    explanation.setAttribute("font-size", "11");
                    explanation.setAttribute("fill", "#2c3e50");
                    explanation.innerHTML = `
                        <tspan x="250" dy="0">LASSO: Coeficientes a cero → selección de variables</tspan>
                        <tspan x="250" dy="15">Ridge: Todos coeficientes pequeños → estabiliza estimaciones</tspan>
                    `;
                    svg.appendChild(explanation);
                }
                
                div.appendChild(svg);
            }
        },
        {
            id: 9,
            title: "9. Reducción de Dimensión: PCA/EFA",
            icon: "fa-compress-arrows-alt",
            controls: [
                {id: 'method', type: 'select', label: 'Método de Reducción', 
                 options: ['PCA (Componentes Principales)', 'EFA (Factorial Exploratorio)']}
            ],
            code: (p) => {
                if (p.method === 'PCA (Componentes Principales)') {
                    return `<span class="c-com"># PCA: Reducción no supervisada, busca máxima varianza</span>
<span class="c-kwd">library</span>(FactoMineR)
<span class="c-kwd">library</span>(factoextra)

<span class="c-com"># Datos de expresión génica (100 genes × 50 muestras)</span>
<span class="c-var">datos_gen</span> <span class="c-op"><-</span> <span class="c-fn">as.data.frame</span>(<span class="c-fn">scale</span>(<span class="c-fn">matrix</span>(<span class="c-fn">rnorm</span>(<span class="c-num">100</span>*<span class="c-num">50</span>), <span class="c-num">100</span>, <span class="c-num">50</span>)))

<span class="c-var">pca_result</span> <span class="c-op"><-</span> <span class="c-fn">PCA</span>(<span class="c-var">datos_gen</span>, <span class="c-arg">graph</span> = <span class="c-kwd">FALSE</span>)

<span class="c-com"># Varianza explicada por cada componente</span>
<span class="c-var">eig_val</span> <span class="c-op"><-</span> <span class="c-fn">get_eigenvalue</span>(<span class="c-var">pca_result</span>)
<span class="c-fn">print</span>(<span class="c-var">eig_val</span>)

<span class="c-com"># Scree plot (gráfico de sedimentación)</span>
<span class="c-fn">fviz_eig</span>(<span class="c-var">pca_result</span>, <span class="c-arg">addlabels</span> = <span class="c-kwd">TRUE</span>)

<span class="c-com"># Biplot: muestras y variables</span>
<span class="c-fn">fviz_pca_biplot</span>(<span class="c-var">pca_result</span>, 
                 <span class="c-arg">col.ind</span> = <span class="c-str">"cos2"</span>,  <span class="c-com"># Calidad de representación</span>
                 <span class="c-arg">gradient.cols</span> = <span class="c-fn">c</span>(<span class="c-str">"blue"</span>, <span class="c-str">"yellow"</span>, <span class="c-str">"red"</span>))`;
                } else {
                    return `<span class="c-com"># EFA: Descubrir factores latentes subyacentes</span>
<span class="c-kwd">library</span>(psych)

<span class="c-com"># Datos de cuestionario con 20 items</span>
<span class="c-var">datos_cuestionario</span> <span class="c-op"><-</span> <span class="c-fn">as.data.frame</span>(<span class="c-fn">scale</span>(<span class="c-fn">matrix</span>(<span class="c-fn">rnorm</span>(<span class="c-num">200</span>*<span class="c-num">20</span>), <span class="c-num">200</span>, <span class="c-num">20</span>)))

<span class="c-com"># Test de adecuación muestral de Kaiser-Meyer-Olkin</span>
<span class="c-fn">KMO</span>(<span class="c-var">datos_cuestionario</span>)

<span class="c-com"># Determinación del número de factores</span>
<span class="c-var">parallel</span> <span class="c-op"><-</span> <span class="c-fn">fa.parallel</span>(<span class="c-var">datos_cuestionario</span>, 
                       <span class="c-arg">fa</span> = <span class="c-str">"fa"</span>, 
                       <span class="c-arg">n.iter</span> = <span class="c-num">100</span>)

<span class="c-com"># EFA con rotación Varimax (ortogonal)</span>
<span class="c-var">efa_result</span> <span class="c-op"><-</span> <span class="c-fn">fa</span>(<span class="c-var">datos_cuestionario</span>,
                   <span class="c-arg">nfactors</span> = <span class="c-num">4</span>,  <span class="c-com"># Según análisis paralelo</span>
                   <span class="c-arg">rotate</span> = <span class="c-str">"varimax"</span>,
                   <span class="c-arg">fm</span> = <span class="c-str">"ml"</span>)  <span class="c-com"># Máxima verosimilitud</span>

<span class="c-fn">print</span>(<span class="c-var">efa_result</span><span class="c-op">$</span><span class="c-var">loadings</span>, <span class="c-arg">cut</span> = <span class="c-num">0.3</span>)  <span class="c-com"># Solo cargas > 0.3</span>

<span class="c-com"># Diagrama de factores</span>
<span class="c-fn">fa.diagram</span>(<span class="c-var">efa_result</span>)`;
                }
            },
            explain: (p) => {
                if (p.method === 'PCA (Componentes Principales)') {
                    return `<h3>Análisis de Componentes Principales (PCA)</h3>
                    <p><b>Objetivo:</b> Reducir dimensionalidad manteniendo la máxima varianza.</p>
                    <p><b>Mecanismo:</b> Encuentra direcciones ortogonales (componentes) que maximizan la varianza.</p>
                    
                    <div class="theory-highlight">
                        <b>Interpretación PCA:</b><br>
                        1. <b>Eigenvalues:</b> Varianza explicada por cada componente<br>
                        2. <b>Scree plot:</b> Decide número de componentes (codo)<br>
                        3. <b>Biplot:</b> Visualiza muestras y variables en componentes
                    </div>
                    
                    <p><b>Aplicación en bioinformática:</b> Visualizar agrupamientos en RNA-seq, reducir ruido en datos ómicos.</p>`;
                } else {
                    return `<h3>Análisis Factorial Exploratorio (EFA)</h3>
                    <p><b>Objetivo:</b> Descubrir factores latentes que explican correlaciones entre variables observadas.</p>
                    <p><b>Modelo:</b> $X = \\Lambda F + \\epsilon$ donde Λ son cargas factoriales, F factores latentes.</p>
                    
                    <div class="theory-highlight">
                        <b>Rotaciones factoriales:</b><br>
                        1. <b>Varimax:</b> Maximiza varianza de cargas (factores no correlacionados)<br>
                        2. <b>Promax/Oblimin:</b> Permite correlación entre factores (más realista)
                    </div>
                    
                    <p><b>Aplicación:</b> Validación de cuestionarios, identificación de dominios clínicos, psicometría.</p>`;
                }
            },
            render: (p, div) => {
                // 1. CORRECCIÓN DE CAJA (Igual que en el Módulo 10)
                div.style.alignItems = "flex-start";
                div.style.justifyContent = "center";
                div.style.paddingTop = "10px";
                div.innerHTML = '';
                
                // 2. LIENZO MÁS ALTO (450px) para que quepan los dos gráficos del PCA
                const svg = createSVG("100%", "480", "0 0 500 480");
                svg.style.display = "block";
                
                // Fondo
                const bg = document.createElementNS(svgNS, "rect");
                bg.setAttribute("width", "500");
                bg.setAttribute("height", "480");
                bg.setAttribute("fill", "white");
                svg.appendChild(bg);
                
                // Título Principal
                const title = document.createElementNS(svgNS, "text");
                title.setAttribute("x", "250");
                title.setAttribute("y", "30");
                title.setAttribute("text-anchor", "middle");
                title.setAttribute("font-size", "14");
                title.setAttribute("font-weight", "bold");
                title.setAttribute("fill", "#2c3e50");
                title.textContent = `Análisis: ${p.method}`;
                svg.appendChild(title);
                
                if (p.method === 'PCA (Componentes Principales)') {
                    // --- ZONA SUPERIOR: BIPLOT (Muestras y Variables) ---
                    // Centro del Biplot en y=150
                    const biplotCenterY = 160;
                    const biplotCenterX = 250;
                    
                    const biplotLabel = document.createElementNS(svgNS, "text");
                    biplotLabel.setAttribute("x", "50");
                    biplotLabel.setAttribute("y", "60");
                    biplotLabel.setAttribute("font-size", "12");
                    biplotLabel.setAttribute("font-weight", "bold");
                    biplotLabel.setAttribute("fill", "#2c3e50");
                    biplotLabel.textContent = "A. Biplot (PC1 vs PC2)";
                    svg.appendChild(biplotLabel);

                    const biplotGroup = document.createElementNS(svgNS, "g");
                    // No usamos translate global para tener control absoluto, calculamos coordenadas relativas
                    
                    // Ejes cruzados del Biplot
                    const xAxis = document.createElementNS(svgNS, "line");
                    xAxis.setAttribute("x1", biplotCenterX - 150); xAxis.setAttribute("y1", biplotCenterY);
                    xAxis.setAttribute("x2", biplotCenterX + 150); xAxis.setAttribute("y2", biplotCenterY);
                    xAxis.setAttribute("stroke", "#ddd"); xAxis.setAttribute("stroke-width", "1");
                    svg.appendChild(xAxis);
                    
                    const yAxis = document.createElementNS(svgNS, "line");
                    yAxis.setAttribute("x1", biplotCenterX); yAxis.setAttribute("y1", biplotCenterY - 100);
                    yAxis.setAttribute("x2", biplotCenterX); yAxis.setAttribute("y2", biplotCenterY + 100);
                    yAxis.setAttribute("stroke", "#ddd"); yAxis.setAttribute("stroke-width", "1");
                    svg.appendChild(yAxis);
                    
                    // Muestras (Puntos dispersos)
                    for (let i = 0; i < 30; i++) {
                        const x = (Math.random() - 0.5) * 200; // Dispersión en X
                        const y = (Math.random() - 0.5) * 150; // Dispersión en Y
                        const group = i < 15 ? "A" : "B";
                        
                        const point = document.createElementNS(svgNS, "circle");
                        point.setAttribute("cx", biplotCenterX + x);
                        point.setAttribute("cy", biplotCenterY + y);
                        point.setAttribute("r", "4");
                        point.setAttribute("fill", group === "A" ? "#3498db" : "#e74c3c");
                        point.setAttribute("opacity", "0.6");
                        svg.appendChild(point);
                    }
                    
                    // Variables (Vectores - Genes) - Los dibujamos encima de los puntos
                    const variables = [
                        {name: "Gen1", x: 0.8, y: 0.2},
                        {name: "Gen2", x: 0.6, y: 0.5},
                        {name: "Gen3", x: 0.3, y: 0.7},
                        {name: "Gen4", x: -0.4, y: 0.6},
                        {name: "Gen5", x: -0.7, y: 0.1}
                    ];
                    
                    variables.forEach((var_) => {
                        const endX = biplotCenterX + var_.x * 80;
                        const endY = biplotCenterY - var_.y * 80; // Restamos Y porque en SVG Y crece hacia abajo
                        
                        const vector = document.createElementNS(svgNS, "line");
                        vector.setAttribute("x1", biplotCenterX);
                        vector.setAttribute("y1", biplotCenterY);
                        vector.setAttribute("x2", endX);
                        vector.setAttribute("y2", endY);
                        vector.setAttribute("stroke", "#27ae60");
                        vector.setAttribute("stroke-width", "2");
                        svg.appendChild(vector);
                        
                        const label = document.createElementNS(svgNS, "text");
                        label.setAttribute("x", endX + (var_.x * 10));
                        label.setAttribute("y", endY - (var_.y * 10));
                        label.setAttribute("text-anchor", "middle");
                        label.setAttribute("font-size", "10");
                        label.setAttribute("fill", "#27ae60");
                        label.setAttribute("font-weight", "bold");
                        label.textContent = var_.name;
                        svg.appendChild(label);
                    });
                    
                    // --- ZONA INFERIOR: SCREE PLOT (Sedimentación) ---
                    // Lo bajamos totalmente a y=320 para que no toque lo de arriba
                    const screeYBase = 440; // Línea base del gráfico de barras
                    const screeXStart = 80;
                    
                    const screeLabel = document.createElementNS(svgNS, "text");
                    screeLabel.setAttribute("x", "50");
                    screeLabel.setAttribute("y", "310");
                    screeLabel.setAttribute("font-size", "12");
                    screeLabel.setAttribute("font-weight", "bold");
                    screeLabel.setAttribute("fill", "#2c3e50");
                    screeLabel.textContent = "B. Scree Plot (Varianza Explicada)";
                    svg.appendChild(screeLabel);
                    
                    // Línea base X
                    const screeLine = document.createElementNS(svgNS, "line");
                    screeLine.setAttribute("x1", "50"); screeLine.setAttribute("y1", screeYBase);
                    screeLine.setAttribute("x2", "450"); screeLine.setAttribute("y2", screeYBase);
                    screeLine.setAttribute("stroke", "#333");
                    svg.appendChild(screeLine);
                    
                    const eigenvalues = [4.2, 3.1, 2.3, 1.8, 1.2, 0.9, 0.7, 0.5, 0.4, 0.3];
                    const varAcum = eigenvalues.map((_, i) => 
                        eigenvalues.slice(0, i + 1).reduce((a, b) => a + b, 0) / eigenvalues.reduce((a, b) => a + b, 0) * 100
                    );
                    
                    eigenvalues.forEach((eig, i) => {
                        const x = screeXStart + i * 35;
                        const height = eig * 20; // Escala reducida para que quepa bien
                        
                        const bar = document.createElementNS(svgNS, "rect");
                        bar.setAttribute("x", x - 10);
                        bar.setAttribute("y", screeYBase - height);
                        bar.setAttribute("width", "20");
                        bar.setAttribute("height", height);
                        bar.setAttribute("fill", eig > 1 ? "#3498db" : "#95a5a6"); // Kaiser criterion visual
                        svg.appendChild(bar);
                        
                        const eigText = document.createElementNS(svgNS, "text");
                        eigText.setAttribute("x", x);
                        eigText.setAttribute("y", screeYBase - height - 5);
                        eigText.setAttribute("text-anchor", "middle");
                        eigText.setAttribute("font-size", "9");
                        eigText.setAttribute("fill", "#333");
                        eigText.textContent = eig.toFixed(1);
                        svg.appendChild(eigText);
                        
                        const compText = document.createElementNS(svgNS, "text");
                        compText.setAttribute("x", x);
                        compText.setAttribute("y", screeYBase + 15);
                        compText.setAttribute("text-anchor", "middle");
                        compText.setAttribute("font-size", "9");
                        compText.setAttribute("fill", "#666");
                        compText.textContent = `PC${i + 1}`;
                        svg.appendChild(compText);
                    });
                    
                    // Línea Kaiser (eigenvalue = 1)
                    const kaiserY = screeYBase - (1 * 20);
                    const kaiserLine = document.createElementNS(svgNS, "line");
                    kaiserLine.setAttribute("x1", "50"); kaiserLine.setAttribute("y1", kaiserY);
                    kaiserLine.setAttribute("x2", "450"); kaiserLine.setAttribute("y2", kaiserY);
                    kaiserLine.setAttribute("stroke", "#e74c3c");
                    kaiserLine.setAttribute("stroke-dasharray", "4,4");
                    svg.appendChild(kaiserLine);
                    
                    const kaiserLabel = document.createElementNS(svgNS, "text");
                    kaiserLabel.setAttribute("x", "455"); kaiserLabel.setAttribute("y", kaiserY + 3);
                    kaiserLabel.setAttribute("font-size", "9");
                    kaiserLabel.setAttribute("fill", "#e74c3c");
                    kaiserLabel.textContent = "Kaiser=1";
                    svg.appendChild(kaiserLabel);

                } else {
                    // --- CORRECCIÓN EFA: AJUSTAR COORDENADAS PARA QUE NO SE CORTEN ---
                    const factorGroup = document.createElementNS(svgNS, "g");
                    
                    // Movemos los factores hacia el centro. Antes Factor 2 estaba en x=400, ahora en x=370.
                    const factors = [
                        {name: "Factor 1", x: 130, y: 150, color: "#3498db"}, // Un poco a la derecha
                        {name: "Factor 2", x: 370, y: 150, color: "#e74c3c"}, // Más a la izquierda para dejar margen
                        {name: "Factor 3", x: 250, y: 320, color: "#2ecc71"}  // Más abajo
                    ];
                    
                    // Dibujar Factores (Círculos grandes)
                    factors.forEach((factor) => {
                        const circle = document.createElementNS(svgNS, "circle");
                        circle.setAttribute("cx", factor.x); circle.setAttribute("cy", factor.y);
                        circle.setAttribute("r", "35"); // Un poco más pequeños
                        circle.setAttribute("fill", factor.color);
                        circle.setAttribute("opacity", "0.2");
                        circle.setAttribute("stroke", factor.color);
                        circle.setAttribute("stroke-width", "2");
                        factorGroup.appendChild(circle);
                        
                        const label = document.createElementNS(svgNS, "text");
                        label.setAttribute("x", factor.x); label.setAttribute("y", factor.y + 4);
                        label.setAttribute("text-anchor", "middle");
                        label.setAttribute("font-size", "12");
                        label.setAttribute("fill", factor.color);
                        label.setAttribute("font-weight", "bold");
                        label.textContent = factor.name;
                        factorGroup.appendChild(label);
                    });
                    
                    // Variables (Items)
                    const variables = [
                        {name: "Item1", factor: 0, loading: 0.82},
                        {name: "Item2", factor: 0, loading: 0.76},
                        {name: "Item3", factor: 0, loading: 0.68},
                        {name: "Item4", factor: 1, loading: 0.79},
                        {name: "Item5", factor: 1, loading: 0.71},
                        {name: "Item6", factor: 1, loading: 0.65},
                        {name: "Item7", factor: 2, loading: 0.84},
                        {name: "Item8", factor: 2, loading: 0.73},
                        {name: "Item9", factor: 2, loading: 0.61}
                    ];
                    
                    variables.forEach((var_, i) => {
                        const factor = factors[var_.factor];
                        // Ángulos ajustados para que no apunten tan hacia afuera en los bordes
                        let angle = (i % 3) * 45 - 45; // -45, 0, 45 grados relativos al centro del factor
                        
                        // Truco visual: si es el factor de la derecha (idx 1), invertimos el ángulo o lo restringimos
                        if (var_.factor === 1) {
                            // Apuntar más hacia arriba/abajo/izquierda, evitar derecha extrema
                            if(i%3 === 0) angle = -60;
                            if(i%3 === 1) angle = 0; // Derecha controlada
                            if(i%3 === 2) angle = 60;
                        }
                        
                        const distance = 90; // Distancia del item al centro del factor
                        
                        // Calcular posición
                        const x = factor.x + Math.cos(angle * Math.PI / 180) * distance;
                        const y = factor.y + Math.sin(angle * Math.PI / 180) * distance;
                        
                        // Línea conectora
                        const line = document.createElementNS(svgNS, "line");
                        line.setAttribute("x1", factor.x); line.setAttribute("y1", factor.y);
                        line.setAttribute("x2", x); line.setAttribute("y2", y);
                        line.setAttribute("stroke", factor.color);
                        line.setAttribute("stroke-width", var_.loading * 3);
                        line.setAttribute("opacity", "0.5");
                        factorGroup.appendChild(line);
                        
                        // Caja del Item
                        const rect = document.createElementNS(svgNS, "rect");
                        rect.setAttribute("x", x - 22); rect.setAttribute("y", y - 12);
                        rect.setAttribute("width", "44"); rect.setAttribute("height", "24");
                        rect.setAttribute("fill", "#fff");
                        rect.setAttribute("stroke", "#bdc3c7");
                        rect.setAttribute("rx", "4");
                        factorGroup.appendChild(rect);
                        
                        const itemLabel = document.createElementNS(svgNS, "text");
                        itemLabel.setAttribute("x", x); itemLabel.setAttribute("y", y + 4);
                        itemLabel.setAttribute("text-anchor", "middle");
                        itemLabel.setAttribute("font-size", "9");
                        itemLabel.setAttribute("fill", "#2c3e50");
                        itemLabel.textContent = var_.name;
                        factorGroup.appendChild(itemLabel);
                        
                        // Carga factorial (Loading)
                        const loadX = (factor.x + x) / 2;
                        const loadY = (factor.y + y) / 2;
                        const loadingText = document.createElementNS(svgNS, "text");
                        loadingText.setAttribute("x", loadX); loadingText.setAttribute("y", loadY);
                        loadingText.setAttribute("text-anchor", "middle");
                        loadingText.setAttribute("font-size", "8");
                        loadingText.setAttribute("fill", factor.color);
                        loadingText.setAttribute("font-weight", "bold");
                        loadingText.setAttribute("paint-order", "stroke");
                        loadingText.setAttribute("stroke", "white");
                        loadingText.setAttribute("stroke-width", "2");
                        loadingText.textContent = var_.loading.toFixed(2);
                        factorGroup.appendChild(loadingText);
                    });
                    
                    svg.appendChild(factorGroup);
                    
                    // Correlación entre F1 y F2
                    const corrLine = document.createElementNS(svgNS, "line");
                    corrLine.setAttribute("x1", "165"); corrLine.setAttribute("y1", "150");
                    corrLine.setAttribute("x2", "335"); corrLine.setAttribute("y2", "150");
                    corrLine.setAttribute("stroke", "#f39c12");
                    corrLine.setAttribute("stroke-width", "1.5");
                    corrLine.setAttribute("stroke-dasharray", "4,4");
                    svg.appendChild(corrLine);
                    
                    const corrText = document.createElementNS(svgNS, "text");
                    corrText.setAttribute("x", "250"); corrText.setAttribute("y", "145");
                    corrText.setAttribute("text-anchor", "middle");
                    corrText.setAttribute("font-size", "10");
                    corrText.setAttribute("fill", "#f39c12");
                    corrText.textContent = "r = 0.42";
                    svg.appendChild(corrText);
                }
                
                div.appendChild(svg);
            }
        },
        {
            id: 10,
            title: "10. Imputación y Validación de Modelos",
            icon: "fa-check-double",
            controls: [
                {id: 'topic', type: 'select', label: 'Técnica', 
                 options: ['Imputación Múltiple (MICE)', 'Curva ROC / AUC', 'Validación Cruzada']}
            ],
            code: (p) => {
                switch(p.topic) {
                    case 'Imputación Múltiple (MICE)':
                        return `<span class="c-com"># MICE: Multivariate Imputation by Chained Equations</span>
<span class="c-kwd">library</span>(mice)

<span class="c-com"># Datos con valores faltantes (NA)</span>
<span class="c-var">datos_incompletos</span> <span class="c-op"><-</span> <span class="c-fn">data.frame</span>(
  <span class="c-arg">Edad</span> = <span class="c-fn">c</span>(<span class="c-num">25</span>, <span class="c-num">34</span>, <span class="c-var">NA</span>, <span class="c-num">52</span>, <span class="c-num">47</span>, <span class="c-var">NA</span>),
  <span class="c-arg">IMC</span> = <span class="c-fn">c</span>(<span class="c-num">22</span>, <span class="c-var">NA</span>, <span class="c-num">23</span>, <span class="c-num">31</span>, <span class="c-num">28</span>, <span class="c-num">24</span>),
  <span class="c-arg">Glucosa</span> = <span class="c-fn">c</span>(<span class="c-num">95</span>, <span class="c-num">110</span>, <span class="c-num">88</span>, <span class="c-var">NA</span>, <span class="c-num">130</span>, <span class="c-num">100</span>)
)

<span class="c-com"># Patrón de valores faltantes</span>
<span class="c-fn">md.pattern</span>(<span class="c-var">datos_incompletos</span>)

<span class="c-com"># Imputación múltiple (m=5 conjuntos)</span>
<span class="c-var">imp</span> <span class="c-op"><-</span> <span class="c-fn">mice</span>(<span class="c-var">datos_incompletos</span>, 
                <span class="c-arg">m</span> = <span class="c-num">5</span>, 
                <span class="c-arg">method</span> = <span class="c-str">"pmm"</span>,  <span class="c-com"># Predictive Mean Matching</span>
                <span class="c-arg">maxit</span> = <span class="c-num">10</span>,
                <span class="c-arg">seed</span> = <span class="c-num">123</span>)

<span class="c-com"># Inspeccionar imputaciones</span>
<span class="c-fn">stripplot</span>(<span class="c-var">imp</span>, <span class="c-arg">pch</span> = <span class="c-num">20</span>, <span class="c-arg">cex</span> = <span class="c-num">1.2</span>)

<span class="c-com"># Análisis en cada conjunto y combinar resultados</span>
<span class="c-var">fit</span> <span class="c-op"><-</span> <span class="c-fn">with</span>(<span class="c-var">imp</span>, <span class="c-fn">lm</span>(Glucosa <span class="c-op">~</span> Edad <span class="c-op">+</span> IMC))
<span class="c-var">pooled</span> <span class="c-op"><-</span> <span class="c-fn">pool</span>(<span class="c-var">fit</span>)
<span class="c-fn">summary</span>(<span class="c-var">pooled</span>)`;

                    case 'Curva ROC / AUC':
                        return `<span class="c-com"># Evaluación de modelos de clasificación</span>
<span class="c-kwd">library</span>(pROC)
<span class="c-kwd">library</span>(caret)

<span class="c-com"># Datos: probabilidades predichas vs realidad</span>
<span class="c-var">datos_eval</span> <span class="c-op"><-</span> <span class="c-fn">data.frame</span>(
  <span class="c-arg">Real</span> = <span class="c-fn">factor</span>(<span class="c-fn">c</span>(<span class="c-str">"Enfermo"</span>, <span class="c-str">"Sano"</span>, <span class="c-str">"Enfermo"</span>, <span class="c-str">"Sano"</span>, 
                     <span class="c-str">"Enfermo"</span>, <span class="c-str">"Sano"</span>, <span class="c-str">"Enfermo"</span>, <span class="c-str">"Sano"</span>)),
  <span class="c-arg">Predicho</span> = <span class="c-fn">c</span>(<span class="c-num">0.9</span>, <span class="c-num">0.3</span>, <span class="c-num">0.8</span>, <span class="c-num">0.4</span>, 
                     <span class="c-num">0.7</span>, <span class="c-num">0.2</span>, <span class="c-num">0.6</span>, <span class="c-num">0.1</span>)
)

<span class="c-com"># Curva ROC</span>
<span class="c-var">roc_obj</span> <span class="c-op"><-</span> <span class="c-fn">roc</span>(<span class="c-arg">response</span> = <span class="c-var">datos_eval</span><span class="c-op">$</span>Real,
               <span class="c-arg">predictor</span> = <span class="c-var">datos_eval</span><span class="c-op">$</span>Predicho,
               <span class="c-arg">levels</span> = <span class="c-fn">c</span>(<span class="c-str">"Sano"</span>, <span class="c-str">"Enfermo"</span>))  <span class="c-com"># ¡Orden importante!</span>

<span class="c-fn">plot</span>(<span class="c-var">roc_obj</span>, 
     <span class="c-arg">main</span> = <span class="c-str">"Curva ROC"</span>,
     <span class="c-arg">col</span> = <span class="c-str">"blue"</span>,
     <span class="c-arg">print.auc</span> = <span class="c-kwd">TRUE</span>)

<span class="c-com"># AUC (Area Under Curve)</span>
<span class="c-var">auc_val</span> <span class="c-op"><-</span> <span class="c-fn">auc</span>(<span class="c-var">roc_obj</span>)
<span class="c-fn">cat</span>(<span class="c-str">"AUC:"</span>, <span class="c-var">auc_val</span>, <span class="c-str">"\\n"</span>)

<span class="c-com"># Punto óptimo (Youden)</span>
<span class="c-var">coords_opt</span> <span class="c-op"><-</span> <span class="c-fn">coords</span>(<span class="c-var">roc_obj</span>, <span class="c-arg">"best"</span>, <span class="c-arg">ret</span> = <span class="c-str">"threshold"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Umbral óptimo:"</span>, <span class="c-var">coords_opt</span>, <span class="c-str">"\\n"</span>)`;

                    case 'Validación Cruzada':
                        return `<span class="c-com"># Validación Cruzada para evitar sobreajuste</span>
<span class="c-kwd">library</span>(caret)
<span class="c-kwd">library</span>(rpart)  <span class="c-com"># Para árbol de decisión</span>

<span class="c-com"># Datos de ejemplo</span>
<span class="c-var">datos</span> <span class="c-op"><-</span> <span class="c-fn">data.frame</span>(
  <span class="c-arg">X1</span> = <span class="c-fn">rnorm</span>(<span class="c-num">100</span>),
  <span class="c-arg">X2</span> = <span class="c-fn">rnorm</span>(<span class="c-num">100</span>),
  <span class="c-arg">Y</span> = <span class="c-fn">factor</span>(<span class="c-fn">sample</span>(<span class="c-num">0</span>:<span class="c-num">1</span>, <span class="c-num">100</span>, <span class="c-arg">replace</span>=<span class="c-kwd">TRUE</span>))
)

<span class="c-com"># 1. K-Fold Cross-Validation (K=10)</span>
<span class="c-var">train_control</span> <span class="c-op"><-</span> <span class="c-fn">trainControl</span>(
  <span class="c-arg">method</span> = <span class="c-str">"cv"</span>,
  <span class="c-arg">number</span> = <span class="c-num">10</span>,
  <span class="c-arg">savePredictions</span> = <span class="c-kwd">TRUE</span>
)

<span class="c-var">model_cv</span> <span class="c-op"><-</span> <span class="c-fn">train</span>(Y <span class="c-op">~</span> X1 <span class="c-op">+</span> X2,
                   <span class="c-arg">data</span> = <span class="c-var">datos</span>,
                   <span class="c-arg">trControl</span> = <span class="c-var">train_control</span>,
                   <span class="c-arg">method</span> = <span class="c-str">"rpart"</span>)  <span class="c-com"># Árbol de decisión</span>

<span class="c-fn">print</span>(<span class="c-var">model_cv</span>)

<span class="c-com"># 2. Leave-One-Out Cross-Validation (LOOCV)</span>
<span class="c-var">train_control_loocv</span> <span class="c-op"><-</span> <span class="c-fn">trainControl</span>(
  <span class="c-arg">method</span> = <span class="c-str">"LOOCV"</span>
)

<span class="c-com"># 3. Repeated CV (10-fold, 5 repeticiones)</span>
<span class="c-var">train_control_rep</span> <span class="c-op"><-</span> <span class="c-fn">trainControl</span>(
  <span class="c-arg">method</span> = <span class="c-str">"repeatedcv"</span>,
  <span class="c-arg">number</span> = <span class="c-num">10</span>,
  <span class="c-arg">repeats</span> = <span class="c-num">5</span>
)`;
                }
            },
            explain: (p) => {
                const topics = {
                    'Imputación Múltiple (MICE)': `<h3>Imputación Múltiple con MICE</h3>
                    <p><b>Problema:</b> Valores faltantes (Missing At Random - MAR) en conjuntos de datos.</p>
                    <p><b>Solución MICE:</b> Genera múltiples conjuntos de datos imputados usando ecuaciones encadenadas.</p>
                    
                    <div class="theory-highlight">
                        <b>Ventajas vs Imputación Simple:</b><br>
                        1. Captura incertidumbre de la imputación<br>
                        2. Produce intervalos de confianza válidos<br>
                        3. Más robusto que media/mediana
                    </div>
                    
                    <p><b>Algoritmo MICE:</b></p>
                    <ol>
                        <li>Inicializar valores faltantes con imputación simple</li>
                        <li>Para cada variable con faltantes: regresar sobre otras variables</li>
                        <li>Repetir m veces para crear m conjuntos completos</li>
                        <li>Analizar cada conjunto y combinar resultados (Rubin's Rules)</li>
                    </ol>`,
                    
                    'Curva ROC / AUC': `<h3>Evaluación de Modelos de Clasificación</h3>
                    <p><b>Curva ROC:</b> Gráfico Sensibilidad vs 1-Especificidad para diferentes umbrales.</p>
                    
                    <p><b>Métricas clave:</b></p>
                    <ul>
                        <li><b>Sensibilidad (Recall):</b> TP / (TP + FN) - Detectar verdaderos positivos</li>
                        <li><b>Especificidad:</b> TN / (TN + FP) - Evitar falsos positivos</li>
                        <li><b>AUC:</b> Área bajo la curva ROC (0.5-1)</li>
                    </ul>
                    
                    <div class="theory-highlight">
                        <b>Interpretación AUC:</b><br>
                        • 0.5: No mejor que azar<br>
                        • 0.7-0.8: Aceptable<br>
                        • 0.8-0.9: Bueno<br>
                        • >0.9: Excelente
                    </div>`,
                    
                    'Validación Cruzada': `<h3>Validación Cruzada para Generalización</h3>
                    <p><b>Problema:</b> Sobreajuste (overfitting) - modelo funciona bien en datos de entrenamiento pero mal en nuevos datos.</p>
                    
                    <p><b>Técnicas de Validación Cruzada:</b></p>
                    <ol>
                        <li><b>K-Fold CV:</b> Divide datos en K partes, usa K-1 para entrenar, 1 para validar (repite K veces)</li>
                        <li><b>LOOCV:</b> K = n (deja uno fuera) - costoso computacionalmente</li>
                        <li><b>Repeated CV:</b> K-Fold repetido varias veces para estabilidad</li>
                    </ol>
                    
                    <div class="theory-highlight">
                        <b>Hold-out vs Cross-Validation:</b><br>
                        • Hold-out simple: 70/30 o 80/20 split<br>
                        • CV: Mejor uso de datos, estimación más estable del error
                    </div>`
                };
                return topics[p.topic];
            },
            render: (p, div) => {
                // --- CORRECCIÓN DE LA CAJA CONTENEDORA ---
                // Forzamos a que el contenido se alinee ARRIBA (flex-start) y no al centro.
                div.style.alignItems = "flex-start"; 
                div.style.justifyContent = "center"; // Mantenemos centrado horizontal
                div.style.paddingTop = "20px";       // Un poco de aire arriba
                
                div.innerHTML = '';
                
                // Usamos una altura fija (450) para que el SVG no se estire innecesariamente
                const svg = createSVG("100%", "450", "0 0 500 450");
                
                // Estilo para asegurar comportamiento de bloque
                svg.style.display = "block";
                
                // Fondo
                const bg = document.createElementNS(svgNS, "rect");
                bg.setAttribute("width", "500");
                bg.setAttribute("height", "450");
                bg.setAttribute("fill", "white");
                svg.appendChild(bg);
                
                // Título
                const title = document.createElementNS(svgNS, "text");
                title.setAttribute("x", "250");
                title.setAttribute("y", "30");
                title.setAttribute("text-anchor", "middle");
                title.setAttribute("font-size", "14");
                title.setAttribute("font-weight", "bold");
                title.setAttribute("fill", "#2c3e50");
                title.textContent = `Técnica: ${p.topic}`;
                svg.appendChild(title);
                
                if (p.topic === 'Imputación Múltiple (MICE)') {
                    const dataGroup = document.createElementNS(svgNS, "g");
                    // Posición inicial de la tabla
                    const tableX = 40;
                    const tableY = 60; 
                    
                    const originalData = [
                        {Edad: 25, IMC: 22, Glucosa: 95},
                        {Edad: 34, IMC: null, Glucosa: 110},
                        {Edad: null, IMC: 23, Glucosa: 88},
                        {Edad: 52, IMC: 31, Glucosa: null},
                        {Edad: 47, IMC: 28, Glucosa: 130},
                        {Edad: null, IMC: 24, Glucosa: 100}
                    ];
                    
                    const headers = ['Edad', 'IMC', 'Glucosa'];
                    headers.forEach((h, i) => {
                        const rect = document.createElementNS(svgNS, "rect");
                        rect.setAttribute("x", tableX + i * 80);
                        rect.setAttribute("y", tableY);
                        rect.setAttribute("width", "70");
                        rect.setAttribute("height", "25");
                        rect.setAttribute("fill", "#2c3e50");
                        rect.setAttribute("rx", "4");
                        dataGroup.appendChild(rect);
                        
                        const text = document.createElementNS(svgNS, "text");
                        text.setAttribute("x", tableX + i * 80 + 35);
                        text.setAttribute("y", tableY + 17);
                        text.setAttribute("text-anchor", "middle");
                        text.setAttribute("font-size", "11");
                        text.setAttribute("fill", "white");
                        text.textContent = h;
                        dataGroup.appendChild(text);
                    });
                    
                    originalData.forEach((row, rIdx) => {
                        [row.Edad, row.IMC, row.Glucosa].forEach((val, cIdx) => {
                            const rect = document.createElementNS(svgNS, "rect");
                            rect.setAttribute("x", tableX + cIdx * 80);
                            rect.setAttribute("y", tableY + 28 + rIdx * 28);
                            rect.setAttribute("width", "70");
                            rect.setAttribute("height", "25");
                            rect.setAttribute("fill", val === null ? "#f8d7da" : "#d4edda");
                            rect.setAttribute("stroke", "#bdc3c7");
                            rect.setAttribute("stroke-width", "1");
                            dataGroup.appendChild(rect);
                            
                            const text = document.createElementNS(svgNS, "text");
                            text.setAttribute("x", tableX + cIdx * 80 + 35);
                            text.setAttribute("y", tableY + 28 + rIdx * 28 + 17);
                            text.setAttribute("text-anchor", "middle");
                            text.setAttribute("font-size", "11");
                            text.setAttribute("fill", val === null ? "#721c24" : "#155724");
                            text.setAttribute("font-weight", val === null ? "normal" : "bold");
                            text.textContent = val === null ? "NA" : val.toString();
                            dataGroup.appendChild(text);
                        });
                    });
                    
                    const originalLabel = document.createElementNS(svgNS, "text");
                    originalLabel.setAttribute("x", tableX + 105);
                    originalLabel.setAttribute("y", tableY - 8);
                    originalLabel.setAttribute("text-anchor", "middle");
                    originalLabel.setAttribute("font-size", "11");
                    originalLabel.setAttribute("fill", "#e74c3c");
                    originalLabel.textContent = "Datos Originales";
                    dataGroup.appendChild(originalLabel);
                    
                    svg.appendChild(dataGroup);
                    
                    const arrow = document.createElementNS(svgNS, "path");
                    arrow.setAttribute("d", "M 290 150 L 340 150");
                    arrow.setAttribute("stroke", "#e67e22");
                    arrow.setAttribute("stroke-width", "3");
                    arrow.setAttribute("fill", "none");
                    arrow.setAttribute("marker-end", "url(#arrow2)");
                    svg.appendChild(arrow);
                    
                    const imputedGroup = document.createElementNS(svgNS, "g");
                    imputedGroup.setAttribute("transform", "translate(350, 45)"); 
                    
                    for (let m = 0; m < 3; m++) {
                        const setX = 0;
                        const setY = m * 65;
                        
                        const frame = document.createElementNS(svgNS, "rect");
                        frame.setAttribute("x", setX); frame.setAttribute("y", setY);
                        frame.setAttribute("width", "110"); frame.setAttribute("height", "55");
                        frame.setAttribute("fill", "none");
                        frame.setAttribute("stroke", "#3498db"); frame.setAttribute("stroke-width", "2");
                        frame.setAttribute("rx", "4");
                        imputedGroup.appendChild(frame);
                        
                        const imputedVals = [
                            {x: 15, y: setY + 15, val: m === 0 ? 29 : m === 1 ? 31 : 30},
                            {x: 15, y: setY + 35, val: m === 0 ? 25 : m === 1 ? 24 : 26},
                            {x: 60, y: setY + 25, val: m === 0 ? 120 : m === 1 ? 118 : 122}
                        ];
                        
                        imputedVals.forEach(v => {
                            const circle = document.createElementNS(svgNS, "circle");
                            circle.setAttribute("cx", v.x); circle.setAttribute("cy", v.y);
                            circle.setAttribute("r", "11");
                            circle.setAttribute("fill", "#3498db"); circle.setAttribute("opacity", "0.7");
                            imputedGroup.appendChild(circle);
                            
                            const text = document.createElementNS(svgNS, "text");
                            text.setAttribute("x", v.x); text.setAttribute("y", v.y + 4);
                            text.setAttribute("text-anchor", "middle");
                            text.setAttribute("font-size", "9");
                            text.setAttribute("fill", "white"); text.setAttribute("font-weight", "bold");
                            text.textContent = v.val.toString();
                            imputedGroup.appendChild(text);
                        });
                        
                        const setLabel = document.createElementNS(svgNS, "text");
                        setLabel.setAttribute("x", "55"); setLabel.setAttribute("y", setY + 50);
                        setLabel.setAttribute("text-anchor", "middle");
                        setLabel.setAttribute("font-size", "9");
                        setLabel.setAttribute("fill", "#3498db");
                        setLabel.textContent = `Imputación ${m + 1}`;
                        imputedGroup.appendChild(setLabel);
                    }
                    svg.appendChild(imputedGroup);
                    
                    const poolText = document.createElementNS(svgNS, "text");
                    poolText.setAttribute("x", "250");
                    poolText.setAttribute("y", "340");
                    poolText.setAttribute("text-anchor", "middle");
                    poolText.setAttribute("font-size", "11");
                    poolText.setAttribute("fill", "#27ae60");
                    poolText.innerHTML = `<tspan x="250" dy="0">Pooling: β = 1.8 [IC95%: 1.2-2.4]</tspan>`;
                    svg.appendChild(poolText);
                    
                    const defs = document.createElementNS(svgNS, "defs");
                    defs.innerHTML = `<marker id="arrow2" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#e67e22"/></marker>`;
                    svg.appendChild(defs);
                    
                } else if (p.topic === 'Curva ROC / AUC') {
                    const rocGroup = document.createElementNS(svgNS, "g");
                    
                    const topY = 70;
                    const bottomY = 330; 
                    const leftX = 60;
                    const rightX = 460;
                    
                    const xAxis = document.createElementNS(svgNS, "line");
                    xAxis.setAttribute("x1", leftX); xAxis.setAttribute("y1", bottomY);
                    xAxis.setAttribute("x2", rightX); xAxis.setAttribute("y2", bottomY);
                    xAxis.setAttribute("stroke", "#333"); xAxis.setAttribute("stroke-width", "1.5");
                    rocGroup.appendChild(xAxis);
                    
                    const yAxis = document.createElementNS(svgNS, "line");
                    yAxis.setAttribute("x1", leftX); yAxis.setAttribute("y1", topY);
                    yAxis.setAttribute("x2", leftX); yAxis.setAttribute("y2", bottomY);
                    yAxis.setAttribute("stroke", "#333"); yAxis.setAttribute("stroke-width", "1.5");
                    rocGroup.appendChild(yAxis);
                    
                    const xLabel = document.createElementNS(svgNS, "text");
                    xLabel.setAttribute("x", rightX);
                    xLabel.setAttribute("y", bottomY + 20);
                    xLabel.setAttribute("text-anchor", "end");
                    xLabel.setAttribute("font-size", "11");
                    xLabel.setAttribute("fill", "#2c3e50");
                    xLabel.textContent = "1 - Especificidad";
                    rocGroup.appendChild(xLabel);
                    
                    const yLabel = document.createElementNS(svgNS, "text");
                    yLabel.setAttribute("x", leftX - 15);
                    yLabel.setAttribute("y", (topY + bottomY) / 2);
                    yLabel.setAttribute("text-anchor", "middle");
                    yLabel.setAttribute("font-size", "11");
                    yLabel.setAttribute("fill", "#2c3e50");
                    yLabel.setAttribute("transform", `rotate(-90 ${leftX - 15}, ${(topY + bottomY) / 2})`);
                    yLabel.textContent = "Sensibilidad";
                    rocGroup.appendChild(yLabel);
                    
                    const diagonal = document.createElementNS(svgNS, "line");
                    diagonal.setAttribute("x1", leftX); diagonal.setAttribute("y1", bottomY);
                    diagonal.setAttribute("x2", rightX); diagonal.setAttribute("y2", topY);
                    diagonal.setAttribute("stroke", "#95a5a6");
                    diagonal.setAttribute("stroke-width", "1");
                    diagonal.setAttribute("stroke-dasharray", "5,5");
                    rocGroup.appendChild(diagonal);
                    
                    const curve = document.createElementNS(svgNS, "path");
                    let pathData = `M ${leftX} ${bottomY} `;
                    const width = rightX - leftX;
                    const height = bottomY - topY;
                    
                    const rocPoints = [
                        {fpr: 0.0, tpr: 0.0}, {fpr: 0.1, tpr: 0.3}, {fpr: 0.2, tpr: 0.5},
                        {fpr: 0.3, tpr: 0.65}, {fpr: 0.4, tpr: 0.75}, {fpr: 0.5, tpr: 0.82},
                        {fpr: 0.6, tpr: 0.88}, {fpr: 0.7, tpr: 0.92}, {fpr: 0.8, tpr: 0.96},
                        {fpr: 0.9, tpr: 0.98}, {fpr: 1.0, tpr: 1.0}
                    ];
                    
                    rocPoints.forEach(point => {
                        const x = leftX + point.fpr * width;
                        const y = bottomY - point.tpr * height;
                        pathData += `L ${x} ${y} `;
                    });
                    
                    curve.setAttribute("d", pathData);
                    curve.setAttribute("fill", "none");
                    curve.setAttribute("stroke", "#3498db"); curve.setAttribute("stroke-width", "3");
                    rocGroup.appendChild(curve);
                    
                    const areaPath = pathData + `L ${rightX} ${bottomY} L ${leftX} ${bottomY} Z`;
                    const area = document.createElementNS(svgNS, "path");
                    area.setAttribute("d", areaPath);
                    area.setAttribute("fill", "#3498db"); area.setAttribute("opacity", "0.2");
                    rocGroup.appendChild(area);
                    
                    const optimalPoint = {fpr: 0.25, tpr: 0.78};
                    const optimalX = leftX + optimalPoint.fpr * width;
                    const optimalY = bottomY - optimalPoint.tpr * height;
                    
                    const optimalCircle = document.createElementNS(svgNS, "circle");
                    optimalCircle.setAttribute("cx", optimalX); optimalCircle.setAttribute("cy", optimalY);
                    optimalCircle.setAttribute("r", "8"); optimalCircle.setAttribute("fill", "#e74c3c");
                    rocGroup.appendChild(optimalCircle);
                    
                    const optimalText = document.createElementNS(svgNS, "text");
                    optimalText.setAttribute("x", optimalX + 15); optimalText.setAttribute("y", optimalY - 10);
                    optimalText.setAttribute("font-size", "10"); optimalText.setAttribute("fill", "#e74c3c");
                    optimalText.setAttribute("font-weight", "bold"); optimalText.textContent = "Óptimo";
                    rocGroup.appendChild(optimalText);
                    
                    const aucText = document.createElementNS(svgNS, "text");
                    aucText.setAttribute("x", rightX - 40); aucText.setAttribute("y", bottomY - 60);
                    aucText.setAttribute("text-anchor", "end");
                    aucText.setAttribute("font-size", "14"); aucText.setAttribute("fill", "#27ae60");
                    aucText.setAttribute("font-weight", "bold"); aucText.textContent = "AUC = 0.87";
                    rocGroup.appendChild(aucText);
                    
                    svg.appendChild(rocGroup);
                    
                    const legend = document.createElementNS(svgNS, "text");
                    legend.setAttribute("x", "250"); legend.setAttribute("y", "375");
                    legend.setAttribute("text-anchor", "middle"); legend.setAttribute("font-size", "11");
                    legend.setAttribute("fill", "#2c3e50");
                    legend.textContent = "Modelo con excelente capacidad discriminativa";
                    svg.appendChild(legend);
                    
                } else if (p.topic === 'Validación Cruzada') {
                    const cvGroup = document.createElementNS(svgNS, "g");
                    const nFolds = 5;
                    const foldHeight = 45; 
                    const startY = 60; 
                    
                    for (let fold = 0; fold < nFolds; fold++) {
                        const y = startY + fold * (foldHeight + 8);
                        
                        const rect = document.createElementNS(svgNS, "rect");
                        rect.setAttribute("x", "50"); rect.setAttribute("y", y);
                        rect.setAttribute("width", "400"); rect.setAttribute("height", foldHeight);
                        rect.setAttribute("fill", "#f8f9fa"); rect.setAttribute("stroke", "#bdc3c7");
                        rect.setAttribute("stroke-width", "1"); rect.setAttribute("rx", "4");
                        cvGroup.appendChild(rect);
                        
                        const foldLabel = document.createElementNS(svgNS, "text");
                        foldLabel.setAttribute("x", "70"); foldLabel.setAttribute("y", y + 25);
                        foldLabel.setAttribute("font-size", "11"); foldLabel.setAttribute("fill", "#2c3e50");
                        foldLabel.setAttribute("font-weight", "bold"); foldLabel.textContent = `Fold ${fold + 1}:`;
                        cvGroup.appendChild(foldLabel);
                        
                        for (let i = 0; i < nFolds; i++) {
                            if (i !== fold) {
                                const trainRect = document.createElementNS(svgNS, "rect");
                                trainRect.setAttribute("x", 120 + i * 60); trainRect.setAttribute("y", y + 8);
                                trainRect.setAttribute("width", "50"); trainRect.setAttribute("height", "28");
                                trainRect.setAttribute("fill", "#3498db"); trainRect.setAttribute("opacity", "0.7");
                                trainRect.setAttribute("rx", "3");
                                cvGroup.appendChild(trainRect);
                                
                                const trainText = document.createElementNS(svgNS, "text");
                                trainText.setAttribute("x", 120 + i * 60 + 25); trainText.setAttribute("y", y + 25);
                                trainText.setAttribute("text-anchor", "middle"); trainText.setAttribute("font-size", "10");
                                trainText.setAttribute("fill", "white"); trainText.setAttribute("font-weight", "bold");
                                trainText.textContent = `D${i + 1}`;
                                cvGroup.appendChild(trainText);
                            }
                        }
                        
                        const valRect = document.createElementNS(svgNS, "rect");
                        valRect.setAttribute("x", 120 + fold * 60); valRect.setAttribute("y", y + 8);
                        valRect.setAttribute("width", "50"); valRect.setAttribute("height", "28");
                        valRect.setAttribute("fill", "#e74c3c"); valRect.setAttribute("opacity", "0.9");
                        valRect.setAttribute("rx", "3");
                        cvGroup.appendChild(valRect);
                        
                        const valText = document.createElementNS(svgNS, "text");
                        valText.setAttribute("x", 120 + fold * 60 + 25); valText.setAttribute("y", y + 25);
                        valText.setAttribute("text-anchor", "middle"); valText.setAttribute("font-size", "10");
                        valText.setAttribute("fill", "white"); valText.setAttribute("font-weight", "bold");
                        valText.textContent = `D${fold + 1}`;
                        cvGroup.appendChild(valText);
                        
                        const arrow = document.createElementNS(svgNS, "path");
                        arrow.setAttribute("d", `M 380 ${y + 22} L 415 ${y + 22}`);
                        arrow.setAttribute("stroke", "#27ae60"); arrow.setAttribute("stroke-width", "2");
                        arrow.setAttribute("fill", "none"); arrow.setAttribute("marker-end", "url(#arrow3)");
                        cvGroup.appendChild(arrow);
                        
                        const resultText = document.createElementNS(svgNS, "text");
                        resultText.setAttribute("x", "465"); resultText.setAttribute("y", y + 25);
                        resultText.setAttribute("font-size", "10"); resultText.setAttribute("fill", "#27ae60");
                        resultText.textContent = `Err: ${(0.15 + Math.random() * 0.1).toFixed(2)}`;
                        cvGroup.appendChild(resultText);
                    }
                    svg.appendChild(cvGroup);
                    
                    const avgError = document.createElementNS(svgNS, "text");
                    avgError.setAttribute("x", "250"); avgError.setAttribute("y", "360");
                    avgError.setAttribute("text-anchor", "middle"); avgError.setAttribute("font-size", "12");
                    avgError.setAttribute("fill", "#e74c3c"); avgError.setAttribute("font-weight", "bold");
                    avgError.textContent = "Error CV Promedio = 0.21 ± 0.04";
                    svg.appendChild(avgError);
                    
                    const legendGroup = document.createElementNS(svgNS, "g");
                    legendGroup.setAttribute("transform", "translate(50, 380)");
                    
                    const trainLegend = document.createElementNS(svgNS, "rect");
                    trainLegend.setAttribute("x", "0"); trainLegend.setAttribute("y", "-15");
                    trainLegend.setAttribute("width", "15"); trainLegend.setAttribute("height", "15");
                    trainLegend.setAttribute("fill", "#3498db"); legendGroup.appendChild(trainLegend);
                    
                    const trainText = document.createElementNS(svgNS, "text");
                    trainText.setAttribute("x", "25"); trainText.setAttribute("y", "-3");
                    trainText.setAttribute("font-size", "10"); trainText.setAttribute("fill", "#2c3e50");
                    trainText.textContent = "Entrenamiento (K-1)"; legendGroup.appendChild(trainText);
                    
                    const valLegend = document.createElementNS(svgNS, "rect");
                    valLegend.setAttribute("x", "180"); valLegend.setAttribute("y", "-15");
                    valLegend.setAttribute("width", "15"); valLegend.setAttribute("height", "15");
                    valLegend.setAttribute("fill", "#e74c3c"); legendGroup.appendChild(valLegend);
                    
                    const valText = document.createElementNS(svgNS, "text");
                    valText.setAttribute("x", "205"); valText.setAttribute("y", "-3");
                    valText.setAttribute("font-size", "10"); valText.setAttribute("fill", "#2c3e50");
                    valText.textContent = "Validación (1)"; legendGroup.appendChild(valText);
                    
                    svg.appendChild(legendGroup);
                    
                    const defs = document.createElementNS(svgNS, "defs");
                    defs.innerHTML = `<marker id="arrow3" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#27ae60"/></marker>`;
                    svg.appendChild(defs);
                }
                
                div.appendChild(svg);
            }
        }
    ];

    // =================================================================
    // SISTEMA DE NAVEGACIÓN Y CONTROL
    // =================================================================

    function initApp() {
        renderMenu();
        loadLesson(1);
        
        // Inicializar MathJax
        if (window.MathJax) {
            MathJax.typesetPromise();
        }
    }

    function renderMenu() {
        const menu = document.getElementById('menuArea');
        menu.innerHTML = '';
        
        lessons.forEach(lesson => {
            const item = document.createElement('div');
            item.className = `menu-item ${lesson.id === currentLessonId ? 'active' : ''}`;
            item.innerHTML = `
                <i class="fas ${lesson.icon} menu-icon"></i>
                <span>${lesson.title}</span>
            `;
            item.onclick = () => loadLesson(lesson.id);
            menu.appendChild(item);
        });
    }

    function loadLesson(id) {
        currentLessonId = id;
        const lesson = lessons.find(l => l.id === id);
        
        // Inicializar estado si no existe
        if (!appState[id]) {
            appState[id] = {};
            lesson.controls.forEach(control => {
                appState[id][control.id] = control.val !== undefined ? control.val : control.options[0];
            });
        }
        
        renderMenu();
        renderControls(lesson);
        updateUI(lesson);
    }

    function renderControls(lesson) {
        const bar = document.getElementById('controlsArea');
        bar.innerHTML = '';
        
        lesson.controls.forEach(control => {
            const container = document.createElement('div');
            container.className = 'control-group';
            
            const label = document.createElement('label');
            label.textContent = control.label;
            label.htmlFor = `control-${lesson.id}-${control.id}`;
            
            let input;
            if (control.type === 'select') {
                input = document.createElement('select');
                input.id = `control-${lesson.id}-${control.id}`;
                
                control.options.forEach(option => {
                    const opt = document.createElement('option');
                    opt.value = option;
                    opt.textContent = option;
                    input.appendChild(opt);
                });
                
                input.value = appState[lesson.id][control.id];
            } else if (control.type === 'range') {
                input = document.createElement('input');
                input.type = 'range';
                input.id = `control-${lesson.id}-${control.id}`;
                input.min = control.min;
                input.max = control.max;
                input.step = control.step || 1;
                input.value = appState[lesson.id][control.id];
                
                // Valor actual
                const valueDisplay = document.createElement('span');
                valueDisplay.style.cssText = `
                    min-width: 30px;
                    text-align: center;
                    font-family: 'Fira Code', monospace;
                    font-size: 0.9rem;
                    color: #2c3e50;
                `;
                valueDisplay.textContent = input.value;
                
                input.addEventListener('input', (e) => {
                    appState[lesson.id][control.id] = e.target.value;
                    valueDisplay.textContent = e.target.value;
                    updateUI(lesson);
                });
                
                container.appendChild(valueDisplay);
            }
            
            input.addEventListener('change', (e) => {
                appState[lesson.id][control.id] = e.target.value;
                updateUI(lesson);
            });
            
            container.appendChild(label);
            container.appendChild(input);
            bar.appendChild(container);
        });
    }

    function updateUI(lesson) {
        const params = appState[lesson.id];
        
        // Actualizar código
        const codeArea = document.getElementById('codeArea');
        codeArea.innerHTML = lesson.code(params);
        
        // Actualizar teoría
        const theoryArea = document.getElementById('theoryArea');
        theoryArea.innerHTML = lesson.explain(params);
        
        // Actualizar visualización
        const vizArea = document.getElementById('vizArea');
        vizArea.innerHTML = '';
        
        try {
            lesson.render(params, vizArea);
        } catch (error) {
            console.error('Error rendering visualization:', error);
            vizArea.innerHTML = `
                <div style="color: #e74c3c; text-align: center; padding: 20px;">
                    <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 10px;"></i>
                    <h3>Error en la visualización</h3>
                    <p>${error.message}</p>
                </div>
            `;
        }
        
        // Actualizar MathJax
        if (window.MathJax) {
            MathJax.typesetPromise();
        }
    }

    // Inicializar cuando el DOM esté listo
    document.addEventListener('DOMContentLoaded', initApp);

</script>
</body>
</html>