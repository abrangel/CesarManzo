<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secuenciación y Ómicas de Próxima Generación</title>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        /* --- CONFIGURACIÓN BASE --- */
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #252526;
            --text-main: #d4d4d4;
            --accent: #007acc;
            --keyword: #c586c0;
            --function: #dcdcaa;
            --string: #ce9178;
            --comment: #6a9955;
            --sidebar-w: 300px;
            --success: #4CAF50;
            --warning: #FF9800;
            --danger: #f44336;
            --info: #2196F3;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body { 
            background: var(--bg-dark); 
            font-family: 'Roboto', sans-serif; 
            color: var(--text-main); 
            height: 100vh; 
            display: flex; 
            overflow: hidden; 
        }

        /* --- SIDEBAR --- */
        .sidebar { 
            width: var(--sidebar-w); 
            background: #2d2d2d; 
            display: flex; 
            flex-direction: column; 
            border-right: 1px solid #000;
            min-width: 250px;
        }
        
        .header { 
            padding: 20px 15px; 
            background: linear-gradient(135deg, #007acc 0%, #005a9e 100%); 
            color: white; 
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .header h2 { 
            margin: 0 0 5px 0; 
            font-size: 1.1rem; 
            font-weight: 700; 
        }
        
        .header span { 
            font-size: 0.8rem; 
            opacity: 0.9; 
            display: block;
        }
        
        .menu { 
            flex: 1; 
            overflow-y: auto; 
            padding: 10px 0;
        }
        
        .menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 15px;
            color: #ccc;
            cursor: pointer;
            border-left: 4px solid transparent;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            transition: all 0.3s ease;
            text-decoration: none;
            position: relative;
            overflow: hidden;
        }
        
        .menu-item:hover { 
            background: rgba(255,255,255,0.05); 
            color: white; 
            padding-left: 18px;
        }
        
        .menu-item.active { 
            background: rgba(0, 122, 204, 0.15); 
            border-left-color: #007acc; 
            color: white; 
            font-weight: 600;
        }
        
        .menu-item.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 3px;
            background: #007acc;
            box-shadow: 0 0 10px #007acc;
        }
        
        .menu-icon {
            font-size: 1rem;
            width: 24px;
            text-align: center;
            color: #007acc;
        }
        
        .menu-item.active .menu-icon {
            color: white;
        }
        
        .menu-text h4 {
            margin: 0 0 4px 0;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .menu-text p {
            margin: 0;
            font-size: 0.75rem;
            color: #aaa;
            line-height: 1.3;
        }

        /* --- ÁREA PRINCIPAL --- */
        .main { 
            flex: 1;
            display: flex; 
            flex-direction: row;
            height: 100%; 
            overflow: hidden;
        }

        .left-column {
            flex: 4;
            display: flex;
            flex-direction: column;
            border-right: 1px solid rgba(255,255,255,0.1);
            min-width: 350px;
        }
        
        .top-split { 
            flex: 4;
            display: flex; 
            border-bottom: 1px solid rgba(255,255,255,0.1); 
            overflow: hidden; 
            min-height: 0;
        }
        
        .code-panel { 
            flex: 3;
            display: flex; 
            flex-direction: column; 
            background: #1e1e1e; 
            border-bottom: 1px solid rgba(255,255,255,0.1);
            overflow: hidden;
        }
        
        .panel-title { 
            background: #2d2d2d; 
            padding: 10px 15px; 
            font-size: 0.8rem; 
            text-transform: uppercase; 
            font-weight: 600; 
            color: #bbb; 
            display: flex; 
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .panel-title span:last-child {
            color: var(--success);
            font-weight: 500;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        
        .editor { 
            flex: 1; 
            padding: 20px; 
            font-family: 'Fira Code', monospace; 
            font-size: 0.9rem; 
            overflow: auto; 
            line-height: 1.6; 
            white-space: pre-wrap;
            background: #1e1e1e;
        }
        
        .c-kwd { color: var(--keyword); font-weight: 500; } 
        .c-fn { color: var(--function); } 
        .c-str { color: var(--string); } 
        .c-com { color: var(--comment); font-style: italic; opacity: 0.9; }
        .c-arg { color: #9cdcfe; } 
        .c-num { color: #b5cea8; }
        .c-var { color: #569cd6; }
        .c-op { color: #d4d4d4; }

        .viz-panel { 
            grid-row: 1 / span 2; 
            grid-column: 2; 
            display: flex; 
            flex-direction: column; 
            background: #fff; 
            color: #333; 
            position: relative; 
            overflow: hidden; /* Evita que crezca más de la cuenta */
        }
        
                
     .controls {
    background: #e6e6e6;          /* Gris sólido, típico de interfaces de escritorio */
    padding: 6px 12px;            /* Más compacto, no tan aireado como una web */
    border-bottom: 1px solid #bfbfbf; /* Borde gris medio para definición */
    display: flex;
    gap: 15px;                    /* Separación limpia entre controles */
    flex-wrap: wrap;
    align-items: center;
    min-height: 38px;             /* Altura de barra de herramientas estándar */
    font-family: 'Segoe UI', sans-serif;
    font-size: 0.75rem;           /* Texto pequeño y técnico */
    color: #333;
    box-shadow: none;             /* Sin sombras para que parezca software nativo */
}

/* --- ESTILOS PARA LOS CONTROLES DENTRO DE LA BARRA --- */

/* Grupos de etiqueta + input */
.control-group {
    display: flex;
    align-items: center;
    gap: 6px;
    border-right: 1px solid #dcdcdc; /* Pequeño separador visual entre grupos */
    padding-right: 15px;
}
.control-group:last-child {
    border-right: none;
}

/* Etiquetas (Labels) */
.control-label {
    font-weight: 700;
    text-transform: uppercase;
    color: #555;
    font-size: 0.65rem;
    letter-spacing: 0.5px;
}

/* Inputs y Selects */
.controls select, 
.controls input[type="range"], 
.controls input[type="text"] {
    background: #fff;
    border: 1px solid #aaa;
    border-radius: 3px;       /* Bordes ligeramente redondeados */
    padding: 2px 5px;
    font-size: 0.75rem;
    color: #333;
    cursor: pointer;
    height: 24px;             /* Altura fija para alineación perfecta */
}

.controls select:hover,
.controls input:hover {
    border-color: #666;       /* Feedback visual al pasar el mouse */
}

/* Checkbox ajuste */
.controls input[type="checkbox"] {
    cursor: pointer;
    margin: 0;
    width: 14px;
    height: 14px;
}
        
        .canvas-container { 
    flex: 1; 
    background: #fff; 
    position: relative; 
    overflow: hidden; 
    display: flex; 
    justify-content: center; 
    align-items: center; 
    padding: 20px; 
}
        .canvas-container svg {
    width: 100%;       /* Intenta ocupar todo el ancho */
    height: 100%;      /* Intenta ocupar todo el alto */
    max-width: 100%;   /* Límite: no pasar del ancho del padre */
    max-height: 100%;  /* Límite: no pasar del alto del padre */
    /* Esto asegura que se vea todo sin deformarse (mantiene proporción) */
    object-fit: contain; 
}
        .explanation-panel { 
            flex: 2;
            background: #252526; 
            padding: 15px; 
            overflow-y: auto; 
            font-family: 'Segoe UI', sans-serif; 
            border-top: 2px solid #007acc;
        }
        
        .exp-title { 
            color: #007acc; 
            font-weight: 600; 
            font-size: 1.2rem; 
            margin-bottom: 15px; 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .exp-text { 
            line-height: 1.7; 
            color: #e9ecef; 
            font-size: 0.95rem; 
        }
        
        .exp-text b {
            color: #007acc;
            font-weight: 600;
        }
        
        .exp-highlight { 
            background: rgba(0, 122, 204, 0.15); 
            padding: 8px 12px; 
            border-radius: 6px; 
            color: #e9ecef; 
            border-left: 3px solid #007acc;
            margin: 10px 0;
        }
        
        .exp-note {
            background: rgba(255, 152, 0, 0.1);
            padding: 8px 12px;
            border-radius: 6px;
            color: #ffcc80;
            border-left: 3px solid #FF9800;
            margin: 10px 0;
            font-size: 0.9rem;
        }

        select, input[type="range"] { 
            padding: 6px 10px; 
            border: 1px solid #ced4da; 
            border-radius: 4px; 
            font-size: 0.8rem; 
            background: white;
            transition: all 0.2s;
        }
        
        select:focus, input[type="range"]:focus {
            outline: none;
            border-color: #007acc;
            box-shadow: 0 0 0 3px rgba(0,122,204,0.1);
        }
        
        .timeline {
            width: 90%;
            height: 120px;
            position: relative;
            background: white;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .timeline-item {
            position: absolute;
            width: 80px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .timeline-item.active {
            transform: scale(1.1);
            z-index: 10;
        }
        
        .timeline-circle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin: 0 auto 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.8rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        
        .tech-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin: 10px;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
            border-left: 4px solid #007acc;
            transition: all 0.3s;
            animation: fadeIn 0.5s ease-out;
        }
        
        .tech-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .fastq-read {
            font-family: 'Fira Code', monospace;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
            margin: 5px 0;
            animation: slideIn 0.5s ease-out;
        }
        
        .quality-bar {
            height: 20px;
            background: linear-gradient(90deg, #4CAF50, #FF9800, #f44336);
            border-radius: 4px;
            margin: 5px 0;
            position: relative;
            overflow: hidden;
        }
        
        .quality-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FF9800);
            width: 0%;
            transition: width 1s ease-out;
            border-radius: 4px;
        }
        
        .genome-viewer {
            width: 90%;
            height: 200px;
            background: white;
            border-radius: 10px;
            padding: 15px;
            position: relative;
            animation: fadeIn 0.5s ease-out;
        }
        
        .gene {
            position: absolute;
            height: 40px;
            background: #007acc;
            border-radius: 4px;
            opacity: 0.8;
            transition: all 0.3s;
            animation: geneAppear 0.5s ease-out forwards;
            cursor: pointer;
        }
        
        .gene:hover {
            opacity: 1;
            transform: scaleY(1.2);
        }
        
        .taxonomy-tree {
            width: 90%;
            height: 300px;
            position: relative;
        }
        
        .taxonomy-node {
            position: absolute;
            background: white;
            border: 2px solid;
            border-radius: 8px;
            padding: 8px 12px;
            text-align: center;
            font-size: 0.8rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            animation: nodeAppear 0.5s ease-out forwards;
            cursor: pointer;
        }
        
        .mass-spectrum {
            width: 90%;
            height: 200px;
            background: white;
            border-radius: 10px;
            padding: 15px;
            position: relative;
            animation: fadeIn 0.5s ease-out;
        }
        
        .peak {
            position: absolute;
            bottom: 0;
            width: 3px;
            background: #007acc;
            animation: peakGrow 1s ease-out forwards;
            transform-origin: bottom;
        }
        
        .omics-network {
            width: 90%;
            height: 300px;
            position: relative;
        }
        
        .omics-node {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.9rem;
            text-align: center;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
            transition: all 0.3s;
            animation: nodePulse 2s infinite alternate;
            cursor: pointer;
        }
        
        .omics-node:hover {
            transform: scale(1.1);
            z-index: 10;
            animation: none;
        }
        
        .omics-connection {
            position: absolute;
            background: #666;
            transform-origin: top left;
            animation: lineDraw 1s ease-out forwards;
        }
        
        .sequencing-read {
            font-family: 'Fira Code', monospace;
            font-size: 0.8rem;
            letter-spacing: 1px;
            background: #f0f0f0;
            padding: 5px;
            border-radius: 3px;
            margin: 2px 0;
            animation: typewriter 2s steps(40) forwards;
            overflow: hidden;
            white-space: nowrap;
        }
        
        .sequencing-platform {
            width: 150px;
            height: 80px;
            background: white;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.3s;
            animation: platformAppear 0.5s ease-out forwards;
        }
        
        .sequencing-platform:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .fastqc-plot {
            width: 100%;
            height: 150px;
            position: relative;
            background: white;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
        }
        
        .q-score-indicator {
            width: 20px;
            height: 100px;
            background: linear-gradient(to top, #4CAF50, #FF9800, #f44336);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        
        .q-score-marker {
            position: absolute;
            width: 100%;
            height: 2px;
            background: #333;
            transition: all 0.3s;
        }
        
        .blast-result {
            background: white;
            border-radius: 8px;
            padding: 10px;
            margin: 5px 0;
            border-left: 4px solid #4CAF50;
            animation: slideInRight 0.5s ease-out forwards;
            transform: translateX(-20px);
            opacity: 0;
        }
        
        .differential-expression {
            width: 100%;
            height: 200px;
            position: relative;
            background: white;
            border-radius: 8px;
            padding: 15px;
        }
        
        .expression-point {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .expression-point:hover {
            transform: scale(2);
        }
        
        .metagenomic-sample {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            position: relative;
            overflow: hidden;
            animation: samplePulse 3s infinite alternate;
        }
        
        .metagenomic-sample::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: conic-gradient(
                #f44336 0% 15%,
                #FF9800 15% 30%,
                #4CAF50 30% 50%,
                #2196F3 50% 70%,
                #9C27B0 70% 85%,
                #00BCD4 85% 100%
            );
            animation: rotate 20s linear infinite;
        }
        
        .protein-structure {
            width: 150px;
            height: 150px;
            position: relative;
            transform-style: preserve-3d;
            animation: proteinRotate 10s linear infinite;
        }
        
        .protein-sphere {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #f44336);
            box-shadow: inset -2px -2px 5px rgba(0,0,0,0.5);
        }
        
        .metabolite-pathway {
            width: 200px;
            height: 200px;
            position: relative;
            border-radius: 50%;
            background: white;
            overflow: hidden;
        }
        
        .pathway-step {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #4CAF50;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
            animation: pathwayFlow 3s linear infinite;
        }
        
        .scrnaseq-cell {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            position: absolute;
            animation: cellMove 5s infinite alternate;
        }
        
        .epigenetic-mod {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            animation: modBounce 2s infinite alternate;
        }
        
        .ai-neuron {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2196F3;
            position: absolute;
            animation: neuronPulse 2s infinite;
        }
        
        .ai-connection {
            position: absolute;
            background: #2196F3;
            opacity: 0.3;
            transform-origin: top left;
            animation: aiFlow 3s infinite;
        }
        
        .multimodal-integration {
            width: 100%;
            height: 300px;
            position: relative;
            background: white;
            border-radius: 10px;
            padding: 15px;
        }
        
        .modal-node {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            animation: modalConnect 4s infinite;
        }
        
        /* Tooltip */
        .tooltip { 
            position: absolute; 
            background: rgba(0,0,0,0.9); 
            color: white; 
            padding: 8px 12px; 
            border-radius: 6px; 
            font-size: 0.8rem; 
            pointer-events: none; 
            opacity: 0; 
            z-index: 1000; 
            transition: opacity 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            max-width: 200px;
            white-space: normal;
        }
        
        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(0,0,0,0.9) transparent transparent transparent;
        }
        
        /* Animaciones */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        @keyframes slideInRight {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        @keyframes geneAppear {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 0.8; transform: scale(1); }
        }
        
        @keyframes nodeAppear {
            from { opacity: 0; transform: scale(0); }
            to { opacity: 1; transform: scale(1); }
        }
        
        @keyframes peakGrow {
            from { height: 0; }
            to { height: var(--peak-height); }
        }
        
        @keyframes nodePulse {
            from { box-shadow: 0 0 0 0 rgba(0, 122, 204, 0.7); }
            to { box-shadow: 0 0 0 10px rgba(0, 122, 204, 0); }
        }
        
        @keyframes lineDraw {
            from { width: 0; }
            to { width: var(--line-length); }
        }
        
        @keyframes typewriter {
            from { width: 0; }
            to { width: 100%; }
        }
        
        @keyframes platformAppear {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes samplePulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }
        
        @keyframes proteinRotate {
            from { transform: rotateX(0) rotateY(0); }
            to { transform: rotateX(360deg) rotateY(360deg); }
        }
        
        @keyframes pathwayFlow {
            0% { transform: rotate(0deg) translateX(70px) rotate(0deg); }
            100% { transform: rotate(360deg) translateX(70px) rotate(-360deg); }
        }
        
        @keyframes cellMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(var(--x), var(--y)); }
        }
        
        @keyframes modBounce {
            from { transform: translateY(0); }
            to { transform: translateY(-10px); }
        }
        
        @keyframes neuronPulse {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.7; }
        }
        
        @keyframes aiFlow {
            0% { opacity: 0.1; }
            50% { opacity: 0.5; }
            100% { opacity: 0.1; }
        }
        
        @keyframes modalConnect {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .continue-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            z-index: 100;
        }
        
        .continue-btn:hover {
            background: #005a9e;
            transform: translateY(-2px);
        }
        
        .continue-btn:active {
            transform: translateY(0);
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #2d2d2d;
            position: relative;
            margin: 10px 0;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: #007acc;
            width: 0%;
            transition: width 0.5s ease-out;
            border-radius: 2px;
        }
        
        /* Scrollbar personalizado */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #2d2d2d;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #666;
        }

        /* Ajustes responsive */
        @media (max-width: 1000px) {
            .main { flex-direction: column; }
            .left-column { width: 100%; height: 50%; border-right: none; }
            .viz-panel { width: 100%; height: 50%; }
        }
            
            .top-split {
                flex-direction: column;
            }
            
            .code-panel, .viz-panel {
                min-height: 300px;
            }
            
            .code-panel {
                border-right: none;
                border-bottom: 1px solid rgba(255,255,255,0.1);
            }
        }

        /* Botón de volver */
        .sidebar-footer {
            margin-top: auto;
            padding: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .back-button-elegant {
            width: 100%;
            padding: 12px;
            background: rgba(0, 122, 204, 0.2);
            border: 1px solid #007acc;
            color: #007acc;
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
            font-size: 0.9rem;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s ease;
        }
        .back-button-elegant:hover {
            background: #007acc;
            color: white;
            box-shadow: 0 0 15px rgba(0, 122, 204, 0.5);
        }

    </style>
</head>
<body>

    <div class="sidebar">
        <div class="header">
            <h2>Secuenciación y Ómicas de Próxima Generación</h2>
            <span>MÁSTER BIOINFORMÁTICA</span>
        </div>
        <div class="menu" id="menuList"></div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="sidebar-footer">
            <button onclick="window.close()" class="back-button-elegant">
                <i class="fas fa-arrow-left"></i> VOLVER
            </button>
        </div>
    </div>

    <div class="main">
        
        <div class="left-column">
            
            <div class="code-panel">
                <div class="panel-title">
                    <span><i class="fas fa-file-code"></i> Script R / Python</span>
                    <span><i class="fas fa-circle"></i> LIVE</span>
                </div>
                <div class="editor" id="codeEditor"></div>
            </div>

            <div class="explanation-panel">
                <div class="exp-title"><i class="fas fa-chalkboard-teacher"></i> Explicación del Profesor</div>
                <div class="exp-text" id="explanationText"></div>
            </div>

        </div>

        <div class="viz-panel">
            <div class="controls" id="controlsArea"></div>
            <div class="canvas" id="canvasArea">
                <div id="plotContent" style="width:100%; height:100%; position:relative; display:flex; justify-content:center; align-items:center;"></div>
                <div class="tooltip" id="tooltip"></div>
                <button class="continue-btn" id="continueBtn" style="display: none;">
                    <i class="fas fa-arrow-right"></i> Continuar al siguiente paso
                </button>
            </div>
        </div>

    </div>

    <script>
        // --- BASE DE DATOS DE LOS 10 TEMAS COMPLETOS ---
        const lessons = [
            {
                id: 1,
                title: "Tema 1. Tecnologías de Secuenciación",
                desc: "Evolución histórica de Sanger a NGS y TGS",
                icon: "fa-dna",
                controls: [
                    {id: 'tech', type: 'select', label: 'Tecnología', options: ['Sanger (1ª Gen)', 'Illumina (NGS)', 'Nanopore (TGS)']}
                ],
                // CÓDIGO R EXTENDIDO Y DETALLADO
                code: (p) => {
                    if (p.tech.includes('Sanger')) {
                        return `
<span class="c-com"># ANÁLISIS SANGER (1ª GENERACIÓN)</span>
<span class="c-com"># El "Gold Standard" para fragmentos cortos y validación</span>

<span class="c-kwd">library</span>(sangerseqR)
<span class="c-kwd">library</span>(Biostrings)

<span class="c-com"># 1. Leer archivo de cromatograma (.ab1 o .scf)</span>
<span class="c-var">ab1_file</span> <span class="c-op"><-</span> <span class="c-str">"data/secuencia_paciente.ab1"</span>
<span class="c-var">sanger_obj</span> <span class="c-op"><-</span> <span class="c-fn">readsangerseq</span>(<span class="c-var">ab1_file</span>)

<span class="c-com"># 2. Extraer secuencia primaria y secundaria (base calling)</span>
<span class="c-var">primary_seq</span> <span class="c-op"><-</span> <span class="c-fn">primarySeq</span>(<span class="c-var">sanger_obj</span>)
<span class="c-var">secondary_seq</span> <span class="c-op"><-</span> <span class="c-fn">secondarySeq</span>(<span class="c-var">sanger_obj</span>)

<span class="c-com"># 3. Visualizar el cromatograma (Trace)</span>
<span class="c-fn">chromatogram</span>(<span class="c-var">sanger_obj</span>, 
             <span class="c-arg">width</span> = <span class="c-num">80</span>, 
             <span class="c-arg">height</span> = <span class="c-num">2</span>, 
             <span class="c-arg">trim5</span> = <span class="c-num">50</span>, 
             <span class="c-arg">showcalls</span> = <span class="c-str">"both"</span>)

<span class="c-com"># 4. Convertir a FASTA para alineamiento</span>
<span class="c-fn">writeXStringSet</span>(<span class="c-var">primary_seq</span>, <span class="c-str">"output/secuencia.fasta"</span>)`;
                    } else if (p.tech.includes('Illumina')) {
                        return `
<span class="c-com"># ANÁLISIS ILLUMINA (NEXT GENERATION SEQUENCING)</span>
<span class="c-com"># Secuenciación masiva paralela (Short Reads)</span>

<span class="c-kwd">library</span>(ShortRead)
<span class="c-kwd">library</span>(Rsamtools)

<span class="c-com"># 1. Control de Calidad de lecturas crudas (FASTQ)</span>
<span class="c-var">fq_files</span> <span class="c-op"><-</span> <span class="c-fn">list.files</span>(<span class="c-arg">pattern</span>=<span class="c-str">".fastq.gz"</span>)
<span class="c-var">qa_summary</span> <span class="c-op"><-</span> <span class="c-fn">qa</span>(<span class="c-var">fq_files</span>)
<span class="c-fn">report</span>(<span class="c-var">qa_summary</span>, <span class="c-arg">dest</span>=<span class="c-str">"QA_Report"</span>)

<span class="c-com"># 2. Filtrado y Recorte (Trimming)</span>
<span class="c-com"># Eliminar adaptadores y bases de baja calidad (Phred < 20)</span>
<span class="c-var">filters</span> <span class="c-op"><-</span> <span class="c-fn">nFilter</span>(<span class="c-arg">threshold</span>=<span class="c-num">1</span>)
<span class="c-var">clean_reads</span> <span class="c-op"><-</span> <span class="c-fn">filterFastq</span>(<span class="c-var">fq_files</span>, <span class="c-var">filters</span>)

<span class="c-com"># 3. Importar alineamientos (BAM files)</span>
<span class="c-var">bam_file</span> <span class="c-op"><-</span> <span class="c-fn">BamFile</span>(<span class="c-str">"aligned_reads.bam"</span>)
<span class="c-var">alignments</span> <span class="c-op"><-</span> <span class="c-fn">scanBam</span>(<span class="c-var">bam_file</span>)

<span class="c-com"># 4. Calcular cobertura</span>
<span class="c-var">coverage_data</span> <span class="c-op"><-</span> <span class="c-fn">coverage</span>(<span class="c-var">bam_file</span>)
<span class="c-fn">plot</span>(<span class="c-var">coverage_data</span>[[<span class="c-num">1</span>]], <span class="c-arg">main</span>=<span class="c-str">"Coverage Chromosome 1"</span>)`;
                    } else {
                        return `
<span class="c-com"># ANÁLISIS NANOPORE (THIRD GENERATION SEQUENCING)</span>
<span class="c-com"># Secuenciación de molécula única y lecturas largas</span>

<span class="c-kwd">library</span>(rhdf5)
<span class="c-kwd">library</span>(poRe)

<span class="c-com"># 1. Leer archivos FAST5 (Datos crudos de señal eléctrica)</span>
<span class="c-var">f5_file</span> <span class="c-op"><-</span> <span class="c-str">"reads/batch_0.fast5"</span>
<span class="c-var">h5_content</span> <span class="c-op"><-</span> <span class="c-fn">h5ls</span>(<span class="c-var">f5_file</span>)

<span class="c-com"># 2. Extraer eventos de señal (Squiggle plot)</span>
<span class="c-com"># La señal representa el cambio en corriente iónica</span>
<span class="c-var">signal_data</span> <span class="c-op"><-</span> <span class="c-fn">get_signal_data</span>(<span class="c-var">f5_file</span>)
<span class="c-fn">plot</span>(<span class="c-var">signal_data</span>, <span class="c-arg">type</span>=<span class="c-str">"l"</span>, <span class="c-arg">col</span>=<span class="c-str">"darkgreen"</span>, 
     <span class="c-arg">main</span>=<span class="c-str">"Raw Ionic Current Signal"</span>)

<span class="c-com"># 3. Basecalling (Convertir señal a nucleótidos)</span>
<span class="c-com"># Generalmente se hace con Guppy o Dorado (CLI), aquí importamos:</span>
<span class="c-var">long_reads</span> <span class="c-op"><-</span> <span class="c-fn">readFastq</span>(<span class="c-str">"nanopore_pass.fastq"</span>)

<span class="c-com"># 4. Longitud de lectura (N50)</span>
<span class="c-var">read_lengths</span> <span class="c-op"><-</span> <span class="c-fn">width</span>(<span class="c-var">long_reads</span>)
<span class="c-fn">hist</span>(<span class="c-fn">log10</span>(<span class="c-var">read_lengths</span>), <span class="c-arg">breaks</span>=<span class="c-num">50</span>)`;
                    }
                },
                
                explain: (p) => {
                    if(p.tech.includes('Sanger')) return `
                        <div class="exp-highlight"><b>Sanger (Dideoxinucleótidos):</b> El método clásico.</div>
                        <p>Usa terminadores de cadena fluorescentes (ddNTPs). Genera un cromatograma con picos de colores.</p>
                        <ul>
                            <li><b>Ventaja:</b> Altísima precisión (99.99%).</li>
                            <li><b>Desventaja:</b> Bajo rendimiento (una secuencia a la vez).</li>
                            <li><b>Uso:</b> Validación de variantes puntuales, secuenciación de plásmidos.</li>
                        </ul>`;
                    if(p.tech.includes('Illumina')) return `
                        <div class="exp-highlight"><b>Illumina (Sequencing by Synthesis):</b> El estándar actual.</div>
                        <p>Secuenciación masiva en paralelo en una celda de flujo (flowcell). Usa terminadores reversibles.</p>
                        <ul>
                            <li><b>Cluster Generation:</b> Amplificación en puente para generar señal fuerte.</li>
                            <li><b>Reads:</b> Lecturas cortas (150-300 pb) pero millones de ellas.</li>
                            <li><b>Uso:</b> Genomas completos, RNA-seq, Exomas.</li>
                        </ul>`;
                    return `
                        <div class="exp-highlight"><b>Nanopore (Oxford Nanopore):</b> Secuenciación en tiempo real.</div>
                        <p>Mide cambios en la corriente iónica cuando una molécula de ADN atraviesa un poro proteico.</p>
                        <ul>
                            <li><b>Reads:</b> Lecturas ultra largas (>100 kb).</li>
                            <li><b>Portabilidad:</b> Equipos del tamaño de un USB (MinION).</li>
                            <li><b>Uso:</b> Ensamblaje de genomas complejos, detección de metilación directa.</li>
                        </ul>`;
                },
                
                render: (p, div) => {
                    // --- LAYOUT CORREGIDO (Estilo "Estadística") ---
                    div.style.cssText = "";
                    div.style.width = "100%";
                    div.style.height = "100%";
                    div.style.display = "flex";
                    div.style.flexDirection = "column";
                    div.style.alignItems = "center";
                    div.style.justifyContent = "flex-start"; // Alineación arriba
                    div.style.padding = "20px";
                    div.style.overflowY = "auto";            // Scroll activado
                    div.style.boxSizing = "border-box";
                    
                    div.innerHTML = '';

                    const techType = p.tech.split(' ')[0];

                    if (techType === 'Sanger') {
                        // === 1. VISUALIZACIÓN SANGER (Cromatograma Realista) ===
                        
                        const container = document.createElement('div');
                        container.style.cssText = `width: 95%; max-width: 700px; background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); margin-bottom: 20px; flex-shrink: 0;`;
                        
                        const title = document.createElement('h3');
                        title.textContent = "Simulación de Cromatograma (Trace file)";
                        title.style.cssText = "text-align: center; color: #2c3e50; margin-bottom: 15px; font-size: 1.1rem;";
                        container.appendChild(title);

                        const canvas = document.createElement('canvas');
                        canvas.width = 650;
                        canvas.height = 300;
                        canvas.style.cssText = "width: 100%; border: 1px solid #eee; background: #fafafa; border-radius: 4px;";
                        container.appendChild(canvas);
                        
                        const ctx = canvas.getContext('2d');
                        
                        // Generar secuencia aleatoria
                        const bases = [];
                        const sequenceLength = 40;
                        const chars = ['A', 'T', 'C', 'G'];
                        const colors = {'A': '#27ae60', 'T': '#c0392b', 'C': '#2980b9', 'G': '#2c3e50'}; // Verde, Rojo, Azul, Negro
                        
                        for(let i=0; i<sequenceLength; i++) bases.push(chars[Math.floor(Math.random()*4)]);
                        
                        // Función para dibujar picos gaussianos
                        const drawPeak = (x, height, color, offset) => {
                            ctx.beginPath();
                            ctx.moveTo(x - 20, 250);
                            for(let i = -20; i <= 20; i++) {
                                // Fórmula Gaussiana: a * exp(-(x-b)^2 / 2c^2)
                                const y = height * Math.exp(-Math.pow(i - offset, 2) / 50);
                                ctx.lineTo(x + i, 250 - y);
                            }
                            ctx.strokeStyle = color;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            // Relleno degradado
                            const grad = ctx.createLinearGradient(x, 250-height, x, 250);
                            grad.addColorStop(0, color);
                            grad.addColorStop(1, "rgba(255,255,255,0)");
                            ctx.fillStyle = grad;
                            ctx.fill();
                        };

                        // Dibujar cromatograma
                        let xPos = 30;
                        const spacing = 16;
                        
                        // Fondo de calidad (Phred score simulado)
                        bases.forEach((base, i) => {
                            const qual = 40 + Math.random() * 20; // Altura de barra calidad
                            const qColor = qual > 50 ? '#ecf0f1' : '#ffebee';
                            ctx.fillStyle = qColor;
                            ctx.fillRect(xPos - 8, 10, 16, 280);
                            xPos += spacing;
                        });

                        // Dibujar trazas (ruido de fondo + picos)
                        xPos = 30;
                        bases.forEach((base, i) => {
                            // Dibujar picos de otras bases (ruido)
                            chars.forEach(b => {
                                if(b !== base) {
                                    const noiseH = Math.random() * 20;
                                    drawPeak(xPos, noiseH, colors[b], (Math.random()-0.5)*10);
                                }
                            });
                            // Dibujar pico principal
                            const mainH = 100 + Math.random() * 80;
                            drawPeak(xPos, mainH, colors[base], 0);
                            
                            // Letra
                            ctx.fillStyle = colors[base];
                            ctx.font = "bold 14px monospace";
                            ctx.textAlign = "center";
                            ctx.fillText(base, xPos, 275);
                            
                            xPos += spacing;
                        });
                        
                        // Leyenda
                        const legend = document.createElement('div');
                        legend.style.cssText = "display: flex; justify-content: center; gap: 20px; margin-top: 10px; font-size: 0.9rem;";
                        legend.innerHTML = `
                            <span style="color:#27ae60"><b>A</b> (Adenina)</span>
                            <span style="color:#2980b9"><b>C</b> (Citosina)</span>
                            <span style="color:#2c3e50"><b>G</b> (Guanina)</span>
                            <span style="color:#c0392b"><b>T</b> (Timina)</span>
                        `;
                        container.appendChild(legend);
                        div.appendChild(container);

                        // Tarjeta de info extra
                        const info = document.createElement('div');
                        info.style.cssText = "width: 95%; max-width: 700px; background: #fffde7; padding: 15px; border-left: 5px solid #f1c40f; border-radius: 4px; color: #7f8c8d; font-size: 0.9rem; flex-shrink: 0;";
                        info.innerHTML = "<b>Nota Bioinformática:</b> Los archivos <code>.ab1</code> contienen la 'forma de onda' cruda. El software basecaller asigna una puntuación de calidad (Phred) a cada pico basándose en la relación señal/ruido.";
                        div.appendChild(info);

                    } else if (techType === 'Illumina') {
                        // === 2. VISUALIZACIÓN ILLUMINA (Flowcell + Alignment) ===
                        
                        // Panel 1: Flowcell
                        const flowcellDiv = document.createElement('div');
                        flowcellDiv.style.cssText = `width: 95%; max-width: 700px; background: #2c3e50; border-radius: 12px; padding: 20px; margin-bottom: 15px; flex-shrink: 0; box-shadow: 0 4px 10px rgba(0,0,0,0.2); position: relative; overflow: hidden;`;
                        
                        const fcTitle = document.createElement('div');
                        fcTitle.innerHTML = "<i class='fas fa-microchip'></i> Flowcell (Cluster Generation)";
                        fcTitle.style.cssText = "color: white; margin-bottom: 10px; font-weight: bold;";
                        flowcellDiv.appendChild(fcTitle);
                        
                        const clusterArea = document.createElement('div');
                        clusterArea.style.cssText = "height: 150px; position: relative;";
                        
                        // Generar clusters parpadeantes
                        for(let i=0; i<80; i++) {
                            const cluster = document.createElement('div');
                            const size = 4 + Math.random() * 6;
                            const left = Math.random() * 95;
                            const top = Math.random() * 90;
                            const color = Math.random() > 0.5 ? '#e74c3c' : '#2ecc71'; // Rojo/Verde (terminadores)
                            const delay = Math.random() * 2;
                            
                            cluster.style.cssText = `
                                position: absolute; width: ${size}px; height: ${size}px; border-radius: 50%;
                                background: ${color}; left: ${left}%; top: ${top}%;
                                box-shadow: 0 0 5px ${color};
                                animation: blink 1s infinite alternate ${delay}s;
                            `;
                            // Inyectar keyframes si no existen
                            if(!document.getElementById('blinkStyle')) {
                                const style = document.createElement('style');
                                style.id = 'blinkStyle';
                                style.innerHTML = `@keyframes blink { from { opacity: 0.2; transform: scale(0.8); } to { opacity: 1; transform: scale(1.2); } }`;
                                document.head.appendChild(style);
                            }
                            clusterArea.appendChild(cluster);
                        }
                        flowcellDiv.appendChild(clusterArea);
                        div.appendChild(flowcellDiv);

                        // Panel 2: Alineamiento (IGV Style)
                        const alignDiv = document.createElement('div');
                        alignDiv.style.cssText = `width: 95%; max-width: 700px; background: white; border-radius: 12px; padding: 20px; margin-bottom: 20px; flex-shrink: 0; box-shadow: 0 4px 10px rgba(0,0,0,0.1);`;
                        
                        alignDiv.innerHTML = "<h4 style='margin-bottom:10px; color:#333;'>Alineamiento de Reads (IGV View)</h4>";
                        
                        // Referencia
                        const refDiv = document.createElement('div');
                        refDiv.style.cssText = "display: flex; gap: 2px; margin-bottom: 10px; border-bottom: 2px solid #ddd; padding-bottom: 5px;";
                        const refSeq = "ATGCGTACGTAGCTAGCTAGCTAGCTAGCTAG";
                        for(let char of refSeq) {
                            const base = document.createElement('div');
                            base.textContent = char;
                            base.style.cssText = `width: 15px; text-align: center; font-family: monospace; font-weight: bold; color: #999;`;
                            refDiv.appendChild(base);
                        }
                        alignDiv.appendChild(refDiv);
                        
                        // Reads apilados
                        const readsArea = document.createElement('div');
                        readsArea.style.cssText = "height: 150px; position: relative; background: #fafafa;";
                        
                        for(let i=0; i<15; i++) {
                            const read = document.createElement('div');
                            const start = Math.floor(Math.random() * 20);
                            const width = 50 + Math.random() * 100;
                            const top = i * 10;
                            const isReverse = Math.random() > 0.5;
                            const color = isReverse ? '#81d4fa' : '#ef9a9a'; // Azul/Rojo según hebra
                            
                            read.style.cssText = `
                                position: absolute; left: ${start * 15}px; top: ${top}px; 
                                width: ${width}px; height: 6px; background: ${color}; 
                                border-radius: 2px;
                            `;
                            // Simular mutación (cuadrito de otro color)
                            if(Math.random() > 0.7) {
                                const snp = document.createElement('div');
                                snp.style.cssText = "position: absolute; left: 20px; width: 4px; height: 6px; background: black;";
                                read.appendChild(snp);
                            }
                            readsArea.appendChild(read);
                        }
                        alignDiv.appendChild(readsArea);
                        div.appendChild(alignDiv);

                    } else {
                        // === 3. VISUALIZACIÓN NANOPORE (Squiggle Plot) ===
                        
                        const container = document.createElement('div');
                        container.style.cssText = `width: 95%; max-width: 700px; background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); margin-bottom: 20px; flex-shrink: 0;`;
                        
                        container.innerHTML = "<h3 style='text-align:center; color:#2c3e50;'>Señal de Corriente Iónica (Squiggle)</h3>";
                        
                        // Canvas para animación
                        const canvas = document.createElement('canvas');
                        canvas.width = 650;
                        canvas.height = 200;
                        canvas.style.cssText = "width: 100%; background: #222; border-radius: 8px; margin-top: 10px;";
                        container.appendChild(canvas);
                        
                        const ctx = canvas.getContext('2d');
                        
                        // Datos simulados de corriente
                        let time = 0;
                        const dataPoints = [];
                        const maxPoints = 200;
                        
                        // Loop de animación
                        const animate = () => {
                            // Generar nuevo punto (señal ruidosa con saltos)
                            // Los saltos representan k-mers pasando por el poro
                            if (time % 20 === 0) {
                                this.targetLevel = 100 + (Math.random() - 0.5) * 80;
                            }
                            // Moverse hacia el target con ruido
                            const currentVal = this.targetLevel + (Math.random() - 0.5) * 15;
                            
                            dataPoints.push(currentVal);
                            if(dataPoints.length > maxPoints) dataPoints.shift();
                            
                            // Dibujar
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            
                            // Grid
                            ctx.strokeStyle = "#333";
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(0, 100); ctx.lineTo(650, 100);
                            ctx.stroke();
                            
                            // Señal
                            ctx.beginPath();
                            ctx.strokeStyle = "#00e676"; // Verde neón
                            ctx.lineWidth = 2;
                            
                            for(let i=0; i<dataPoints.length; i++) {
                                const x = (i / maxPoints) * canvas.width;
                                const y = dataPoints[i];
                                if(i===0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.stroke();
                            
                            // Dibujar "Poro" esquemático a la derecha
                            ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
                            ctx.fillRect(canvas.width - 50, 0, 50, 200);
                            ctx.fillStyle = "white";
                            ctx.fillText("PORE", canvas.width - 40, 20);
                            
                            time++;
                            // Guardar el ID para poder cancelar si cambiamos de slide (opcional)
                            this.animId = requestAnimationFrame(animate);
                        };
                        
                        // Iniciar animación
                        this.targetLevel = 100;
                        animate();
                        
                        div.appendChild(container);
                        
                        const info = document.createElement('div');
                        info.style.cssText = "width: 95%; max-width: 700px; display: flex; gap: 10px; align-items: center; background: #e8f5e9; padding: 10px; border-radius: 8px; color: #2e7d32; font-size: 0.9rem; flex-shrink: 0;";
                        info.innerHTML = "<i class='fas fa-bolt'></i> <span><b>Raw Signal:</b> La línea verde muestra la corriente (picoamperios). Cada 'escalón' corresponde a un k-mer (ej. ATCG) bloqueando el poro.</span>";
                        div.appendChild(info);
                    }
                }
            },
            {
                id: 2,
                title: "Tema 2. Alineamiento y Mapeo (Mapping)",
                desc: "Alineamiento de lecturas contra un genoma de referencia",
                icon: "fa-align-left",
                controls: [
                    {id: 'aligner', type: 'select', label: 'Alineador', options: ['BWA-MEM (DNA)', 'Bowtie2 (Fast)', 'STAR (RNA-seq)']},
                    {id: 'mismatches', type: 'range', label: 'Max Mismatches', min: 0, max: 5, step: 1, val: 2}
                ],
                // CÓDIGO R EXTENDIDO Y PROFESIONAL
                code: (p) => {
                    const tool = p.aligner.split(' ')[0];
                    const isRNA = tool === 'STAR';
                    
                    return `
<span class="c-com"># PIPELINE DE ALINEAMIENTO DE SECUENCIAS (${tool})</span>
<span class="c-com"># Objetivo: Mapear lecturas FASTQ al Genoma de Referencia (FASTA)</span>

<span class="c-kwd">library</span>(Rsubread)
<span class="c-kwd">library</span>(Rsamtools)

<span class="c-com"># 1. Construcción del Índice (Solo se hace una vez)</span>
<span class="c-com"># Permite búsquedas rápidas en el genoma</span>
<span class="c-var">ref_genome</span> <span class="c-op"><-</span> <span class="c-str">"hg38.fasta"</span>
<span class="c-fn">buildindex</span>(<span class="c-arg">basename</span>=<span class="c-str">"hg38_index"</span>, <span class="c-arg">reference</span>=<span class="c-var">ref_genome</span>)

<span class="c-com"># 2. Alineamiento (Mapping)</span>
<span class="c-var">reads_file</span> <span class="c-op"><-</span> <span class="c-str">"sample_01.fastq.gz"</span>

<span class="c-kwd">align</span>(
    <span class="c-arg">index</span> = <span class="c-str">"hg38_index"</span>,
    <span class="c-arg">readfile1</span> = <span class="c-var">reads_file</span>,
    <span class="c-arg">output_file</span> = <span class="c-str">"aligned.bam"</span>,
    <span class="c-arg">type</span> = <span class="c-str">"${isRNA ? 'rna' : 'dna'}"</span>,  <span class="c-com"># ${isRNA ? 'STAR maneja splicing (intrones)' : 'BWA/Bowtie para ADN contiguo'}</span>
    <span class="c-arg">nthreads</span> = <span class="c-num">8</span>,
    <span class="c-arg">nBestLocations</span> = <span class="c-num">1</span>,
    <span class="c-arg">maxMismatches</span> = <span class="c-num">${p.mismatches}</span>
)

<span class="c-com"># 3. Post-procesamiento BAM (Binary Alignment Map)</span>
<span class="c-com"># Ordenar por coordenadas para visualización en IGV</span>
<span class="c-fn">sortBam</span>(<span class="c-str">"aligned.bam"</span>, <span class="c-str">"aligned_sorted"</span>)

<span class="c-com"># 4. Indexar el BAM (.bai)</span>
<span class="c-fn">indexBam</span>(<span class="c-str">"aligned_sorted.bam"</span>)

<span class="c-com"># 5. Estadísticas de mapeo</span>
<span class="c-var">stats</span> <span class="c-op"><-</span> <span class="c-fn">idxstatsBam</span>(<span class="c-str">"aligned_sorted.bam"</span>)
<span class="c-fn">print</span>(<span class="c-var">stats</span>)`;
                },
                
                explain: (p) => {
                    return `
                    <div class="exp-highlight">
                        <b>📍 El problema del Mapeo:</b>
                        <p>Tenemos millones de piezas de un rompecabezas (Reads) y necesitamos encontrar su lugar exacto en la imagen de la caja (Genoma de Referencia).</p>
                    </div>
                    
                    <p><b>Algoritmos seleccionados:</b></p>
                    <ul>
                        <li><b>BWA-MEM / Bowtie2:</b> Usan la Transformada de Burrows-Wheeler (BWT). Son ideales para ADN donde el alineamiento es contiguo (sin huecos grandes).</li>
                        <li><b>STAR (Spliced Transcripts Alignment):</b> Especial para RNA-seq. Es capaz de "saltar" intrones, mapeando una lectura partida (spliced read) entre dos exones distantes.</li>
                    </ul>
                    
                    <div class="exp-note">
                        <i class="fas fa-search"></i> <b>Visualización (IGV):</b>
                        <p>En la simulación, verás las barras grises (reads) apilándose. Si hay una base de color (A, T, C, G) dentro de la barra gris, indica un <b>Mismatch (SNP)</b> o error respecto a la referencia.</p>
                    </div>`;
                },
                
                render: (p, div) => {
                    // --- LAYOUT CORREGIDO Y ROBUSTO ---
                    div.style.cssText = "";
                    div.style.width = "100%";
                    div.style.height = "100%";
                    div.style.display = "flex";
                    div.style.flexDirection = "column";
                    div.style.alignItems = "center";
                    div.style.justifyContent = "flex-start"; // Alineación superior
                    div.style.padding = "20px";
                    div.style.overflowY = "auto";            // Scroll activado
                    div.style.boxSizing = "border-box";
                    
                    div.innerHTML = '';
                    
                    const isRNA = p.aligner.includes('STAR');
                    const allowedMismatches = p.mismatches || 2;

                    // 1. VISOR DE GENOMA (IGV STYLE)
                    const igvContainer = document.createElement('div');
                    igvContainer.style.cssText = `
                        width: 95%; max-width: 800px; height: 350px;
                        background: white; border-radius: 8px; border: 1px solid #ccc;
                        display: flex; flex-direction: column; overflow: hidden;
                        box-shadow: 0 4px 10px rgba(0,0,0,0.1); flex-shrink: 0;
                    `;
                    
                    // Header IGV
                    const igvHeader = document.createElement('div');
                    igvHeader.style.cssText = `background: #f1f1f1; padding: 8px 15px; border-bottom: 1px solid #ccc; display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; color: #555;`;
                    igvHeader.innerHTML = `<span><i class="fas fa-dna"></i> Reference: <b>hg38</b></span> <span>Region: chr1:10,500-10,600</span>`;
                    igvContainer.appendChild(igvHeader);

                    // Canvas principal para el dibujo
                    const canvasBox = document.createElement('div');
                    canvasBox.style.cssText = `flex: 1; position: relative; background: #fff; overflow: hidden;`;
                    igvContainer.appendChild(canvasBox);
                    
                    // Elementos internos
                    // 1. Coverage Track (Histograma arriba)
                    const coverageTrack = document.createElement('div');
                    coverageTrack.style.cssText = `position: absolute; top: 0; left: 0; width: 100%; height: 60px; background: #fafafa; border-bottom: 1px solid #eee; display: flex; align-items: flex-end; padding: 0 10px; box-sizing: border-box; gap: 1px;`;
                    canvasBox.appendChild(coverageTrack);
                    
                    // 2. Reference Track (Línea de colorines abajo del coverage)
                    const refTrack = document.createElement('div');
                    refTrack.style.cssText = `position: absolute; top: 60px; left: 0; width: 100%; height: 20px; background: #eee; display: flex;`;
                    canvasBox.appendChild(refTrack);
                    
                    // 3. Reads Track (Area de alineamiento)
                    const readsTrack = document.createElement('div');
                    readsTrack.style.cssText = `position: absolute; top: 85px; left: 0; width: 100%; bottom: 0; overflow-y: hidden;`; // Hidden scroll for visual cleaness in animation
                    canvasBox.appendChild(readsTrack);

                    // --- LÓGICA DE SIMULACIÓN ---
                    const seqLength = 60; // Bloques visuales
                    const refSeq = [];
                    const bases = ['A', 'C', 'G', 'T'];
                    const colors = {'A': '#2ecc71', 'C': '#3498db', 'G': '#f1c40f', 'T': '#e74c3c'};
                    
                    // Generar Referencia
                    for(let i=0; i<seqLength; i++) {
                        const base = bases[Math.floor(Math.random()*4)];
                        refSeq.push(base);
                        const block = document.createElement('div');
                        block.style.cssText = `flex: 1; background: ${colors[base]}; opacity: 0.5; border-right: 1px solid white;`;
                        block.title = base;
                        refTrack.appendChild(block);
                    }
                    
                    // Array para controlar la altura del coverage (pileup)
                    const coverageData = new Array(seqLength).fill(0);
                    // Crear barras de coverage iniciales
                    const covBars = [];
                    for(let i=0; i<seqLength; i++) {
                        const bar = document.createElement('div');
                        bar.style.cssText = `flex: 1; background: #bdc3c7; height: 0%; transition: height 0.2s;`;
                        coverageTrack.appendChild(bar);
                        covBars.push(bar);
                    }

                    div.appendChild(igvContainer);

                    // --- ANIMACIÓN DE LECTURAS ---
                    let activeReads = 0;
                    const maxReads = 40;
                    
                    const spawnRead = () => {
                        if(activeReads > maxReads) return; // Limite visual
                        
                        const readDiv = document.createElement('div');
                        // Longitud de lectura (ej. 10 bloques)
                        const readLen = 10;
                        const startPos = Math.floor(Math.random() * (seqLength - readLen));
                        
                        // Lógica Spliced (STAR) vs Contigua
                        const isSpliced = isRNA && Math.random() > 0.6; // 40% probabilidad de ser spliced si es RNA
                        
                        // Crear visual de la lectura
                        // Contenedor absoluto
                        readDiv.style.cssText = `
                            position: absolute; 
                            left: ${(startPos / seqLength) * 100}%; 
                            top: -20px; /* Empieza arriba */
                            height: 12px; 
                            width: ${(readLen / seqLength) * 100}%;
                            opacity: 0;
                            transition: all 1s ease-out;
                        `;
                        
                        if (isSpliced) {
                            // Lectura partida: Exon1 --- Intron --- Exon2
                            const gapSize = 4; // Tamaño del hueco
                            const exonSize = (readLen - gapSize) / 2;
                            
                            readDiv.style.width = `${((readLen + gapSize) / seqLength) * 100}%`;
                            
                            // Exon 1
                            const ex1 = document.createElement('div');
                            ex1.style.cssText = `position: absolute; left: 0; width: ${(exonSize/(readLen+gapSize))*100}%; height: 100%; background: #95a5a6; border-radius: 2px;`;
                            readDiv.appendChild(ex1);
                            
                            // Línea Intron
                            const intron = document.createElement('div');
                            intron.style.cssText = `position: absolute; left: ${(exonSize/(readLen+gapSize))*100}%; width: ${(gapSize/(readLen+gapSize))*100}%; top: 50%; height: 1px; background: #95a5a6;`;
                            readDiv.appendChild(intron);
                            
                            // Exon 2
                            const ex2 = document.createElement('div');
                            ex2.style.cssText = `position: absolute; right: 0; width: ${(exonSize/(readLen+gapSize))*100}%; height: 100%; background: #95a5a6; border-radius: 2px;`;
                            readDiv.appendChild(ex2);
                            
                            // Añadir coverage para las dos partes
                            for(let k=0; k<readLen+gapSize; k++) {
                                if(k < exonSize || k >= exonSize+gapSize) {
                                    if(startPos+k < seqLength) coverageData[startPos+k]++;
                                }
                            }

                        } else {
                            // Lectura contigua normal
                            readDiv.style.background = "#95a5a6"; // Gris IGV
                            readDiv.style.borderRadius = "2px";
                            
                            // Mismatches simulados
                            // Flecha para indicar dirección (punta)
                            const isReverse = Math.random() > 0.5;
                            if(isReverse) {
                                readDiv.style.borderLeft = "2px solid #7f8c8d"; // Marca visual de hebra
                            } else {
                                readDiv.style.borderRight = "2px solid #7f8c8d";
                            }

                            // Generar Mismatches
                            const numMismatches = Math.floor(Math.random() * (allowedMismatches + 1));
                            for(let m=0; m<numMismatches; m++) {
                                const misPos = Math.floor(Math.random() * readLen);
                                const snp = document.createElement('div');
                                const snpBase = bases[Math.floor(Math.random()*4)];
                                
                                snp.style.cssText = `
                                    position: absolute; 
                                    left: ${(misPos/readLen)*100}%; 
                                    top: 0; height: 100%; width: ${100/readLen}%;
                                    background: ${colors[snpBase]};
                                `;
                                readDiv.appendChild(snp);
                            }
                            
                            // Añadir coverage
                            for(let k=0; k<readLen; k++) {
                                if(startPos+k < seqLength) coverageData[startPos+k]++;
                            }
                        }
                        
                        readsTrack.appendChild(readDiv);
                        
                        // Animar entrada
                        setTimeout(() => {
                            // Calcular posición Y basada en "activeReads" para apilar
                            // Usamos módulo para reciclar filas
                            const row = activeReads % 15; 
                            readDiv.style.top = `${row * 14}px`; // 14px altura por fila
                            readDiv.style.opacity = 1;
                        }, 50);
                        
                        activeReads++;
                        
                        // Actualizar histograma de coverage
                        const maxCov = Math.max(...coverageData);
                        coverageData.forEach((val, idx) => {
                            if(covBars[idx]) {
                                const h = maxCov > 0 ? (val / maxCov) * 100 : 0;
                                covBars[idx].style.height = `${h}%`;
                            }
                        });
                        
                        // Loop
                        if(activeReads < maxReads) {
                            setTimeout(spawnRead, 100); // Velocidad de llegada
                        }
                    };
                    
                    // Iniciar animación
                    setTimeout(spawnRead, 500);

                    // 2. DASHBOARD DE ESTADÍSTICAS (Abajo)
                    const statsDiv = document.createElement('div');
                    statsDiv.style.cssText = `width: 95%; max-width: 800px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-top: 20px; flex-shrink: 0;`;
                    
                    // Datos simulados
                    const mappingRate = (90 + Math.random()*8).toFixed(1);
                    const dupRate = (Math.random()*5).toFixed(1);
                    
                    const stats = [
                        {l: "Mapping Rate", v: mappingRate + "%", c: "#27ae60", i: "fa-check-circle"},
                        {l: "Mean Coverage", v: "32x", c: "#2980b9", i: "fa-layer-group"},
                        {l: "Multi-mapping", v: dupRate + "%", c: "#e67e22", i: "fa-copy"}
                    ];
                    
                    stats.forEach(s => {
                        const card = document.createElement('div');
                        card.style.cssText = `background: white; border-radius: 8px; padding: 15px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); text-align: center; border-left: 4px solid ${s.c};`;
                        card.innerHTML = `
                            <i class="fas ${s.i}" style="color: ${s.c}; font-size: 1.5rem; margin-bottom: 5px;"></i>
                            <div style="font-size: 0.9rem; color: #7f8c8d;">${s.l}</div>
                            <div style="font-size: 1.4rem; font-weight: bold; color: #2c3e50;">${s.v}</div>
                        `;
                        statsDiv.appendChild(card);
                    });
                    
                    div.appendChild(statsDiv);
                }
            },
            {
                id: 3,
                title: "Tema 3. Identificación de Variantes (Variant Calling)",
                desc: "Detección de SNPs e Indels (GATK/FreeBayes)",
                icon: "fa-fingerprint",
                controls: [
                    {id: 'caller', type: 'select', label: 'Algoritmo', options: ['GATK HaplotypeCaller', 'FreeBayes (Haplotype)', 'VarScan (Heurístico)']},
                    {id: 'min_qual', type: 'range', label: 'Min. Phred Quality', min: 10, max: 60, step: 1, val: 30}
                ],
                // CÓDIGO R EXTENSO Y DETALLADO
                code: (p) => {
                    const algo = p.caller.split(' ')[0];
                    return `
<span class="c-com"># PIPELINE DE LLAMADO DE VARIANTES (${algo.toUpperCase()})</span>
<span class="c-com"># Input: Archivo BAM alineado y ordenado | Output: VCF (Variant Call Format)</span>

<span class="c-kwd">library</span>(VariantAnnotation)
<span class="c-kwd">library</span>(GenomicRanges)

<span class="c-com"># 1. Configuración de parámetros de lectura</span>
<span class="c-var">bam_file</span> <span class="c-op"><-</span> <span class="c-fn">BamFile</span>(<span class="c-str">"aligned_sorted.bam"</span>)
<span class="c-var">ref_genome</span> <span class="c-op"><-</span> <span class="c-str">"hg38.fasta"</span>

<span class="c-com"># Definir región de interés (ROI) para acelerar</span>
<span class="c-var">roi</span> <span class="c-op"><-</span> <span class="c-fn">GRanges</span>(<span class="c-arg">seqnames</span>=<span class="c-str">"chr1"</span>, <span class="c-arg">ranges</span>=<span class="c-fn">IRanges</span>(<span class="c-num">10500</span>, <span class="c-num">10600</span>))

<span class="c-com"># 2. Ejecución del Caller (${algo})</span>
<span class="c-com"># En un entorno real, esto suele llamarse desde sistema (system2)</span>
<span class="c-com"># gatk HaplotypeCaller -R ref.fa -I input.bam -O raw_variants.vcf</span>

<span class="c-com"># 3. Cargar VCF crudo en R</span>
<span class="c-var">vcf</span> <span class="c-op"><-</span> <span class="c-fn">readVcf</span>(<span class="c-str">"raw_variants.vcf"</span>, <span class="c-str">"hg38"</span>)

<span class="c-com"># Inspeccionar información</span>
<span class="c-fn">print</span>(<span class="c-fn">header</span>(<span class="c-var">vcf</span>))
<span class="c-fn">head</span>(<span class="c-fn">rowRanges</span>(<span class="c-var">vcf</span>))

<span class="c-com"># 4. Filtrado de Variantes (Hard Filtering)</span>
<span class="c-com"># Criterio: Calidad Phred > ${p.min_qual} y Profundidad (DP) > 10</span>
<span class="c-var">qual_filter</span> <span class="c-op"><-</span> <span class="c-fn">fixed</span>(<span class="c-var">vcf</span>)<span class="c-op">$</span>QUAL <span class="c-op">></span> <span class="c-num">${p.min_qual}</span>
<span class="c-var">depth_filter</span> <span class="c-op"><-</span> <span class="c-fn">info</span>(<span class="c-var">vcf</span>)<span class="c-op">$</span>DP <span class="c-op">></span> <span class="c-num">10</span>

<span class="c-var">vcf_filtered</span> <span class="c-op"><-</span> <span class="c-var">vcf</span>[<span class="c-var">qual_filter</span> <span class="c-op">&</span> <span class="c-var">depth_filter</span>, ]

<span class="c-com"># 5. Exportar resultados finales</span>
<span class="c-fn">writeVcf</span>(<span class="c-var">vcf_filtered</span>, <span class="c-str">"filtered_variants.vcf"</span>)

<span class="c-com"># Visualización rápida de transición / transversión</span>
<span class="c-fn">titv</span>(<span class="c-var">vcf_filtered</span>)`;
                },
                
                explain: (p) => {
                    return `
                    <div class="exp-highlight">
                        <b>🧬 Variant Calling (Descubrimiento de Variantes)</b>
                        <p>Es el proceso de identificar diferencias entre los datos secuenciados y un genoma de referencia.</p>
                    </div>
                    
                    <p><b>Conceptos Clave:</b></p>
                    <ul>
                        <li><b>Genotipo (GT):</b> ¿Es el individuo Homocigoto Referencia (0/0), Heterocigoto (0/1) o Homocigoto Alternativo (1/1)?</li>
                        <li><b>Calidad (QUAL):</b> Probabilidad logarítmica (Phred) de que la variante exista realmente. Un QUAL de 30 implica 1 error en 1000 (99.9% precisión).</li>
                        <li><b>Profundidad (DP):</b> Cuántas lecturas cubren esa posición. Más profundidad = Mayor confianza.</li>
                    </ul>
                    
                    <div class="exp-note">
                        <i class="fas fa-microscope"></i> <b>En la simulación:</b>
                        <p>Observa cómo el "Modelo Bayesiano" actualiza la probabilidad de cada genotipo conforme llegan nuevas lecturas. Si llegan muchas bases "T" donde debería haber "C", la barra de <b>1/1 (Hom Alt)</b> crecerá.</p>
                    </div>`;
                },
                
                render: (p, div) => {
                    // --- LAYOUT ESTILO DASHBOARD (FLEX-START + SCROLL) ---
                    div.style.cssText = "";
                    div.style.width = "100%";
                    div.style.height = "100%";
                    div.style.display = "flex";
                    div.style.flexDirection = "column";
                    div.style.alignItems = "center";
                    div.style.justifyContent = "flex-start";
                    div.style.padding = "20px";
                    div.style.overflowY = "auto";
                    div.style.boxSizing = "border-box";
                    
                    div.innerHTML = '';
                    
                    // Configuración de la simulación
                    const qualThreshold = p.min_qual || 30;
                    const isGATK = p.caller.includes('GATK');
                    
                    // 1. ZONA DE ALINEAMIENTO (PILEUP)
                    const pileupContainer = document.createElement('div');
                    pileupContainer.style.cssText = `
                        width: 95%; max-width: 700px; height: 280px; 
                        background: white; border-radius: 10px; padding: 20px;
                        box-shadow: 0 4px 10px rgba(0,0,0,0.1); margin-bottom: 20px;
                        position: relative; flex-shrink: 0; border: 1px solid #e0e0e0;
                    `;
                    
                    pileupContainer.innerHTML = `
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 0.85rem; color: #555;">
                            <span><b>Locus:</b> chr1:10,542</span>
                            <span><b>Ref Base:</b> <span style="color:#3498db; font-weight:bold;">C</span></span>
                        </div>
                    `;
                    
                    // Canvas para dibujar reads
                    const pileupBox = document.createElement('div');
                    pileupBox.style.cssText = `width: 100%; height: 200px; background: #fafafa; position: relative; overflow: hidden; border-radius: 4px; border: 1px solid #eee;`;
                    
                    // Línea central (lugar de la variante)
                    const variantLine = document.createElement('div');
                    variantLine.style.cssText = `position: absolute; left: 50%; top: 0; bottom: 0; width: 20px; background: rgba(255, 235, 59, 0.2); border-left: 1px dashed #f1c40f; border-right: 1px dashed #f1c40f; transform: translateX(-50%); z-index: 0;`;
                    pileupBox.appendChild(variantLine);
                    
                    pileupContainer.appendChild(pileupBox);
                    div.appendChild(pileupContainer);

                    // 2. MODELO BAYESIANO (Probabilidades)
                    const probContainer = document.createElement('div');
                    probContainer.style.cssText = `
                        width: 95%; max-width: 700px; 
                        background: #2c3e50; border-radius: 10px; padding: 20px;
                        box-shadow: 0 4px 10px rgba(0,0,0,0.2); margin-bottom: 20px;
                        flex-shrink: 0; color: white;
                    `;
                    
                    probContainer.innerHTML = `<div style="margin-bottom: 15px; font-size: 0.9rem; font-weight: 600;"><i class="fas fa-chart-bar"></i> Probabilidad de Genotipo (Bayesiano)</div>`;
                    
                    const barsDiv = document.createElement('div');
                    barsDiv.style.cssText = `display: flex; justify-content: space-around; align-items: flex-end; height: 100px; gap: 10px;`;
                    
                    // Barras de genotipo
                    const createBar = (label, color) => {
                        const wrapper = document.createElement('div');
                        wrapper.style.cssText = `flex: 1; display: flex; flex-direction: column; align-items: center; height: 100%;`;
                        
                        const barBg = document.createElement('div');
                        barBg.style.cssText = `width: 100%; flex: 1; background: rgba(255,255,255,0.1); border-radius: 4px; position: relative; display: flex; align-items: flex-end;`;
                        
                        const fill = document.createElement('div');
                        fill.style.cssText = `width: 100%; height: 5%; background: ${color}; border-radius: 4px; transition: height 0.3s cubic-bezier(0.4, 0, 0.2, 1);`;
                        
                        const text = document.createElement('div');
                        text.textContent = label;
                        text.style.cssText = `margin-top: 5px; font-size: 0.8rem; color: #ccc;`;
                        
                        const pct = document.createElement('div');
                        pct.textContent = "0%";
                        pct.style.cssText = `position: absolute; top: -20px; width: 100%; text-align: center; font-size: 0.8rem; font-weight: bold;`;
                        
                        barBg.appendChild(fill);
                        barBg.appendChild(pct);
                        wrapper.appendChild(barBg);
                        wrapper.appendChild(text);
                        return {wrapper, fill, pct};
                    };
                    
                    const barRef = createBar("0/0 (Ref)", "#3498db");
                    const barHet = createBar("0/1 (Het)", "#9b59b6");
                    const barAlt = createBar("1/1 (Alt)", "#e74c3c");
                    
                    barsDiv.appendChild(barRef.wrapper);
                    barsDiv.appendChild(barHet.wrapper);
                    barsDiv.appendChild(barAlt.wrapper);
                    probContainer.appendChild(barsDiv);
                    
                    div.appendChild(probContainer);

                    // 3. SALIDA VCF (Terminal style)
                    const vcfCard = document.createElement('div');
                    vcfCard.style.cssText = `
                        width: 95%; max-width: 700px; background: #1e1e1e; 
                        border-radius: 8px; padding: 15px; font-family: 'Fira Code', monospace;
                        font-size: 0.75rem; color: #d4d4d4; flex-shrink: 0; border-left: 4px solid #4CAF50;
                        margin-bottom: 30px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    `;
                    vcfCard.innerHTML = `<div style="color: #6a9955; margin-bottom: 5px;"># VCF OUTPUT PREVIEW</div>`;
                    const vcfLine = document.createElement('div');
                    vcfLine.textContent = "Waiting for data...";
                    vcfCard.appendChild(vcfLine);
                    div.appendChild(vcfCard);

                    // --- LÓGICA DE SIMULACIÓN ---
                    let refCount = 0;
                    let altCount = 0;
                    const maxReads = 30;
                    let currentReads = 0;
                    
                    // Decidir "Verdad Biológica" aleatoria para esta sesión
                    const rand = Math.random();
                    const trueGenotype = rand > 0.6 ? '1/1' : (rand > 0.3 ? '0/1' : '0/0');
                    
                    // Función para generar lecturas
                    const spawnRead = () => {
                        if (currentReads >= maxReads) return;
                        
                        const read = document.createElement('div');
                        const isForward = Math.random() > 0.5;
                        const topPos = (currentReads % 10) * 18 + 10; // Apilar ordenadamente
                        
                        // Determinar base en el sitio de la variante
                        let base = 'C'; // Ref
                        let color = '#bdc3c7'; // Gris (match)
                        let isAlt = false;
                        
                        // Probabilidad de emitir Alt basada en el genotipo verdadero
                        let pAlt = 0.01; // Error seq
                        if (trueGenotype === '0/1') pAlt = 0.5;
                        if (trueGenotype === '1/1') pAlt = 0.99;
                        
                        if (Math.random() < pAlt) {
                            base = 'T'; // Variante
                            color = '#e74c3c'; // Rojo
                            isAlt = true;
                        } else {
                            // Pequeña prob de error a otra base
                            if (Math.random() < 0.02) { base = 'A'; color = '#2ecc71'; }
                        }
                        
                        // Dibujar Read
                        read.style.cssText = `
                            position: absolute; left: -50px; top: ${topPos}px;
                            width: 200px; height: 12px; background: #e0e0e0;
                            border-radius: 2px; display: flex; align-items: center; justify-content: center;
                            font-size: 10px; font-weight: bold; color: white;
                            transition: left 0.5s ease-out;
                            opacity: 0.8;
                        `;
                        
                        // Dibujar la base variante
                        const baseMarker = document.createElement('div');
                        baseMarker.style.cssText = `
                            width: 14px; height: 14px; background: ${isAlt ? color : 'transparent'};
                            color: ${isAlt ? 'white' : 'transparent'}; text-align: center; line-height: 14px;
                            border-radius: 2px;
                        `;
                        if(isAlt) baseMarker.textContent = base;
                        read.appendChild(baseMarker);
                        
                        pileupBox.appendChild(read);
                        
                        // Animar entrada
                        setTimeout(() => {
                            read.style.left = "calc(50% - 100px)"; // Centrar
                        }, 50);
                        
                        // Actualizar contadores y probabilidades
                        setTimeout(() => {
                            if (base === 'C') refCount++;
                            if (base === 'T') altCount++;
                            updateBayesianModel();
                        }, 500);
                        
                        currentReads++;
                        if(currentReads < maxReads) setTimeout(spawnRead, 200);
                    };
                    
                    const updateBayesianModel = () => {
                        const total = refCount + altCount;
                        if (total === 0) return;
                        
                        // Modelo Bayesiano simplificado
                        // P(D|G) * P(G)
                        let p00 = Math.pow(0.99, refCount) * Math.pow(0.01, altCount);
                        let p01 = Math.pow(0.5, refCount) * Math.pow(0.5, altCount);
                        let p11 = Math.pow(0.01, refCount) * Math.pow(0.99, altCount);
                        
                        // Normalizar
                        const sum = p00 + p01 + p11;
                        p00 /= sum; p01 /= sum; p11 /= sum;
                        
                        // Actualizar barras UI
                        barRef.fill.style.height = `${p00 * 100}%`;
                        barRef.pct.textContent = `${(p00 * 100).toFixed(0)}%`;
                        
                        barHet.fill.style.height = `${p01 * 100}%`;
                        barHet.pct.textContent = `${(p01 * 100).toFixed(0)}%`;
                        
                        barAlt.fill.style.height = `${p11 * 100}%`;
                        barAlt.pct.textContent = `${(p11 * 100).toFixed(0)}%`;
                        
                        // Actualizar VCF Line
                        // Calculamos Phred Quality (aprox)
                        const errorProb = 1 - Math.max(p00, p01, p11);
                        const qual = errorProb === 0 ? 99 : Math.min(99, -10 * Math.log10(errorProb));
                        
                        let gt = "./.";
                        if (p00 > 0.9) gt = "0/0";
                        if (p01 > 0.9) gt = "0/1";
                        if (p11 > 0.9) gt = "1/1";
                        
                        const filterStatus = qual >= qualThreshold ? "PASS" : "LowQual";
                        const color = qual >= qualThreshold ? "#4CAF50" : "#f44336";
                        
                        vcfLine.innerHTML = `
                            <span style="color: #569cd6">chr1</span> 
                            <span style="color: #b5cea8">10542</span> 
                            <span style="color: #d4d4d4">.</span> 
                            <span style="color: #3498db">C</span> 
                            <span style="color: #e74c3c">T</span> 
                            <span style="color: ${color}; font-weight: bold;">${qual.toFixed(1)}</span> 
                            <span style="color: ${filterStatus==='PASS'?'#4CAF50':'#f44336'}">${filterStatus}</span> 
                            <span style="color: #ce9178">DP=${total};AF=${(altCount/total).toFixed(2)}</span> 
                            <span style="color: #dcdcaa">GT:AD:PL</span> 
                            <span style="font-weight: bold;">${gt}:${refCount},${altCount}</span>
                        `;
                    };
                    
                    // Iniciar simulación
                    setTimeout(spawnRead, 500);
                }
            },
            {
                id: 4,
                title: "Tema 4. Control de Calidad (QC)",
                desc: "Análisis de calidad (FastQC) y Trimming",
                icon: "fa-filter",
                controls: [
                    {id: 'dataset', type: 'select', label: 'Dataset', options: ['Good Data (Illumina)', 'Adapter Contamination', 'Low Quality Ends']},
                    {id: 'phred', type: 'range', label: 'Umbral Trimming (Phred)', min: 15, max: 35, step: 1, val: 20}
                ],
                // CÓDIGO R DE ALTO NIVEL
                code: (p) => {
                    const file = p.dataset.includes('Good') ? "sample_S1_L001_R1.fastq.gz" : 
                                (p.dataset.includes('Adapter') ? "sample_adapters.fastq.gz" : "sample_lowqual.fastq.gz");
                    
                    return `
<span class="c-com"># PIPELINE DE CONTROL DE CALIDAD Y FILTRADO</span>
<span class="c-com"># Objetivo: Limpiar lecturas crudas antes del alineamiento</span>

<span class="c-kwd">library</span>(ShortRead)
<span class="c-kwd">library</span>(Rfastp)  <span class="c-com"># Librería ultra-rápida (C++) para QC/Trimming</span>

<span class="c-com"># 1. Definir archivos crudos (Raw Data)</span>
<span class="c-var">fastq_file</span> <span class="c-op"><-</span> <span class="c-str">"raw_data/${file}"</span>

<span class="c-com"># 2. Generar Reporte de Calidad Inicial (Estilo FastQC)</span>
<span class="c-com"># Esto crea un HTML con métricas: Per base quality, GC content, N content...</span>
<span class="c-var">qc_report</span> <span class="c-op"><-</span> <span class="c-fn">rfastp_report</span>(<span class="c-arg">files</span> = <span class="c-var">fastq_file</span>, 
                             <span class="c-arg">output_prefix</span> = <span class="c-str">"qc_report_pre"</span>)

<span class="c-com"># 3. Procesamiento (Quality Trimming & Adapter Removal)</span>
<span class="c-com"># - Cortar colas con calidad Phred < ${p.phred}</span>
<span class="c-com"># - Detectar y eliminar adaptadores automáticamente</span>
<span class="c-com"># - Descartar lecturas que queden muy cortas (< 36bp)</span>

<span class="c-var">json_report</span> <span class="c-op"><-</span> <span class="c-fn">rfastp</span>(
    <span class="c-arg">read1</span> = <span class="c-var">fastq_file</span>,
    <span class="c-arg">output_fastqp1</span> = <span class="c-str">"clean_data/trimmed_R1.fastq.gz"</span>,
    
    <span class="c-com"># Parámetros de filtrado</span>
    <span class="c-arg">quality_phred</span> = <span class="c-num">${p.phred}</span>,      <span class="c-com"># Umbral de corte (Window sliding)</span>
    <span class="c-arg">length_required</span> = <span class="c-num">36</span>,      <span class="c-com"># Longitud mínima</span>
    <span class="c-arg">cut_window_size</span> = <span class="c-num">4</span>,       <span class="c-com"># Ventana deslizante</span>
    <span class="c-arg">cut_mean_quality</span> = <span class="c-num">${p.phred}</span>, <span class="c-com"># Calidad media en ventana</span>
    <span class="c-arg">adapter_sequence</span> = <span class="c-str">"auto"</span>  <span class="c-com"># Auto-detección de adaptadores</span>
)

<span class="c-com"># 4. Verificar resultados (Post-QC)</span>
<span class="c-com"># Cargar lecturas limpias para inspección en R</span>
<span class="c-var">clean_reads</span> <span class="c-op"><-</span> <span class="c-fn">readFastq</span>(<span class="c-str">"clean_data/trimmed_R1.fastq.gz"</span>)

<span class="c-com"># Visualizar distribución de calidad post-filtrado</span>
<span class="c-var">q_matrix</span> <span class="c-op"><-</span> <span class="c-fn">as</span>(<span class="c-fn">quality</span>(<span class="c-var">clean_reads</span>), <span class="c-str">"matrix"</span>)
<span class="c-fn">boxplot</span>(<span class="c-var">q_matrix</span>, <span class="c-arg">outline</span>=<span class="c-kwd">FALSE</span>, <span class="c-arg">main</span>=<span class="c-str">"Per Base Quality (Clean)"</span>, 
        <span class="c-arg">col</span>=<span class="c-str">"lightgreen"</span>, <span class="c-arg">xlab</span>=<span class="c-str">"Position"</span>, <span class="c-arg">ylab</span>=<span class="c-str">"Phred Score"</span>)`;
                },
                
                explain: (p) => `
                    <div class="exp-highlight">
                        <b>🧹 Control de Calidad (QC)</b>
                        <p>Los secuenciadores cometen errores, especialmente al final de las lecturas. El QC es vital para no analizar "basura".</p>
                    </div>
                    
                    <p><b>Métrica clave: Phred Score (Q)</b></p>
                    <ul>
                        <li><b>Q10:</b> 1 error cada 10 bases (90% precisión). <span style="color:red">Malo.</span></li>
                        <li><b>Q20:</b> 1 error cada 100 bases (99% precisión). <span style="color:orange">Aceptable.</span></li>
                        <li><b>Q30:</b> 1 error cada 1000 bases (99.9% precisión). <span style="color:green">Óptimo.</span></li>
                    </ul>
                    
                    <p><b>Acciones realizadas por el script:</b></p>
                    <ul>
                        <li><b>Trimming:</b> Cortar las bases malas del final (3') hasta que la calidad sea buena.</li>
                        <li><b>Adapter Removal:</b> Eliminar secuencias técnicas (adaptadores) que se colaron.</li>
                    </ul>`,
                
                render: (p, div) => {
                    // --- LAYOUT CORREGIDO (FLEX-START + SCROLL) ---
                    div.style.cssText = "";
                    div.style.width = "100%";
                    div.style.height = "100%";
                    div.style.display = "flex";
                    div.style.flexDirection = "column";
                    div.style.alignItems = "center";
                    div.style.justifyContent = "flex-start"; // Alineación arriba
                    div.style.padding = "20px";
                    div.style.overflowY = "auto";            // Scroll activado
                    div.style.boxSizing = "border-box";
                    
                    div.innerHTML = '';
                    
                    const threshold = p.phred || 20;
                    const scenario = p.dataset || 'Good';

                    // 1. GRÁFICA FASTQC INTERACTIVA
                    const qcContainer = document.createElement('div');
                    qcContainer.style.cssText = `
                        width: 95%; max-width: 750px; height: 320px;
                        background: white; border-radius: 8px; padding: 20px;
                        box-shadow: 0 4px 10px rgba(0,0,0,0.1); margin-bottom: 20px; flex-shrink: 0;
                        position: relative;
                    `;
                    
                    qcContainer.innerHTML = `<div style="text-align:center; font-weight:bold; color:#333; margin-bottom:10px;">Per base sequence quality (FastQC Sim)</div>`;
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = 700;
                    canvas.height = 250;
                    canvas.style.width = '100%';
                    canvas.style.height = '250px';
                    qcContainer.appendChild(canvas);
                    div.appendChild(qcContainer);
                    
                    const ctx = canvas.getContext('2d');
                    
                    // Función para dibujar el gráfico FastQC
                    const drawFastQC = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Zonas de colores (Background)
                        // Q30-40 (Verde)
                        ctx.fillStyle = "#e8f5e9";
                        ctx.fillRect(0, 0, canvas.width, 100); 
                        // Q20-30 (Verde claro)
                        ctx.fillStyle = "#f1f8e9";
                        ctx.fillRect(0, 100, canvas.width, 50);
                        // Q10-20 (Naranja)
                        ctx.fillStyle = "#fff3e0";
                        ctx.fillRect(0, 150, canvas.width, 50);
                        // Q0-10 (Rojo)
                        ctx.fillStyle = "#ffebee";
                        ctx.fillRect(0, 200, canvas.width, 50);
                        
                        // Ejes Y (Phred)
                        ctx.fillStyle = "#666";
                        ctx.font = "10px sans-serif";
                        [40, 30, 20, 10, 0].forEach((val, i) => {
                            const y = i * 50 + 10;
                            ctx.fillText(val, 5, y);
                            // Línea guía
                            ctx.beginPath();
                            ctx.moveTo(25, y-3); ctx.lineTo(canvas.width, y-3);
                            ctx.strokeStyle = "#eee"; ctx.stroke();
                        });

                        // Línea de Umbral (Usuario)
                        // Mapeo: 40 -> 0px, 0 -> 250px.  Y = 250 - (val/40)*250
                        const threshY = 250 - (threshold / 40) * 250;
                        ctx.beginPath();
                        ctx.moveTo(25, threshY);
                        ctx.lineTo(canvas.width, threshY);
                        ctx.strokeStyle = "blue";
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.fillText(`Threshold: Q${threshold}`, canvas.width - 80, threshY - 5);

                        // Dibujar "Bigotes" (Boxplots simulados)
                        const nPos = 30; // Posiciones en x
                        const stepX = (canvas.width - 30) / nPos;
                        
                        ctx.lineWidth = 1;
                        
                        for(let i=0; i<nPos; i++) {
                            const x = 30 + i * stepX + stepX/2;
                            
                            // Simular caída de calidad
                            let meanQ = 38; 
                            let spread = 2;
                            
                            // Escenario: Adaptadores o Low Qual hacen caer el final
                            if (scenario.includes('Low') || scenario.includes('Adapter')) {
                                if (i > 15) { // A partir de la mitad empieza a caer
                                    meanQ = 38 - (i-15) * 1.5; // Caída progresiva
                                    spread = 2 + (i-15); // Aumenta la varianza
                                }
                            }
                            // Ruido aleatorio
                            meanQ += (Math.random() - 0.5) * 2;
                            
                            // Asegurar límites
                            meanQ = Math.max(2, Math.min(40, meanQ));
                            
                            // Coordenadas Y
                            const yMean = 250 - (meanQ / 40) * 250;
                            const yHigh = yMean - (spread * 2);
                            const yLow = yMean + (spread * 3); // "Bigote" bajo más largo (errores)
                            
                            // Color de la caja (si la media está debajo de Q20 es peligroso)
                            const color = meanQ < 20 ? "#e74c3c" : "#f1c40f"; // Rojo o Amarillo (estilo FastQC)
                            
                            // Línea (Bigote)
                            ctx.beginPath();
                            ctx.moveTo(x, yHigh); ctx.lineTo(x, yLow);
                            ctx.strokeStyle = "#333";
                            ctx.stroke();
                            
                            // "Caja" (Rectángulo de cuartiles)
                            ctx.fillStyle = color;
                            const boxH = spread * 4;
                            ctx.fillRect(x - 4, yMean - boxH/2, 8, boxH);
                            
                            // Media (Línea azul)
                            ctx.beginPath();
                            ctx.moveTo(x-4, yMean); ctx.lineTo(x+4, yMean);
                            ctx.strokeStyle = "blue";
                            ctx.stroke();
                        }
                    };
                    
                    drawFastQC(); // Primer dibujo

                    // 2. SIMULADOR DE TRIMMING (Visualización de Reads)
                    const trimDiv = document.createElement('div');
                    trimDiv.style.cssText = `
                        width: 95%; max-width: 750px; background: white; border-radius: 8px; padding: 20px;
                        box-shadow: 0 4px 10px rgba(0,0,0,0.1); flex-shrink: 0;
                        margin-bottom: 30px;
                    `;
                    
                    trimDiv.innerHTML = `
                        <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
                            <span style="font-weight:bold; color:#333;">Simulador de Trimming</span>
                            <div style="font-size:0.8rem; display:flex; gap:10px;">
                                <span style="color:#27ae60">■ Buena</span>
                                <span style="color:#c0392b">■ Mala (< Q${threshold})</span>
                                <span style="color:#2980b9">■ Adaptador</span>
                            </div>
                        </div>
                    `;
                    
                    const flowArea = document.createElement('div');
                    flowArea.style.cssText = `width: 100%; height: 200px; background: #fafafa; border: 1px solid #eee; position: relative; overflow: hidden; border-radius: 4px;`;
                    trimDiv.appendChild(flowArea);
                    div.appendChild(trimDiv);
                    
                    // Estadísticas en tiempo real
                    const statsDiv = document.createElement('div');
                    statsDiv.style.cssText = `display: flex; gap: 20px; justify-content: center; margin-top: 10px;`;
                    statsDiv.innerHTML = `
                        <div class="stat-badge"><i class="fas fa-check"></i> Kept: <span id="kept-count">0</span></div>
                        <div class="stat-badge" style="color:#c0392b"><i class="fas fa-trash"></i> Trimmed: <span id="trim-count">0</span></div>
                    `;
                    trimDiv.appendChild(statsDiv);

                    // --- ANIMACIÓN DE READS ---
                    let kept = 0; 
                    let trimmed = 0;
                    
                    const spawnRead = () => {
                        const readLen = 40; // Bloques
                        const readEl = document.createElement('div');
                        readEl.style.cssText = `
                            position: absolute; left: -100%; top: ${20 + Math.random()*140}px;
                            height: 12px; display: flex; gap: 1px;
                            transition: left 4s linear; width: 300px;
                        `;
                        
                        // Generar bases del read
                        let badStart = 999;
                        let adaptStart = 999;
                        
                        // Configurar dónde empieza lo malo según escenario
                        if (scenario.includes('Low')) badStart = 25 + Math.floor(Math.random()*10);
                        if (scenario.includes('Adapter')) adaptStart = 30 + Math.floor(Math.random()*5);
                        
                        for(let i=0; i<readLen; i++) {
                            const base = document.createElement('div');
                            base.style.cssText = `flex: 1; height: 100%; border-radius: 1px;`;
                            
                            // Determinar calidad base a base
                            let quality = 35 + (Math.random()*5); // Base buena
                            
                            if (i >= badStart) quality = 10 + Math.random()*10; // Cae la calidad
                            
                            let color = '#27ae60'; // Verde (bueno)
                            let isTrimmed = false;
                            
                            // Lógica de coloreado
                            if (i >= adaptStart) {
                                color = '#2980b9'; // Adaptador (Azul)
                                // Adaptadores siempre se cortan
                                isTrimmed = true;
                            } else if (quality < threshold) {
                                color = '#c0392b'; // Mala calidad (Rojo)
                                isTrimmed = true;
                            }
                            
                            base.style.backgroundColor = color;
                            
                            // Efecto visual de corte: Si es trimmed, se hace transparente/fantasma
                            if (isTrimmed) {
                                base.style.opacity = "0.3";
                                base.style.transform = "scaleY(0.5)"; // Más pequeño
                            }
                            
                            readEl.appendChild(base);
                        }
                        
                        // Icono de tijera al inicio del corte
                        const cutIndex = Math.min(badStart, adaptStart);
                        if (cutIndex < readLen) {
                            const scissors = document.createElement('div');
                            scissors.innerHTML = '<i class="fas fa-cut"></i>';
                            scissors.style.cssText = `
                                position: absolute; left: ${(cutIndex/readLen)*100}%; top: -15px; 
                                color: #e67e22; font-size: 12px;
                            `;
                            readEl.appendChild(scissors);
                            trimmed++;
                        } else {
                            kept++;
                        }
                        
                        // Actualizar contadores
                        document.getElementById('kept-count').innerText = kept;
                        document.getElementById('trim-count').innerText = trimmed;

                        flowArea.appendChild(readEl);
                        
                        // Trigger animación
                        setTimeout(() => {
                            readEl.style.left = "110%";
                        }, 50);
                        
                        // Limpieza
                        setTimeout(() => {
                            readEl.remove();
                        }, 4100);
                        
                        // Loop
                        if (document.body.contains(flowArea)) { // Solo si sigue visible
                            setTimeout(spawnRead, 600);
                        }
                    };
                    
                    spawnRead();
                }
            },
            {
                id: 5,
                title: "Tema 5. Visualización Genómica y Ensamblaje",
                desc: "Ensamblaje De Novo, Circos Plots e Ideogramas",
                icon: "fa-project-diagram",
                controls: [
                    {id: 'viz_type', type: 'select', label: 'Enfoque Visual', options: ['Ensamblaje (De Bruijn)', 'Circular (Circos Plot)', 'Lineal (KaryoploteR)']},
                    {id: 'complexity', type: 'range', label: 'Complejidad / Zoom', min: 1, max: 10, step: 1, val: 5}
                ],
                // CÓDIGO R PROFESIONAL (3 ESCENARIOS)
                code: (p) => {
                    if (p.viz_type.includes('Ensamblaje')) {
                        return `
<span class="c-com"># PIPELINE DE ENSAMBLAJE DE NOVO (SPAdes / Velvet)</span>
<span class="c-com"># Estrategia: Grafo de De Bruijn (DBG)</span>

<span class="c-kwd">library</span>(Biostrings)
<span class="c-kwd">library</span>(igraph)

<span class="c-com"># 1. Generación de K-mers (k = 31)</span>
<span class="c-var">reads</span> <span class="c-op"><-</span> <span class="c-fn">readDNAStringSet</span>(<span class="c-str">"clean_reads.fastq"</span>)
<span class="c-var">kmers</span> <span class="c-op"><-</span> <span class="c-fn">oligonucleotideFrequency</span>(<span class="c-var">reads</span>, <span class="c-arg">width</span>=<span class="c-num">31</span>)

<span class="c-com"># 2. Construcción del Grafo</span>
<span class="c-com"># Nodos: K-mers (prefijos/sufijos) | Aristas: Superposiciones (Overlaps)</span>
<span class="c-var">dbg</span> <span class="c-op"><-</span> <span class="c-fn">make_debruijn_graph</span>(<span class="c-var">kmers</span>)

<span class="c-com"># 3. Limpieza de Errores (Simplificación Topológica)</span>
<span class="c-com"># Eliminar "Tips" (errores de seq al final) y "Bubbles" (SNPs/Heterocigocidad)</span>
<span class="c-var">dbg_clean</span> <span class="c-op"><-</span> <span class="c-fn">simplify_topology</span>(<span class="c-var">dbg</span>, <span class="c-arg">tip_length</span>=<span class="c-num">2</span>*<span class="c-num">31</span>)

<span class="c-com"># 4. Resolución de Repeticiones y Scaffolding</span>
<span class="c-com"># Usar lecturas Paired-End para saltar regiones repetitivas</span>
<span class="c-var">scaffolds</span> <span class="c-op"><-</span> <span class="c-fn">scaffold_contigs</span>(<span class="c-var">dbg_clean</span>, <span class="c-arg">insert_size</span>=<span class="c-num">500</span>)

<span class="c-com"># 5. Métricas de Calidad</span>
<span class="c-var">stats</span> <span class="c-op"><-</span> <span class="c-fn">assembly_stats</span>(<span class="c-var">scaffolds</span>)
<span class="c-fn">print</span>(<span class="c-fn">paste</span>(<span class="c-str">"N50:"</span>, <span class="c-var">stats</span>$N50))
<span class="c-fn">print</span>(<span class="c-fn">paste</span>(<span class="c-str">"L50:"</span>, <span class="c-var">stats</span>$L50))`;
                    } else if (p.viz_type.includes('Circular')) {
                        return `
<span class="c-com"># VISUALIZACIÓN CIRCULAR (PAQUETE CIRCLIZE)</span>
<span class="c-com"># Estándar para mostrar relaciones genómicas globales</span>

<span class="c-kwd">library</span>(circlize)

<span class="c-com"># 1. Inicializar ideograma (Cariotipo Humano hg38)</span>
<span class="c-fn">circos.par</span>(<span class="c-str">"start.degree"</span> = <span class="c-num">90</span>)
<span class="c-fn">circos.initializeWithIdeogram</span>(<span class="c-arg">species</span>=<span class="c-str">"hg38"</span>, <span class="c-arg">chromosome.index</span>=<span class="c-fn">paste0</span>(<span class="c-str">"chr"</span>, <span class="c-num">1</span>:<span class="c-num">22</span>))

<span class="c-com"># 2. Track 1: Densidad de Variantes (SNPs)</span>
<span class="c-var">snps</span> <span class="c-op"><-</span> <span class="c-fn">read.table</span>(<span class="c-str">"data/variants.bed"</span>)
<span class="c-fn">circos.genomicDensity</span>(<span class="c-var">snps</span>, <span class="c-arg">col</span>=<span class="c-fn">c</span>(<span class="c-str">"#FF000080"</span>), <span class="c-arg">track.height</span>=<span class="c-num">0.1</span>)

<span class="c-com"># 3. Track 2: Expresión Génica (Heatmap RNA-seq)</span>
<span class="c-var">expr</span> <span class="c-op"><-</span> <span class="c-fn">read.table</span>(<span class="c-str">"data/expression.txt"</span>)
<span class="c-fn">circos.genomicHeatmap</span>(<span class="c-var">expr</span>, <span class="c-arg">col</span> = <span class="c-fn">colorRamp2</span>(<span class="c-fn">c</span>(-<span class="c-num">2</span>,<span class="c-num">0</span>,<span class="c-num">2</span>), <span class="c-fn">c</span>(<span class="c-str">"blue"</span>,<span class="c-str">"white"</span>,<span class="c-str">"red"</span>)))

<span class="c-com"># 4. Links: Translocaciones Cromosómicas (Centro)</span>
<span class="c-com"># Ejemplo: Cromosoma Philadelphia (BCR-ABL1, t(9;22))</span>
<span class="c-fn">circos.link</span>(<span class="c-str">"chr9"</span>, <span class="c-fn">c</span>(<span class="c-num">133e6</span>, <span class="c-num">134e6</span>), 
            <span class="c-str">"chr22"</span>, <span class="c-fn">c</span>(<span class="c-num">23e6</span>, <span class="c-num">24e6</span>), 
            <span class="c-arg">col</span>=<span class="c-str">"red"</span>, <span class="c-arg">lwd</span>=<span class="c-num">2</span>)

<span class="c-fn">circos.clear</span>()`;
                    } else {
                        return `
<span class="c-com"># VISUALIZACIÓN LINEAL (PAQUETE KARYOPLOTER)</span>
<span class="c-com"># Ideal para mapeo detallado de picos, genes y cobertura</span>

<span class="c-kwd">library</span>(karyoploteR)
<span class="c-kwd">library</span>(GenomicRanges)

<span class="c-com"># 1. Crear el lienzo del genoma (Genome Plot)</span>
<span class="c-var">kp</span> <span class="c-op"><-</span> <span class="c-fn">plotKaryotype</span>(<span class="c-arg">genome</span>=<span class="c-str">"hg38"</span>, <span class="c-arg">plot.type</span>=<span class="c-num">2</span>, <span class="c-arg">chromosomes</span>=<span class="c-fn">c</span>(<span class="c-str">"chr1"</span>, <span class="c-str">"chr2"</span>, <span class="c-str">"chr3"</span>))

<span class="c-com"># 2. Añadir datos: Picos de ChIP-seq (Histonas)</span>
<span class="c-var">peaks</span> <span class="c-op"><-</span> <span class="c-fn">toGRanges</span>(<span class="c-str">"data/H3K4me3_peaks.bed"</span>)
<span class="c-fn">kpPlotRegions</span>(<span class="c-var">kp</span>, <span class="c-arg">data</span>=<span class="c-var">peaks</span>, <span class="c-arg">col</span>=<span class="c-str">"#FFA500"</span>, <span class="c-arg">r0</span>=<span class="c-num">0</span>, <span class="c-arg">r1</span>=<span class="c-num">0.5</span>)

<span class="c-com"># 3. Añadir datos: Densidad Génica (Rainfall plot)</span>
<span class="c-var">genes</span> <span class="c-op"><-</span> <span class="c-fn">makeGRangesFromDataFrame</span>(<span class="c-var">gene_data</span>)
<span class="c-fn">kpPlotDensity</span>(<span class="c-var">kp</span>, <span class="c-arg">data</span>=<span class="c-var">genes</span>, <span class="c-arg">col</span>=<span class="c-str">"blue"</span>, <span class="c-arg">window.size</span>=<span class="c-num">10e6</span>)

<span class="c-com"># 4. Marcadores específicos</span>
<span class="c-fn">kpAddMainTitle</span>(<span class="c-var">kp</span>, <span class="c-str">"Epigenetic Landscape - Chromosomes 1-3"</span>)
<span class="c-fn">kpPlotMarkers</span>(<span class="c-var">kp</span>, <span class="c-arg">chr</span>=<span class="c-str">"chr1"</span>, <span class="c-arg">x</span>=<span class="c-num">150e6</span>, <span class="c-arg">labels</span>=<span class="c-str">"Region X"</span>)`;
                    }
                },
                
                explain: (p) => {
                    const zoomLevel = p.complexity;
                    if (p.viz_type.includes('Ensamblaje')) return `
                        <div class="exp-highlight"><b>🧩 Grafo de De Bruijn (Ensamblaje):</b><br>Nodos = secuencias (k-mers). Aristas = coincidencias.</div>
                        <p>Imagina que rompemos un periódico en tiras de 3 letras. Si tenemos "OLA" y "LAS", sabemos que pueden unirse para formar "OLAS". Así se reconstruyen genomas completos.</p>
                        <ul><li><b>Complejidad actual (${zoomLevel}):</b> Muestra grafos más densos con más conexiones.</li></ul>`;
                    if (p.viz_type.includes('Circular')) return `
                        <div class="exp-highlight"><b>⭕ Circos Plot:</b><br>La "navaja suiza" de la visualización genómica global.</div>
                        <p>Muestra relaciones entre partes distantes del genoma. Las líneas curvas que cruzan el centro suelen indicar <b>Translocaciones</b> (un pedazo de cromosoma se movió a otro).</p>`;
                    return `
                        <div class="exp-highlight"><b>📏 Ideograma (KaryoploteR):</b><br>Mapeo preciso sobre la estructura cromosómica.</div>
                        <p>Aquí vemos los cromosomas "estirados". Las bandas oscuras y claras (G-banding) son reales. Encima pintamos datos como la expresión génica o picos de regulación.</p>`;
                },
                
                render: (p, div) => {
                    // --- LAYOUT MASTER FIX (FLEX-START + SCROLL) ---
                    div.style.cssText = "";
                    div.style.width = "100%";
                    div.style.height = "100%";
                    div.style.display = "flex";
                    div.style.flexDirection = "column";
                    div.style.alignItems = "center";
                    div.style.justifyContent = "flex-start"; // CLAVE: Alineación superior
                    div.style.padding = "20px";
                    div.style.overflowY = "auto";            // CLAVE: Scroll vertical
                    div.style.boxSizing = "border-box";
                    
                    div.innerHTML = '';
                    
                    const complexity = p.complexity || 5;

                    if (p.viz_type.includes('Ensamblaje')) {
                        // === 1. MODO ENSAMBLAJE (SIMULACIÓN DE GRAFOS DE BRUIJN) ===
                        
                        const container = document.createElement('div');
                        container.style.cssText = `width: 95%; max-width: 800px; height: 500px; background: #1e1e1e; border-radius: 12px; position: relative; overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,0.3); flex-shrink: 0; margin-bottom: 20px;`;
                        
                        const title = document.createElement('div');
                        title.innerHTML = `<i class="fas fa-network-wired"></i> De Bruijn Graph Assembly (K=${21 + complexity*2})`;
                        title.style.cssText = `position: absolute; top: 15px; left: 20px; color: #4CAF50; font-weight: bold; z-index: 10; font-family: monospace;`;
                        container.appendChild(title);
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = 800; canvas.height = 500;
                        container.appendChild(canvas);
                        div.appendChild(container);
                        
                        // Sistema de Partículas (Nodos del grafo)
                        const ctx = canvas.getContext('2d');
                        const nodes = [];
                        const numNodes = 15 + complexity * 3; // Más complejidad = más nodos
                        
                        // Inicializar nodos
                        for(let i=0; i<numNodes; i++) {
                            nodes.push({
                                x: Math.random() * canvas.width,
                                y: Math.random() * canvas.height,
                                vx: (Math.random() - 0.5) * 0.5,
                                vy: (Math.random() - 0.5) * 0.5,
                                seq: ['ATG', 'GCT', 'TCA', 'CAG'][Math.floor(Math.random()*4)],
                                radius: 4 + Math.random() * 4,
                                color: `hsl(${Math.random()*360}, 70%, 60%)`
                            });
                        }
                        
                        // Loop de animación física
                        const animateGraph = () => {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            
                            // Fondo grid tecnológico
                            ctx.strokeStyle = "#333";
                            ctx.lineWidth = 0.5;
                            for(let i=0; i<canvas.width; i+=50) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); ctx.stroke(); }
                            for(let i=0; i<canvas.height; i+=50) { ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(canvas.width,i); ctx.stroke(); }

                            // Actualizar posiciones y dibujar conexiones
                            nodes.forEach((node, i) => {
                                node.x += node.vx;
                                node.y += node.vy;
                                
                                // Rebote bordes
                                if(node.x < 0 || node.x > canvas.width) node.vx *= -1;
                                if(node.y < 0 || node.y > canvas.height) node.vy *= -1;
                                
                                // Dibujar conexiones (Edges) si están cerca (Overlap simulado)
                                nodes.forEach((other, j) => {
                                    if(i !== j) {
                                        const dx = node.x - other.x;
                                        const dy = node.y - other.y;
                                        const dist = Math.sqrt(dx*dx + dy*dy);
                                        
                                        if(dist < 100) {
                                            ctx.beginPath();
                                            ctx.moveTo(node.x, node.y);
                                            ctx.lineTo(other.x, other.y);
                                            // Color basado en distancia (más fuerte si cerca)
                                            ctx.strokeStyle = `rgba(100, 255, 218, ${1 - dist/100})`;
                                            ctx.lineWidth = 1;
                                            ctx.stroke();
                                        }
                                    }
                                });
                            });
                            
                            // Dibujar nodos encima de las líneas
                            nodes.forEach(node => {
                                ctx.beginPath();
                                ctx.arc(node.x, node.y, node.radius, 0, Math.PI*2);
                                ctx.fillStyle = node.color;
                                ctx.fill();
                                ctx.strokeStyle = "white";
                                ctx.lineWidth = 1;
                                ctx.stroke();
                                
                                // Texto k-mer (si zoom es alto)
                                if (complexity > 3) {
                                    ctx.fillStyle = "#fff";
                                    ctx.font = "10px monospace";
                                    ctx.fillText(node.seq, node.x + 8, node.y + 3);
                                }
                            });
                            
                            if(document.body.contains(canvas)) requestAnimationFrame(animateGraph);
                        };
                        animateGraph();
                        
                        // Panel Info Ensamblaje
                        const infoDiv = document.createElement('div');
                        infoDiv.style.cssText = `width: 95%; max-width: 800px; padding: 15px; background: #e3f2fd; border-left: 5px solid #2196F3; border-radius: 4px; font-size: 0.9rem; color: #0d47a1; flex-shrink: 0;`;
                        infoDiv.innerHTML = "<b>Estado del Ensamblaje:</b> Resolviendo burbujas y puntas muertas. Los nodos representan k-mers únicos; las líneas brillantes indican caminos de alta cobertura confirmados.";
                        div.appendChild(infoDiv);

                    } else if (p.viz_type.includes('Circular')) {
                        // === 2. MODO CIRCOS (ANIMACIÓN RADIAL) ===
                        
                        const container = document.createElement('div');
                        container.style.cssText = `width: 600px; height: 600px; position: relative; flex-shrink: 0; margin-bottom: 30px;`;
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = 600; canvas.height = 600;
                        container.appendChild(canvas);
                        div.appendChild(container);
                        
                        const ctx = canvas.getContext('2d');
                        const cx = 300, cy = 300;
                        const radius = 250;
                        
                        // Generar datos de cromosomas
                        const numChrs = 12; // Simplificado para visualización clara
                        const chrs = [];
                        const gap = 0.05;
                        const totalAngle = Math.PI * 2 - (gap * numChrs);
                        const anglePerChr = totalAngle / numChrs;
                        
                        let currentAngle = -Math.PI/2;
                        for(let i=0; i<numChrs; i++) {
                            chrs.push({
                                id: `chr${i+1}`,
                                start: currentAngle,
                                end: currentAngle + anglePerChr,
                                color: i % 2 === 0 ? "#34495e" : "#95a5a6"
                            });
                            currentAngle += anglePerChr + gap;
                        }
                        
                        let frame = 0;
                        const drawCircos = () => {
                            ctx.clearRect(0,0,600,600);
                            
                            // 1. Ideogramas (Outer Ring)
                            const progress = Math.min(1, frame / 100); // Animación 0 a 1
                            
                            chrs.forEach(chr => {
                                // Dibujar solo hasta donde llegue el progreso
                                const chrLen = chr.end - chr.start;
                                const drawEnd = chr.start + chrLen * progress;
                                
                                if (progress > 0) {
                                    ctx.beginPath();
                                    ctx.arc(cx, cy, radius, chr.start, drawEnd);
                                    ctx.arc(cx, cy, radius - 20, drawEnd, chr.start, true);
                                    ctx.closePath();
                                    ctx.fillStyle = chr.color;
                                    ctx.fill();
                                    ctx.strokeStyle = "white";
                                    ctx.lineWidth = 2;
                                    ctx.stroke();
                                    
                                    // Etiquetas
                                    if(progress > 0.8) {
                                        const mid = (chr.start + chr.end)/2;
                                        const lx = cx + Math.cos(mid) * (radius + 25);
                                        const ly = cy + Math.sin(mid) * (radius + 25);
                                        ctx.fillStyle = "#333";
                                        ctx.font = "bold 12px sans-serif";
                                        ctx.textAlign = "center";
                                        ctx.textBaseline = "middle";
                                        ctx.fillText(chr.id, lx, ly);
                                    }
                                }
                            });
                            
                            // 2. Track Datos (Heatmap interno)
                            if (frame > 50) {
                                const innerR = radius - 25;
                                const trackW = 30;
                                const trackProgress = Math.min(1, (frame - 50) / 50);
                                
                                chrs.forEach(chr => {
                                    const chrLen = chr.end - chr.start;
                                    const steps = 10;
                                    const stepAngle = chrLen / steps;
                                    
                                    for(let j=0; j<steps; j++) {
                                        const startA = chr.start + j*stepAngle;
                                        const endA = startA + stepAngle;
                                        
                                        // Animar aparición radial
                                        if ((j/steps) < trackProgress) {
                                            const val = Math.random();
                                            // Heatmap Rojo (Alto) - Azul (Bajo)
                                            const r = Math.floor(val * 255);
                                            const b = Math.floor((1-val) * 255);
                                            
                                            ctx.beginPath();
                                            ctx.arc(cx, cy, innerR, startA, endA);
                                            ctx.arc(cx, cy, innerR - trackW, endA, startA, true);
                                            ctx.fillStyle = `rgb(${r}, 0, ${b})`;
                                            ctx.fill();
                                        }
                                    }
                                });
                            }
                            
                            // 3. Links (Translocaciones)
                            if (frame > 100) {
                                const linkAlpha = Math.min(1, (frame - 100) / 50);
                                ctx.globalAlpha = linkAlpha;
                                ctx.lineWidth = 2;
                                
                                // Función Curva Bezier
                                const drawLink = (idx1, idx2, color) => {
                                    const c1 = chrs[idx1];
                                    const c2 = chrs[idx2];
                                    const a1 = (c1.start + c1.end)/2;
                                    const a2 = (c2.start + c2.end)/2;
                                    const rLink = radius - 60;
                                    
                                    const x1 = cx + Math.cos(a1) * rLink;
                                    const y1 = cy + Math.sin(a1) * rLink;
                                    const x2 = cx + Math.cos(a2) * rLink;
                                    const y2 = cy + Math.sin(a2) * rLink;
                                    
                                    const cp1x = cx + Math.cos(a1) * (rLink/3);
                                    const cp1y = cy + Math.sin(a1) * (rLink/3);
                                    const cp2x = cx + Math.cos(a2) * (rLink/3);
                                    const cp2y = cy + Math.sin(a2) * (rLink/3);
                                    
                                    ctx.beginPath();
                                    ctx.moveTo(x1, y1);
                                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
                                    ctx.strokeStyle = color;
                                    ctx.stroke();
                                };
                                
                                // Dibujar algunos links aleatorios estéticos
                                drawLink(0, 5, "#e74c3c"); // Translocación roja
                                drawLink(2, 8, "#3498db"); // Translocación azul
                                drawLink(10, 1, "#f1c40f"); // Translocación amarilla
                                
                                ctx.globalAlpha = 1;
                            }
                            
                            frame++;
                            if (frame < 200) requestAnimationFrame(drawCircos);
                        };
                        drawCircos();

                    } else {
                        // === 3. MODO IDEOGRAMA (KARYOPLOTER - VISTA LINEAL) ===
                        
                        const container = document.createElement('div');
                        container.style.cssText = `width: 95%; max-width: 800px; background: white; border-radius: 8px; padding: 30px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 25px; flex-shrink: 0;`;
                        
                        // Título
                        container.innerHTML = `<h3 style="text-align:center; color:#333; margin-bottom:10px;">Visualización Lineal (KaryoploteR) - Cromosomas 1-3</h3>`;
                        
                        // Función para dibujar un cromosoma
                        const createChr = (name, lengthPct, color) => {
                            const row = document.createElement('div');
                            row.style.cssText = `width: 100%; position: relative; margin-bottom: 10px;`;
                            
                            // Etiqueta
                            const label = document.createElement('div');
                            label.textContent = name;
                            label.style.cssText = `font-weight: bold; margin-bottom: 5px; color: #555;`;
                            row.appendChild(label);
                            
                            // Contenedor gráfico
                            const plotArea = document.createElement('div');
                            plotArea.style.cssText = `width: 100%; height: 60px; position: relative;`;
                            
                            // 1. Barra Cromosoma (Ideograma con bandas)
                            const ideogram = document.createElement('div');
                            ideogram.style.cssText = `
                                width: ${lengthPct}%; height: 15px; 
                                background: linear-gradient(90deg, #ddd 0%, #fff 10%, #555 20%, #fff 30%, #555 40%, #ddd 100%);
                                border-radius: 10px; border: 1px solid #999;
                                position: absolute; bottom: 0; left: 0;
                                box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
                            `;
                            plotArea.appendChild(ideogram);
                            
                            // 2. Data Track (Picos encima) - Simulación ChIP-seq
                            const dataTrack = document.createElement('div');
                            dataTrack.style.cssText = `position: absolute; bottom: 18px; left: 0; width: ${lengthPct}%; height: 40px; display: flex; align-items: flex-end;`;
                            
                            const numBars = 50;
                            for(let i=0; i<numBars; i++) {
                                const bar = document.createElement('div');
                                // Altura aleatoria simulando picos
                                let h = Math.random() * 100;
                                // Hacer picos en clusters
                                if (Math.abs(i - 25) < 5) h = 80 + Math.random()*20; // Pico central grande
                                else if (Math.random() > 0.8) h = 50 + Math.random()*20; // Ruido
                                else h = Math.random() * 15; // Fondo
                                
                                bar.style.cssText = `
                                    flex: 1; margin: 0 1px; background: ${color}; 
                                    height: 0%; transition: height 0.5s ease-out ${i*0.02}s;
                                    opacity: 0.8; border-radius: 2px 2px 0 0;
                                `;
                                // Trigger animación
                                setTimeout(() => bar.style.height = `${h}%`, 100);
                                dataTrack.appendChild(bar);
                            }
                            plotArea.appendChild(dataTrack);
                            row.appendChild(plotArea);
                            return row;
                        };
                        
                        container.appendChild(createChr("Chr 1", 100, "#e74c3c")); // Rojo
                        container.appendChild(createChr("Chr 2", 90, "#3498db"));  // Azul
                        container.appendChild(createChr("Chr 3", 80, "#2ecc71"));  // Verde
                        
                        div.appendChild(container);
                        
                        // Leyenda
                        const legend = document.createElement('div');
                        legend.style.cssText = `display:flex; justify-content:center; gap:20px; font-size:0.9rem; color:#666; margin-top:10px; width:100%; flex-shrink:0;`;
                        legend.innerHTML = `
                            <span><span style="display:inline-block;width:12px;height:12px;background:#e74c3c"></span> ChIP-seq (Picos)</span>
                            <span><span style="display:inline-block;width:30px;height:10px;background:linear-gradient(90deg, #fff, #555);border:1px solid #999"></span> Bandas Giemsa</span>
                        `;
                        div.appendChild(legend);
                    }
                }
            },
            {
                id: 6,
                title: "Tema 6. Análisis de Expresión Diferencial",
                desc: "RNA-seq y expresión génica diferencial",
                icon: "fa-chart-line",
                controls: [
                    {id: 'method', type: 'select', label: 'Método', options: ['DESeq2', 'edgeR', 'limma-voom']},
                    {id: 'foldchange', type: 'range', label: 'Umbral Log2FC', min: 0.5, max: 3, step: 0.1, val: 1}
                ],
                // CÓDIGO R COMPLETO Y ESTILIZADO (ORIGINAL MEJORADO)
                code: (p) => `
<span class="c-com"># ANÁLISIS DE EXPRESIÓN DIFERENCIAL - ${(p.method || 'DESEQ2').toUpperCase()}</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(${p.method || 'DESeq2'})
<span class="c-kwd">library</span>(ggplot2)
<span class="c-kwd">library</span>(pheatmap)

<span class="c-com"># Configurar parámetros</span>
de_method <- <span class="c-str">"${p.method || 'DESeq2'}"</span>
fc_threshold <- <span class="c-num">${p.foldchange || 1}</span>

<span class="c-com"># Simular datos de expresión</span>
<span class="c-kwd">set.seed</span>(123)
n_genes <- <span class="c-num">1000</span>
n_samples <- <span class="c-num">12</span>

<span class="c-com"># Crear matriz de conteos</span>
counts_matrix <- <span class="c-fn">matrix</span>(
  <span class="c-fn">rnbinom</span>(n_genes * n_samples, mu=1000, size=0.1),
  nrow=n_genes, ncol=n_samples
)

<span class="c-com"># Asignar condiciones (6 control, 6 tratamiento)</span>
colnames(counts_matrix) <- <span class="c-fn">paste0</span>(
  <span class="c-fn">rep</span>(<span class="c-str">"Sample"</span>, n_samples),
  <span class="c-fn">sprintf</span>(<span class="c-str">"%02d"</span>, 1:n_samples)
)
rownames(counts_matrix) <- <span class="c-fn">paste0</span>(<span class="c-str">"Gene_"</span>, 1:n_genes)

condition <- <span class="c-fn">factor</span>(
  <span class="c-fn">c</span>(<span class="c-fn">rep</span>(<span class="c-str">"Control"</span>, n_samples/2), 
    <span class="c-fn">rep</span>(<span class="c-str">"Treatment"</span>, n_samples/2))
)

<span class="c-com"># Simular genes diferencialmente expresados (5%)</span>
n_de <- <span class="c-num">50</span>
de_indices <- <span class="c-fn">sample</span>(1:n_genes, n_de)
<span class="c-kwd">for</span> (i <span class="c-kwd">in</span> de_indices) {
  counts_matrix[i, (n_samples/2 + 1):n_samples] <- 
    counts_matrix[i, (n_samples/2 + 1):n_samples] * <span class="c-fn">sample</span>(<span class="c-fn">c</span>(0.5, 2, 4), 1)
}

<span class="c-com"># Análisis con el método seleccionado</span>
<span class="c-kwd">if</span> (de_method == <span class="c-str">"DESeq2"</span>) {
  <span class="c-com"># Análisis con DESeq2</span>
  col_data <- <span class="c-fn">data.frame</span>(condition = condition)
  rownames(col_data) <- colnames(counts_matrix)
  
  dds <- <span class="c-fn">DESeqDataSetFromMatrix</span>(
    countData = counts_matrix,
    colData = col_data,
    design = ~ condition
  )
  
  dds <- <span class="c-fn">DESeq</span>(dds)
  res <- <span class="c-fn">results</span>(dds, contrast=<span class="c-str">"condition_Treatment_vs_Control"</span>)
  res_df <- <span class="c-fn">as.data.frame</span>(res)
  
} <span class="c-kwd">else if</span> (de_method == <span class="c-str">"edgeR"</span>) {
  <span class="c-com"># Análisis con edgeR</span>
  dge <- <span class="c-fn">DGEList</span>(counts=counts_matrix, group=condition)
  dge <- <span class="c-fn">calcNormFactors</span>(dge)
  design <- <span class="c-fn">model.matrix</span>(~condition)
  dge <- <span class="c-fn">estimateDisp</span>(dge, design)
  fit <- <span class="c-fn">glmQLFit</span>(dge, design)
  qlf <- <span class="c-fn">glmQLFTest</span>(fit, coef=2)
  res_df <- <span class="c-fn">topTags</span>(qlf, n=n_genes)<span class="c-var">$table</span>
  
} <span class="c-kwd">else</span> {
  <span class="c-com"># Análisis con limma-voom</span>
  dge <- <span class="c-fn">DGEList</span>(counts=counts_matrix)
  dge <- <span class="c-fn">calcNormFactors</span>(dge)
  design <- <span class="c-fn">model.matrix</span>(~condition)
  v <- <span class="c-fn">voom</span>(dge, design, plot=FALSE)
  fit <- <span class="c-fn">lmFit</span>(v, design)
  fit <- <span class="c-fn">eBayes</span>(fit)
  res_df <- <span class="c-fn">topTable</span>(fit, coef=2, n=n_genes)
}

<span class="c-com"># Identificar genes significativos</span>
res_df<span class="c-var">$significant</span> <- <span class="c-fn">abs</span>(res_df<span class="c-var">$logFC</span>) > fc_threshold & 
                          res_df<span class="c-var">$adj.P.Val</span> < 0.05

<span class="c-com"># Volcano plot</span>
ggplot(res_df, <span class="c-fn">aes</span>(x=logFC, y=-log10(adj.P.Val), color=significant)) +
  <span class="c-fn">geom_point</span>(alpha=0.6, size=1.5) +
  <span class="c-fn">scale_color_manual</span>(values=<span class="c-fn">c</span>(<span class="c-str">"gray"</span>, <span class="c-str">"red"</span>)) +
  <span class="c-fn">geom_vline</span>(xintercept=<span class="c-fn">c</span>(-fc_threshold, fc_threshold), 
               linetype=<span class="c-str">"dashed"</span>, color=<span class="c-str">"blue"</span>) +
  <span class="c-fn">geom_hline</span>(yintercept=-log10(0.05), 
               linetype=<span class="c-str">"dashed"</span>, color=<span class="c-str">"blue"</span>) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">ggtitle</span>(<span class="c-str">"Volcano Plot - Expresión Diferencial"</span>,
          subtitle = <span class="c-fn">paste</span>(<span class="c-str">"Método:"</span>, de_method, 
                         <span class="c-str">"| Log2FC >"</span>, fc_threshold)) +
  <span class="c-fn">xlab</span>(<span class="c-str">"Log2 Fold Change"</span>) +
  <span class="c-fn">ylab</span>(<span class="c-str">"-log10(adj.P.Val)"</span>)

<span class="c-com"># Resumen estadístico</span>
n_sig <- <span class="c-fn">sum</span>(res_df<span class="c-var">$significant</span>, na.rm=TRUE)
n_up <- <span class="c-fn">sum</span>(res_df<span class="c-var">$significant</span> & res_df<span class="c-var">$logFC</span> > 0, na.rm=TRUE)
n_down <- <span class="c-fn">sum</span>(res_df<span class="c-var">$significant</span> & res_df<span class="c-var">$logFC</span> < 0, na.rm=TRUE)

<span class="c-fn">cat</span>(<span class="c-str">"\\n=== RESUMEN DE EXPRESIÓN DIFERENCIAL ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Método:"</span>, de_method, <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Total genes analizados:"</span>, n_genes, <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Genes significativos:"</span>, n_sig, 
    <span class="c-str">"("</span>, <span class="c-fn">round</span>(n_sig/n_genes*100, 1), <span class="c-str">"%)"</span>, <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"  - Sobre-expresados:"</span>, n_up, <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"  - Sub-expresados:"</span>, n_down, <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Umbral Log2FC:"</span>, fc_threshold, <span class="c-str">"\\n"</span>)`,
                
                explain: (p) => `
                    <div class="exp-highlight">
                        <b>📈 Análisis de Expresión Diferencial (RNA-seq)</b>
                        <p>Identificación de genes cuya expresión cambia significativamente entre condiciones experimentales.</p>
                    </div>
                    <p><b>Método seleccionado: ${p.method || 'DESeq2'}</b></p>
                    <p><b>Principios estadísticos:</b></p>
                    <ul>
                        <li>🎯 Modelado de datos de conteo (distribución binomial negativa)</li>
                        <li>📊 Normalización por tamaño de biblioteca</li>
                        <li>🧪 Corrección por pruebas múltiples (FDR)</li>
                        <li>📈 Análisis de sobredispersión</li>
                    </ul>
                    <p><b>Umbrales de significancia:</b></p>
                    <ul>
                        <li>📏 Fold Change (FC): Cambio en expresión (Log2FC = ${p.foldchange || 1})</li>
                        <li>🎯 Valor p ajustado: FDR < 0.05</li>
                        <li>📊 Tamaño de efecto: Magnitud del cambio biológico</li>
                    </ul>
                    <div class="exp-note">
                        <i class="fas fa-lightbulb"></i> <b>Interpretación de resultados:</b>
                        <p>• Genes con Log2FC > ${p.foldchange || 1}: Sobre-expresados en tratamiento</p>
                        <p>• Genes con Log2FC < -${p.foldchange || 1}: Sub-expresados en tratamiento</p>
                        <p>• Valor p ajustado < 0.05: Significancia estadística después de corrección</p>
                    </div>`,
                
                render: (p, div) => {
                    // --- ARREGLO DE LAYOUT (Estilo "Estadística") ---
                    // Se usa flex-start y overflow-auto para permitir scroll
                    // y que el contenido no se corte ni arriba ni abajo.
                    div.style.cssText = ""; // Reset previo
                    
                    div.style.width = "100%";
                    div.style.height = "100%";
                    div.style.display = "flex";
                    div.style.flexDirection = "column";
                    div.style.alignItems = "center";
                    div.style.justifyContent = "flex-start"; // CLAVE: Alineación superior
                    div.style.padding = "20px";
                    div.style.overflowY = "auto";            // CLAVE: Scroll vertical activado
                    div.style.boxSizing = "border-box";
                    
                    div.innerHTML = '';
                    
                    const threshold = p.foldchange || 1;

                    // 1. GRÁFICO VOLCANO (Extenso y detallado)
                    const volcanoPlot = document.createElement('div');
                    volcanoPlot.style.cssText = `
                        width: 95%; 
                        max-width: 650px; 
                        height: 400px;
                        min-height: 400px;
                        background: white; 
                        border-radius: 10px; 
                        padding: 20px; 
                        position: relative; 
                        animation: fadeIn 0.5s ease-out;
                        flex-shrink: 0;
                        box-shadow: 0 4px 10px rgba(0,0,0,0.1);
                        border: 1px solid #eee;
                    `;
                    
                    // Etiquetas de ejes más profesionales
                    const xLabel = document.createElement('div');
                    xLabel.textContent = `Log2 Fold Change (Umbral: ${threshold})`;
                    xLabel.style.cssText = `position: absolute; bottom: 10px; left: 0; width: 100%; text-align: center; font-size: 0.85rem; color: #666; font-weight: 500;`;
                    volcanoPlot.appendChild(xLabel);

                    const yLabel = document.createElement('div');
                    yLabel.textContent = "-Log10 P-value";
                    yLabel.style.cssText = `position: absolute; top: 50%; left: -20px; transform: translateY(-50%) rotate(-90deg); font-size: 0.85rem; color: #666; font-weight: 500;`;
                    volcanoPlot.appendChild(yLabel);

                    // Ejes
                    const axisX = document.createElement('div');
                    axisX.style.cssText = `position: absolute; bottom: 40px; left: 50px; right: 20px; height: 2px; background: #333;`;
                    const axisY = document.createElement('div');
                    axisY.style.cssText = `position: absolute; top: 20px; bottom: 40px; left: 50px; width: 2px; background: #333;`;
                    volcanoPlot.appendChild(axisX);
                    volcanoPlot.appendChild(axisY);
                    
                    // Generar puntos (Simulación enriquecida)
                    // Usamos más puntos para dar sensación de "Big Data"
                    const nPoints = 250;
                    for(let i = 0; i < nPoints; i++) {
                        const point = document.createElement('div');
                        
                        // Distribución simulada realista
                        let logFC = (Math.random() - 0.5) * 8; // Rango más amplio -4 a 4
                        let pValue = Math.pow(Math.random(), 2); // Sesgado a 0
                        
                        // Forzar algunos significativos claros
                        if (i % 20 === 0) {
                            logFC = (Math.random() > 0.5 ? 1 : -1) * (threshold + Math.random() * 2);
                            pValue = 0.0001; 
                        }

                        const isSig = Math.abs(logFC) > threshold && pValue < 0.05;
                        const isUp = logFC > threshold && pValue < 0.05;
                        const isDown = logFC < -threshold && pValue < 0.05;
                        
                        // Posicionamiento porcentual
                        // Eje X: -4 a 4 -> 0% a 100%
                        const xPct = 10 + ((logFC + 4) / 8) * 85; 
                        // Eje Y: 0 a 5 (log scale)
                        const logP = -Math.log10(pValue);
                        const yPct = 90 - (Math.min(logP, 5) / 5) * 85;
                        
                        const color = isUp ? '#e74c3c' : (isDown ? '#3498db' : '#95a5a6');
                        const size = isSig ? 7 : 4;
                        const opacity = isSig ? 0.9 : 0.5;
                        
                        point.style.cssText = `
                            position: absolute;
                            width: ${size}px; height: ${size}px;
                            border-radius: 50%;
                            left: ${xPct}%; top: ${yPct}%;
                            background: ${color};
                            transform: translate(-50%, -50%);
                            animation: fadeIn 0.5s ease-out ${i * 0.002}s forwards;
                            opacity: 0;
                            z-index: ${isSig ? 10 : 1};
                            cursor: pointer;
                            transition: transform 0.2s;
                        `;
                        
                        // Interactividad: Tooltip nativo
                        point.title = `Gene_${i}\nLog2FC: ${logFC.toFixed(2)}\nP-val: ${pValue.toExponential(2)}`;
                        point.onmouseover = () => { point.style.transform = 'translate(-50%, -50%) scale(1.5)'; point.style.zIndex = 100; };
                        point.onmouseout = () => { point.style.transform = 'translate(-50%, -50%) scale(1)'; point.style.zIndex = isSig ? 10 : 1; };
                        
                        volcanoPlot.appendChild(point);
                    }
                    
                    // Líneas de umbral (dinámicas y suaves)
                    const lineStyle = `position: absolute; top: 20px; bottom: 40px; width: 1px; border-left: 2px dashed #2ecc71; opacity: 0.6; transition: left 0.4s ease; pointer-events: none;`;
                    
                    const rightPos = 10 + ((threshold + 4) / 8) * 85;
                    const leftPos = 10 + ((-threshold + 4) / 8) * 85;
                    
                    const l1 = document.createElement('div'); l1.style.cssText = `${lineStyle} left: ${rightPos}%; border-color: #e74c3c;`;
                    const l2 = document.createElement('div'); l2.style.cssText = `${lineStyle} left: ${leftPos}%; border-color: #3498db;`;
                    
                    // Línea P-value
                    const pLine = document.createElement('div');
                    const pY = 90 - (-Math.log10(0.05) / 5) * 85;
                    pLine.style.cssText = `position: absolute; left: 50px; right: 20px; top: ${pY}%; height: 1px; border-top: 2px dashed #666; opacity: 0.4;`;
                    
                    volcanoPlot.appendChild(l1); 
                    volcanoPlot.appendChild(l2);
                    volcanoPlot.appendChild(pLine);
                    div.appendChild(volcanoPlot);
                    
                    // 2. TARJETAS DE ESTADÍSTICAS (Diseño mejorado)
                    const statsDiv = document.createElement('div');
                    statsDiv.style.cssText = `width: 95%; max-width: 650px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 20px; flex-shrink: 0;`;
                    
                    // Cálculo dinámico simulado más realista
                    const baseSig = 150;
                    const sigCount = Math.max(10, Math.floor(baseSig / (threshold * 1.5))); 
                    const upCount = Math.floor(sigCount * 0.55);
                    const downCount = sigCount - upCount;
                    
                    const cards = [
                        {title: "Total Significativos", val: sigCount, color: "#2c3e50", icon: "fa-dna"},
                        {title: "Up-Regulated", val: upCount, color: "#e74c3c", icon: "fa-arrow-up"},
                        {title: "Down-Regulated", val: downCount, color: "#3498db", icon: "fa-arrow-down"}
                    ];
                    
                    cards.forEach((c, idx) => {
                        const card = document.createElement('div');
                        card.style.cssText = `
                            background: white; border-radius: 12px; padding: 15px; 
                            text-align: center; border-bottom: 4px solid ${c.color};
                            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
                            animation: fadeIn 0.6s ease-out ${0.2 + idx*0.1}s forwards; opacity: 0;
                            display: flex; flex-direction: column; align-items: center; justify-content: center;
                        `;
                        card.innerHTML = `
                            <i class="fas ${c.icon}" style="color: ${c.color}; font-size: 1.2rem; margin-bottom: 8px;"></i>
                            <div style="font-size: 0.8rem; color: #7f8c8d; font-weight: 600; text-transform: uppercase;">${c.title}</div>
                            <div style="font-size: 1.8rem; font-weight: 700; color: ${c.color};">${c.val}</div>
                            <div style="font-size: 0.7rem; color: #bdc3c7;">${((c.val/1000)*100).toFixed(1)}% del genoma</div>
                        `;
                        statsDiv.appendChild(card);
                    });
                    div.appendChild(statsDiv);
                    
                    // 3. HEATMAP PROFESIONAL (Grid detallado)
                    const heatDiv = document.createElement('div');
                    heatDiv.style.cssText = `
                        width: 95%; max-width: 650px; background: white; border-radius: 12px; padding: 25px;
                        box-shadow: 0 4px 15px rgba(0,0,0,0.08); flex-shrink: 0; margin-bottom: 40px;
                    `;
                    
                    heatDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <span style="font-weight: 700; color: #2c3e50; font-size: 1rem;"><i class="fas fa-th"></i> Heatmap de Expresión</span>
                            <span style="font-size: 0.8rem; color: #7f8c8d;">Top 50 Genes Diferenciales</span>
                        </div>
                    `;
                    
                    const grid = document.createElement('div');
                    grid.style.cssText = `display: flex; height: 250px; gap: 2px; border: 1px solid #eee; padding: 2px;`;
                    
                    // Columnas (Muestras)
                    for(let c=0; c<12; c++) {
                        const col = document.createElement('div');
                        col.style.cssText = `flex: 1; display: flex; flex-direction: column; gap: 1px;`;
                        
                        // Filas (Genes)
                        for(let r=0; r<50; r++) {
                            const cell = document.createElement('div');
                            // Patrón biológico: Genes Up (mitad superior) altos en Tratamiento (cols 6-11)
                            const isTreat = c >= 6;
                            const isUpGene = r < 25;
                            
                            let intensity;
                            if (isUpGene) {
                                intensity = isTreat ? 0.7 + Math.random()*0.3 : 0.2 + Math.random()*0.3;
                            } else {
                                intensity = isTreat ? 0.2 + Math.random()*0.3 : 0.7 + Math.random()*0.3;
                            }
                            
                            // Color scale: Azul (bajo) -> Blanco -> Rojo (alto)
                            let bg;
                            if (intensity < 0.5) {
                                // Azul a Blanco
                                const val = Math.floor(intensity * 2 * 255);
                                bg = `rgb(${val}, ${val}, 255)`;
                            } else {
                                // Blanco a Rojo
                                const val = Math.floor((1 - (intensity - 0.5) * 2) * 255);
                                bg = `rgb(255, ${val}, ${val})`;
                            }
                            
                            cell.style.cssText = `flex: 1; background: ${bg}; transition: opacity 0.2s;`;
                            cell.onmouseover = () => { cell.style.opacity = 0.5; };
                            cell.onmouseout = () => { cell.style.opacity = 1; };
                            col.appendChild(cell);
                        }
                        
                        // Etiqueta columna
                        const colLabel = document.createElement('div');
                        colLabel.textContent = isTreat ? 'T' : 'C';
                        colLabel.style.cssText = `text-align: center; font-size: 9px; color: #666; margin-top: 4px;`;
                        col.appendChild(colLabel);
                        
                        grid.appendChild(col);
                    }
                    heatDiv.appendChild(grid);
                    
                    // Leyenda Heatmap
                    const legend = document.createElement('div');
                    legend.style.cssText = `display: flex; justify-content: center; align-items: center; gap: 15px; margin-top: 15px; font-size: 0.8rem; color: #666;`;
                    legend.innerHTML = `
                        <div style="display:flex; align-items:center; gap:5px;"><span style="width:12px; height:12px; background:blue;"></span> Bajo</div>
                        <div style="display:flex; align-items:center; gap:5px;"><span style="width:12px; height:12px; background:white; border:1px solid #eee;"></span> Medio</div>
                        <div style="display:flex; align-items:center; gap:5px;"><span style="width:12px; height:12px; background:red;"></span> Alto</div>
                    `;
                    heatDiv.appendChild(legend);
                    
                    div.appendChild(heatDiv);
                    
                    // Botón continuar
                    setTimeout(() => {
                        const btn = document.getElementById('continueBtn');
                        if(btn) {
                            btn.style.display = 'block';
                            btn.scrollIntoView({behavior: "smooth"}); // Scroll automático hacia el botón
                        }
                    }, 2500);
                }
            },
            {
                id: 7,
                title: "Tema 7. Metagenómica y Microbioma",
                desc: "Análisis de comunidades: Diversidad Alfa, Beta y Biomarcadores",
                icon: "fa-users",
                controls: [
                    {id: 'analysis_type', type: 'select', label: 'Tipo de Análisis', options: ['Diversidad Beta (PCoA)', 'Diversidad Alfa', 'Composición (Taxonomía)', 'Biomarcadores (LEfSe)']}
                ],
                // CÓDIGO R BASADO EN TU INPUT (CORREGIDO Y FORMATEADO)
                code: (p) => {
                    const type = p.analysis_type.split(' ')[0]; // Beta, Alfa, Composición, Biomarcadores
                    
                    let specificCode = "";
                    
                    if (p.analysis_type.includes("Alfa")) {
                        specificCode = `
<span class="c-kwd">if</span> (analysis_type == <span class="c-str">"Diversidad Alfa"</span>) {
  <span class="c-com"># Calcular índices ecológicos</span>
  alpha_div <span class="c-op"><-</span> <span class="c-fn">data.frame</span>(
    <span class="c-arg">Sample</span> = metadata$Sample,
    <span class="c-arg">Group</span> = metadata$Group,
    <span class="c-arg">Shannon</span> = vegan::<span class="c-fn">diversity</span>(<span class="c-fn">t</span>(otu_table), <span class="c-arg">index</span>=<span class="c-str">"shannon"</span>),
    <span class="c-arg">Simpson</span> = vegan::<span class="c-fn">diversity</span>(<span class="c-fn">t</span>(otu_table), <span class="c-arg">index</span>=<span class="c-str">"simpson"</span>),
    <span class="c-arg">Observed</span> = <span class="c-fn">colSums</span>(otu_table > 0)
  )
  
  <span class="c-com"># Visualización (Boxplot)</span>
  alpha_melt <span class="c-op"><-</span> reshape2::<span class="c-fn">melt</span>(alpha_div, <span class="c-arg">id.vars</span>=<span class="c-fn">c</span>(<span class="c-str">"Sample"</span>, <span class="c-str">"Group"</span>))
  
  <span class="c-fn">ggplot</span>(alpha_melt, <span class="c-fn">aes</span>(<span class="c-arg">x</span>=Group, <span class="c-arg">y</span>=value, <span class="c-arg">fill</span>=Group)) +
    <span class="c-fn">geom_boxplot</span>(<span class="c-arg">alpha</span>=0.7) +
    <span class="c-fn">facet_wrap</span>(~variable, <span class="c-arg">scales</span>=<span class="c-str">"free_y"</span>) +
    <span class="c-fn">theme_minimal</span>() +
    <span class="c-fn">ggtitle</span>(<span class="c-str">"Diversidad Alfa por Grupo"</span>)
}`;
                    } else if (p.analysis_type.includes("Beta")) {
                        specificCode = `
<span class="c-kwd">else if</span> (analysis_type == <span class="c-str">"Diversidad Beta"</span>) {
  <span class="c-com"># Matriz de distancia (Bray-Curtis)</span>
  dist_matrix <span class="c-op"><-</span> vegan::<span class="c-fn">vegdist</span>(<span class="c-fn">t</span>(otu_table), <span class="c-arg">method</span>=<span class="c-str">"bray"</span>)
  
  <span class="c-com"># Ordenación PCoA (Principal Coordinates Analysis)</span>
  pcoa <span class="c-op"><-</span> <span class="c-fn">cmdscale</span>(dist_matrix, <span class="c-arg">k</span>=2, <span class="c-arg">eig</span>=<span class="c-kwd">TRUE</span>)
  
  pcoa_df <span class="c-op"><-</span> <span class="c-fn">data.frame</span>(
    <span class="c-arg">Sample</span> = metadata$Sample,
    <span class="c-arg">Group</span> = metadata$Group,
    <span class="c-arg">PC1</span> = pcoa$points[,1],
    <span class="c-arg">PC2</span> = pcoa$points[,2]
  )
  
  <span class="c-fn">ggplot</span>(pcoa_df, <span class="c-fn">aes</span>(<span class="c-arg">x</span>=PC1, <span class="c-arg">y</span>=PC2, <span class="c-arg">color</span>=Group)) +
    <span class="c-fn">geom_point</span>(<span class="c-arg">size</span>=3, <span class="c-arg">alpha</span>=0.8) +
    <span class="c-fn">stat_ellipse</span>(<span class="c-arg">level</span>=0.95) + <span class="c-com"># Elipses de confianza</span>
    <span class="c-fn">theme_minimal</span>() +
    <span class="c-fn">ggtitle</span>(<span class="c-str">"Análisis PCoA - Diversidad Beta"</span>)
}`;
                    } else if (p.analysis_type.includes("Composición")) {
                        specificCode = `
<span class="c-kwd">else if</span> (analysis_type == <span class="c-str">"Composición"</span>) {
  <span class="c-com"># Aglomerar abundancias por Filo</span>
  phylum_abundance <span class="c-op"><-</span> <span class="c-fn">aggregate</span>(
    <span class="c-fn">rowSums</span>(otu_table) ~ taxonomy$Phylum, 
    <span class="c-arg">FUN</span>=sum
  )
  <span class="c-fn">colnames</span>(phylum_abundance) <- <span class="c-fn">c</span>(<span class="c-str">"Phylum"</span>, <span class="c-str">"Abundance"</span>)
  
  <span class="c-com"># Calcular porcentajes</span>
  phylum_abundance$Percentage <- phylum_abundance$Abundance / 
                                 <span class="c-fn">sum</span>(phylum_abundance$Abundance) * 100
  
  <span class="c-fn">ggplot</span>(phylum_abundance, <span class="c-fn">aes</span>(<span class="c-arg">x</span>=<span class="c-str">""</span>, <span class="c-arg">y</span>=Percentage, <span class="c-arg">fill</span>=Phylum)) +
    <span class="c-fn">geom_bar</span>(<span class="c-arg">stat</span>=<span class="c-str">"identity"</span>, <span class="c-arg">width</span>=1) +
    <span class="c-fn">coord_polar</span>(<span class="c-str">"y"</span>, <span class="c-arg">start</span>=0) +
    <span class="c-fn">theme_void</span>() +
    <span class="c-fn">ggtitle</span>(<span class="c-str">"Composición del Microbioma por Filum"</span>)
}`;
                    } else {
                        specificCode = `
<span class="c-kwd">else</span> {
  <span class="c-fn">cat</span>(<span class="c-str">"\\n=== ANÁLISIS LEFSe (Biomarcadores) ===\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"Identificando taxones que explican diferencias entre grupos...\\n"</span>)
  
  <span class="c-com"># Simular resultados de Linear Discriminant Analysis</span>
  marker_taxa <span class="c-op"><-</span> <span class="c-fn">data.frame</span>(
    <span class="c-arg">Taxon</span> = <span class="c-fn">sample</span>(taxonomy$OTU, 15),
    <span class="c-arg">Group</span> = <span class="c-fn">sample</span>(<span class="c-fn">c</span>(<span class="c-str">"Healthy"</span>, <span class="c-str">"Disease_A"</span>), 15, <span class="c-arg">replace</span>=<span class="c-kwd">TRUE</span>),
    <span class="c-arg">LDA_Score</span> = <span class="c-fn">runif</span>(15, 2, 5),
    <span class="c-arg">p_Value</span> = <span class="c-fn">runif</span>(15, 0.001, 0.05)
  )
  
  <span class="c-fn">ggplot</span>(marker_taxa, <span class="c-fn">aes</span>(<span class="c-arg">x</span>=<span class="c-fn">reorder</span>(Taxon, LDA_Score), <span class="c-arg">y</span>=LDA_Score, <span class="c-arg">fill</span>=Group)) +
    <span class="c-fn">geom_bar</span>(<span class="c-arg">stat</span>=<span class="c-str">"identity"</span>) +
    <span class="c-fn">coord_flip</span>() +
    <span class="c-fn">theme_minimal</span>() +
    <span class="c-fn">ggtitle</span>(<span class="c-str">"Taxones Marcadores (LDA Score > 2)"</span>) +
    <span class="c-fn">xlab</span>(<span class="c-str">"Taxón"</span>) + <span class="c-fn">ylab</span>(<span class="c-str">"LDA Score (log10)"</span>)
}`;
                    }

                    return `
<span class="c-com"># CONFIGURACIÓN GENERAL (METADATA Y OTUs)</span>
<span class="c-kwd">library</span>(phyloseq); <span class="c-kwd">library</span>(vegan); <span class="c-kwd">library</span>(ggplot2)

<span class="c-com"># 1. Simulación de datos</span>
n_samples <- 20; n_taxa <- 100; n_groups <- 3
metadata <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">Sample</span> = <span class="c-fn">paste0</span>(<span class="c-str">"S_"</span>, 1:n_samples),
  <span class="c-arg">Group</span> = <span class="c-fn">rep</span>(<span class="c-fn">c</span>(<span class="c-str">"Healthy"</span>, <span class="c-str">"Disease_A"</span>, <span class="c-str">"Disease_B"</span>), <span class="c-arg">length.out</span>=n_samples)
)

<span class="c-com"># 2. Generar Tabla de OTUs (Cuenta negativa binomial)</span>
otu_table <- <span class="c-fn">matrix</span>(
  <span class="c-fn">rnbinom</span>(n_taxa * n_samples, <span class="c-arg">mu</span>=1000, <span class="c-arg">size</span>=0.5),
  <span class="c-arg">nrow</span>=n_taxa, <span class="c-arg">ncol</span>=n_samples
)

<span class="c-com"># 3. Asignar Taxonomía</span>
taxonomy <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">OTU</span> = <span class="c-fn">paste0</span>(<span class="c-str">"OTU_"</span>, 1:n_taxa),
  <span class="c-arg">Phylum</span> = <span class="c-fn">sample</span>(<span class="c-fn">c</span>(<span class="c-str">"Firmicutes"</span>, <span class="c-str">"Bacteroidetes"</span>, <span class="c-str">"Proteobacteria"</span>), n_taxa, <span class="c-arg">replace</span>=<span class="c-kwd">TRUE</span>)
)

<span class="c-com"># --- SELECCIÓN DE ANÁLISIS: ${p.analysis_type.toUpperCase()} ---</span>
${specificCode}`;
                },
                
                explain: (p) => {
                    const desc = {
                        'Diversidad Beta (PCoA)': 'Mide qué tan diferentes son las comunidades microbianas entre muestras. Usamos distancias (Bray-Curtis) y ordenación (PCoA). Los puntos cercanos indican microbiomas similares.',
                        'Diversidad Alfa': 'Mide la riqueza (cuántas especies) y equidad dentro de una sola muestra. Índices comunes: Shannon (equidad) y Chao1 (riqueza estimada).',
                        'Composición (Taxonomía)': 'Muestra la abundancia relativa de los diferentes grupos bacterianos (Filos). Un microbioma sano suele tener equilibrio entre Firmicutes y Bacteroidetes.',
                        'Biomarcadores (LEfSe)': 'Linear discriminant analysis Effect Size. Identifica qué bacterias explican estadísticamente la diferencia entre dos grupos (ej. Sano vs Enfermo).'
                    };
                    return `
                    <div class="exp-highlight">
                        <b>🦠 Metagenómica: ${p.analysis_type}</b>
                        <p>${desc[p.analysis_type]}</p>
                    </div>
                    <div class="exp-note">
                        <i class="fas fa-info-circle"></i> <b>Nota:</b> En el código R de arriba, simulamos una matriz de conteos usando una distribución binomial negativa, que es el modelo estándar para datos de secuenciación (RNA-seq / 16S).
                    </div>`;
                },
                
                render: (p, div) => {
                    // --- LAYOUT CORREGIDO (FLEX-START + SCROLL) ---
                    div.style.cssText = "";
                    div.style.width = "100%";
                    div.style.height = "100%";
                    div.style.display = "flex";
                    div.style.flexDirection = "column";
                    div.style.alignItems = "center";
                    div.style.justifyContent = "flex-start"; 
                    div.style.padding = "20px";
                    div.style.overflowY = "auto";
                    div.style.boxSizing = "border-box";
                    
                    div.innerHTML = '';

                    const type = p.analysis_type;

                    if (type.includes("Beta")) {
                        // === 1. SIMULACIÓN PCoA (Scatter Plot Dinámico) ===
                        const container = document.createElement('div');
                        container.style.cssText = `width: 95%; max-width: 700px; height: 450px; background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); position: relative; flex-shrink: 0;`;
                        
                        const title = document.createElement('div');
                        title.innerHTML = "<b>PCoA Plot (Bray-Curtis Distance)</b>";
                        title.style.cssText = "text-align: center; margin-bottom: 10px; color: #333;";
                        container.appendChild(title);
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = 650; canvas.height = 380;
                        container.appendChild(canvas);
                        div.appendChild(container);
                        
                        const ctx = canvas.getContext('2d');
                        const cx = canvas.width / 2;
                        const cy = canvas.height / 2;
                        
                        // Generar puntos (3 Grupos)
                        const groups = [
                            {name: "Healthy", color: "#2ecc71", cx: cx - 100, cy: cy + 50},
                            {name: "Disease A", color: "#e74c3c", cx: cx + 80, cy: cy - 60},
                            {name: "Disease B", color: "#3498db", cx: cx + 100, cy: cy + 80}
                        ];
                        
                        const points = [];
                        groups.forEach(g => {
                            for(let i=0; i<15; i++) {
                                // Destino final
                                const tx = g.cx + (Math.random()-0.5)*100;
                                const ty = g.cy + (Math.random()-0.5)*100;
                                // Inicio (centro)
                                points.push({
                                    x: cx, y: cy, 
                                    tx: tx, ty: ty, 
                                    color: g.color,
                                    group: g.name,
                                    speed: 0.02 + Math.random()*0.03
                                });
                            }
                        });
                        
                        // Animación
                        const drawPCoA = () => {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            
                            // Ejes
                            ctx.strokeStyle = "#eee"; ctx.lineWidth = 2;
                            ctx.beginPath(); ctx.moveTo(cx, 20); ctx.lineTo(cx, canvas.height-20); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(20, cy); ctx.lineTo(canvas.width-20, cy); ctx.stroke();
                            
                            // Etiquetas Ejes
                            ctx.fillStyle = "#999"; ctx.font = "12px sans-serif";
                            ctx.fillText("PC1 (45.2%)", canvas.width-80, cy - 5);
                            ctx.fillText("PC2 (21.5%)", cx + 5, 20);

                            // Dibujar Elipses (Simuladas)
                            groups.forEach(g => {
                                ctx.beginPath();
                                ctx.ellipse(g.cx, g.cy, 70, 50, Math.PI/4, 0, 2 * Math.PI);
                                ctx.fillStyle = g.color;
                                ctx.globalAlpha = 0.1;
                                ctx.fill();
                                ctx.strokeStyle = g.color;
                                ctx.globalAlpha = 0.5;
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            });
                            ctx.globalAlpha = 1;

                            // Dibujar Puntos
                            let moving = false;
                            points.forEach(p => {
                                // Interpolación (Moverse hacia target)
                                const dx = p.tx - p.x;
                                const dy = p.ty - p.y;
                                if(Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {
                                    p.x += dx * p.speed;
                                    p.y += dy * p.speed;
                                    moving = true;
                                }
                                
                                ctx.beginPath();
                                ctx.arc(p.x, p.y, 6, 0, Math.PI*2);
                                ctx.fillStyle = p.color;
                                ctx.fill();
                                ctx.strokeStyle = "white";
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            });
                            
                            // Leyenda
                            let legX = 20;
                            groups.forEach(g => {
                                ctx.fillStyle = g.color;
                                ctx.fillRect(legX, 10, 10, 10);
                                ctx.fillStyle = "#333";
                                ctx.fillText(g.name, legX + 15, 19);
                                legX += 80;
                            });

                            if(moving) requestAnimationFrame(drawPCoA);
                        };
                        drawPCoA();

                    } else if (type.includes("Composición")) {
                        // === 2. SIMULACIÓN DONUT CHART (Interactivo) ===
                        const container = document.createElement('div');
                        container.style.cssText = `width: 95%; max-width: 600px; height: 400px; background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); display:flex; flex-direction:column; align-items:center; flex-shrink: 0;`;
                        
                        container.innerHTML = `<h3 style="color:#2c3e50; margin-bottom:10px;">Abundancia por Filo (Phylum)</h3>`;
                        
                        const chartDiv = document.createElement('div');
                        chartDiv.style.cssText = `position: relative; width: 300px; height: 300px;`;
                        container.appendChild(chartDiv);
                        div.appendChild(container);
                        
                        const data = [
                            {name: "Firmicutes", val: 45, color: "#e74c3c"},
                            {name: "Bacteroidetes", val: 30, color: "#3498db"},
                            {name: "Proteobacteria", val: 15, color: "#2ecc71"},
                            {name: "Actinobacteria", val: 8, color: "#f1c40f"},
                            {name: "Otros", val: 2, color: "#95a5a6"}
                        ];
                        
                        // Crear sectores con conic-gradient (CSS puro para super calidad)
                        let gradientStr = "";
                        let currentPct = 0;
                        data.forEach(d => {
                            const endPct = currentPct + d.val;
                            gradientStr += `${d.color} ${currentPct}% ${endPct}%, `;
                            currentPct = endPct;
                        });
                        gradientStr = gradientStr.slice(0, -2); // Quitar ultima coma
                        
                        const donut = document.createElement('div');
                        donut.style.cssText = `
                            width: 100%; height: 100%; border-radius: 50%;
                            background: conic-gradient(${gradientStr});
                            mask: radial-gradient(transparent 50%, black 51%);
                            -webkit-mask: radial-gradient(transparent 50%, black 51%);
                            animation: spinEntry 1s ease-out;
                            position: relative;
                        `;
                        
                        // Leyenda flotante central
                        const centerText = document.createElement('div');
                        centerText.innerHTML = "Hover<br>Segment";
                        centerText.style.cssText = `position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; font-weight: bold; color: #555; pointer-events: none;`;
                        chartDiv.appendChild(donut);
                        chartDiv.appendChild(centerText);
                        
                        // Leyenda externa interactiva
                        const legendDiv = document.createElement('div');
                        legendDiv.style.cssText = `display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; margin-top: 20px;`;
                        
                        data.forEach(d => {
                            const badge = document.createElement('div');
                            badge.style.cssText = `display: flex; align-items: center; gap: 5px; cursor: pointer; padding: 5px 10px; border-radius: 20px; background: #f9f9f9; transition: transform 0.2s;`;
                            badge.innerHTML = `<span style="width:12px; height:12px; background:${d.color}; border-radius:50%;"></span> ${d.name}`;
                            
                            badge.onmouseover = () => {
                                badge.style.transform = "scale(1.1)";
                                badge.style.background = "#eee";
                                centerText.innerHTML = `<span style="color:${d.color}; font-size:1.2rem;">${d.val}%</span><br>${d.name}`;
                            };
                            
                            legendDiv.appendChild(badge);
                        });
                        container.appendChild(legendDiv);

                    } else if (type.includes("Biomarcadores")) {
                        // === 3. SIMULACIÓN LEFSE (Barras Horizontales Animadas) ===
                        const container = document.createElement('div');
                        container.style.cssText = `width: 95%; max-width: 700px; background: white; border-radius: 12px; padding: 25px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); flex-shrink: 0;`;
                        
                        container.innerHTML = `<h3 style="text-align:center; color:#2c3e50; margin-bottom:20px;">Biomarcadores Diferenciales (LDA Score)</h3>`;
                        
                        const chart = document.createElement('div');
                        chart.style.cssText = `display: flex; flex-direction: column; gap: 10px; position: relative; padding-left: 20px; border-left: 1px solid #ccc;`;
                        
                        const markers = [
                            {name: "f_Lachnospiraceae", score: 4.8, group: "Healthy", c: "#2ecc71"},
                            {name: "g_Bacteroides", score: 4.5, group: "Healthy", c: "#2ecc71"},
                            {name: "g_Faecalibacterium", score: 3.9, group: "Healthy", c: "#2ecc71"},
                            {name: "f_Enterobacteriaceae", score: -4.2, group: "Disease", c: "#e74c3c"},
                            {name: "g_Escherichia", score: -3.8, group: "Disease", c: "#e74c3c"},
                            {name: "g_Fusobacterium", score: -3.1, group: "Disease", c: "#e74c3c"}
                        ];
                        
                        markers.forEach((m, i) => {
                            const row = document.createElement('div');
                            row.style.cssText = `display: flex; align-items: center; width: 100%; height: 30px; position: relative;`;
                            
                            // Barra
                            const bar = document.createElement('div');
                            const width = Math.abs(m.score) * 15; // Escalar
                            
                            bar.style.cssText = `
                                height: 20px; background: ${m.c}; border-radius: 4px;
                                width: 0%; transition: width 1s ease-out;
                                position: absolute;
                                left: ${m.score > 0 ? "50%" : `calc(50% - ${width}%)`};
                            `;
                            
                            // Etiqueta Nombre
                            const label = document.createElement('div');
                            label.textContent = m.name;
                            label.style.cssText = `
                                position: absolute; font-size: 0.8rem; color: #555;
                                left: ${m.score > 0 ? "5%" : "auto"};
                                right: ${m.score > 0 ? "auto" : "5%"};
                                text-align: ${m.score > 0 ? "right" : "left"};
                                width: 40%;
                            `;
                            
                            // Tooltip valor
                            const val = document.createElement('span');
                            val.textContent = Math.abs(m.score).toFixed(2);
                            val.style.cssText = `margin: 0 5px; color: white; font-size: 0.7rem; font-weight: bold; padding: 2px;`;
                            bar.appendChild(val);
                            bar.style.display = "flex";
                            bar.style.alignItems = "center";
                            bar.style.justifyContent = m.score > 0 ? "flex-end" : "flex-start";

                            row.appendChild(label);
                            row.appendChild(bar);
                            chart.appendChild(row);
                            
                            // Trigger animación
                            setTimeout(() => {
                                bar.style.width = `${width}%`;
                            }, 100 + i * 100);
                        });
                        
                        // Eje central
                        const axis = document.createElement('div');
                        axis.style.cssText = `position: absolute; left: 50%; top: 0; bottom: 0; width: 2px; background: #333; z-index: 10;`;
                        chart.appendChild(axis);
                        
                        container.appendChild(chart);
                        
                        // Leyenda inferior
                        const leg = document.createElement('div');
                        leg.style.cssText = `display:flex; justify-content:space-between; margin-top:10px; font-size:0.8rem; font-weight:bold; padding: 0 10%;`;
                        leg.innerHTML = `<span style="color:#e74c3c">← Enriquecido en Disease</span> <span style="color:#2ecc71">Enriquecido en Healthy →</span>`;
                        container.appendChild(leg);
                        
                        div.appendChild(container);

                    } else {
                        // === 4. SIMULACIÓN ALPHA DIVERSITY (Boxplots Animados) ===
                        const container = document.createElement('div');
                        container.style.cssText = `width: 95%; max-width: 700px; height: 400px; background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); flex-shrink: 0; display: flex; flex-direction: column;`;
                        
                        container.innerHTML = `<h3 style="text-align:center; color:#333;">Índice de Shannon (Alfa Diversidad)</h3>`;
                        
                        const plotArea = document.createElement('div');
                        plotArea.style.cssText = `flex: 1; display: flex; align-items: flex-end; justify-content: space-around; padding-bottom: 30px; border-bottom: 2px solid #ccc; position: relative;`;
                        
                        const groups = [
                            {name: "Healthy", color: "#2ecc71", mean: 250, spread: 50},
                            {name: "Disease A", color: "#e74c3c", mean: 120, spread: 40},
                            {name: "Disease B", color: "#3498db", mean: 180, spread: 60}
                        ];
                        
                        groups.forEach((g, i) => {
                            // Contenedor Grupo
                            const groupCol = document.createElement('div');
                            groupCol.style.cssText = `width: 80px; position: relative; display: flex; justify-content: center; height: 100%;`;
                            
                            // Puntos (Jitter)
                            for(let j=0; j<15; j++) {
                                const ptVal = g.mean + (Math.random()-0.5)*g.spread;
                                const pt = document.createElement('div');
                                pt.style.cssText = `
                                    width: 8px; height: 8px; border-radius: 50%;
                                    background: ${g.color}; opacity: 0.6;
                                    position: absolute; bottom: 0; 
                                    left: ${20 + (Math.random()-0.5)*30}px;
                                    transition: bottom 1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
                                `;
                                groupCol.appendChild(pt);
                                
                                setTimeout(() => {
                                    pt.style.bottom = `${ptVal}px`;
                                }, 100 + j*20);
                            }
                            
                            // Boxplot esquemático (Caja)
                            const box = document.createElement('div');
                            box.style.cssText = `
                                position: absolute; bottom: 0; left: 10px; width: 60px;
                                height: 0; border: 2px solid ${g.color}; background: transparent;
                                transition: all 1s ease-out;
                            `;
                            groupCol.appendChild(box);
                            
                            // Animar Caja
                            setTimeout(() => {
                                box.style.height = `${g.spread}px`;
                                box.style.bottom = `${g.mean - g.spread/2}px`;
                            }, 500);
                            
                            // Etiqueta Eje X
                            const label = document.createElement('div');
                            label.textContent = g.name;
                            label.style.cssText = `position: absolute; bottom: -25px; width: 100%; text-align: center; font-weight: bold; font-size: 0.8rem; color: #555;`;
                            groupCol.appendChild(label);
                            
                            plotArea.appendChild(groupCol);
                        });
                        
                        container.appendChild(plotArea);
                        div.appendChild(container);
                    }
                }
            },
                       {
                id: 8,
                title: "Tema 8. Análisis Proteómicos y Metabolómicos",
                desc: "Espectrometría de Masas (MALDI-TOF) y Redes Metabólicas",
                icon: "fa-vial", 
                controls: [
                    {id: 'technique', type: 'select', label: 'Técnica', options: ['Proteómica (MALDI-TOF)', 'Metabolómica (LC-MS)', 'Redes Metabólicas']},
                    {id: 'laser_power', type: 'range', label: 'Potencia Láser / Voltaje', min: 10, max: 100, step: 10, val: 70}
                ],
                // CÓDIGO R REAL BASADO EN EL TEMARIO DEL PDF
                code: (p) => {
                    if (p.technique.includes('Redes')) {
                        return `
<span class="c-com"># ANÁLISIS DE REDES METABÓLICAS (KEGG/HMDB)</span>
<span class="c-com"># Objetivo: Integrar metabolitos en rutas biológicas</span>

<span class="c-kwd">library</span>(MetaboAnalystR)
<span class="c-kwd">library</span>(igraph)

<span class="c-com"># 1. Cargar lista de metabolitos identificados</span>
<span class="c-var">metabolites</span> <span class="c-op"><-</span> <span class="c-fn">c</span>(<span class="c-str">"Glu"</span>, <span class="c-str">"Gln"</span>, <span class="c-str">"Pyruvate"</span>, <span class="c-str">"Citrate"</span>, <span class="c-str">"Lactate"</span>)

<span class="c-com"># 2. Mapeo a bases de datos (HMDB/KEGG)</span>
<span class="c-com"># Identificamos los IDs únicos para cada compuesto</span>
<span class="c-var">ids</span> <span class="c-op"><-</span> <span class="c-fn">name.map</span>(<span class="c-var">metabolites</span>, <span class="c-arg">pkg</span>=<span class="c-str">"KEGG"</span>)

<span class="c-com"># 3. Construcción de la Red (Enrichment Analysis)</span>
<span class="c-com"># Buscamos rutas donde estos metabolitos estén sobrerrepresentados</span>
<span class="c-var">mset</span> <span class="c-op"><-</span> <span class="c-fn">enrich_pathway</span>(<span class="c-var">ids</span>, <span class="c-arg">organism</span>=<span class="c-str">"hsa"</span>)

<span class="c-com"># 4. Visualización de la Red</span>
<span class="c-com"># Nodos: Metabolitos | Aristas: Reacciones enzimáticas</span>
<span class="c-var">net</span> <span class="c-op"><-</span> <span class="c-fn">make_network</span>(<span class="c-var">mset</span>, <span class="c-arg">threshold</span>=<span class="c-num">0.05</span>)
<span class="c-fn">plot</span>(<span class="c-var">net</span>, <span class="c-arg">layout</span>=<span class="c-fn">layout_with_fr</span>, 
     <span class="c-arg">vertex.color</span>=<span class="c-str">"orange"</span>, 
     <span class="c-arg">main</span>=<span class="c-str">"Ciclo de Krebs y Glucólisis"</span>)`;
                    } else {
                        return `
<span class="c-com"># PROCESAMIENTO DE ESPECTROMETRÍA DE MASAS (R/Bioconductor)</span>
<span class="c-com"># Técnica: ${p.technique} | Potencia: ${p.laser_power}%</span>

<span class="c-kwd">library</span>(MSnbase)
<span class="c-kwd">library</span>(MALDIquant)

<span class="c-com"># 1. Importar Datos Crudos (Archivos mzML)</span>
<span class="c-com"># El espectro contiene intensidad vs m/z (masa/carga)</span>
<span class="c-var">raw_data</span> <span class="c-op"><-</span> <span class="c-fn">readMSData</span>(<span class="c-str">"sample_01.mzML"</span>, <span class="c-arg">mode</span>=<span class="c-str">"onDisk"</span>)

<span class="c-com"># 2. Pre-procesamiento: Suavizado y Línea Base</span>
<span class="c-com"># Eliminamos el ruido de fondo de la matriz</span>
<span class="c-var">smooth_spec</span> <span class="c-op"><-</span> <span class="c-fn">smoothIntensity</span>(<span class="c-var">raw_data</span>, <span class="c-arg">method</span>=<span class="c-str">"Savitzky-Golay"</span>)
<span class="c-var">base_corr</span> <span class="c-op"><-</span> <span class="c-fn">removeBaseline</span>(<span class="c-var">smooth_spec</span>, <span class="c-arg">method</span>=<span class="c-str">"SNIP"</span>)

<span class="c-com"># 3. Detección de Picos (Peak Picking)</span>
<span class="c-com"># Identificamos los péptidos/metabolitos reales</span>
<span class="c-var">peaks</span> <span class="c-op"><-</span> <span class="c-fn">detectPeaks</span>(<span class="c-var">base_corr</span>, 
                     <span class="c-arg">method</span>=<span class="c-str">"MAD"</span>, 
                     <span class="c-arg">SNR</span>=<span class="c-num">5</span>) <span class="c-com"># Signal-to-Noise Ratio > 5</span>

<span class="c-com"># 4. Identificación (Peptide Mass Fingerprinting)</span>
<span class="c-com"># Comparamos los picos (m/z) contra la base de datos UniProt</span>
<span class="c-var">proteins</span> <span class="c-op"><-</span> <span class="c-fn">search_db</span>(<span class="c-var">peaks</span>, <span class="c-arg">database</span>=<span class="c-str">"SwissProt"</span>, 
                      <span class="c-arg">tolerance</span>=<span class="c-num">0.1</span>) <span class="c-com"># Da: Daltons</span>

<span class="c-fn">plot</span>(<span class="c-var">raw_data</span>, <span class="c-arg">main</span>=<span class="c-str">"Espectro de Masas (m/z)"</span>)`;
                    }
                },
                
                explain: (p) => {
                    if (p.technique.includes('Redes')) return `
                        <div class="exp-highlight"><b>🌐 Redes Metabólicas</b></div>
                        <p>La metabolómica no estudia moléculas aisladas, sino sistemas. En la visualización, los <b>Nodos</b> son metabolitos (ej. Glucosa, ATP) y las <b>Líneas</b> son enzimas que convierten uno en otro.</p>
                        <p>Los "Hubs" (nodos muy conectados) suelen ser metabolitos críticos como el Piruvato o Acetil-CoA.</p>`;
                    
                    return `
                    <div class="exp-highlight">
                        <b>⚡ Espectrometría de Masas (${p.technique})</b>
                        <p>Es la técnica reina para identificar proteínas y metabolitos midiendo su relación masa/carga (m/z).</p>
                    </div>
                    <p><b>El Proceso Físico (Simulado a la derecha):</b></p>
                    <ol>
                        <li><b>Ionización (MALDI/ESI):</b> El láser (${p.laser_power}%) golpea la muestra cristalizada. Las moléculas absorben energía y "saltan" convertidas en iones gaseosos.</li>
                        <li><b>Aceleración:</b> Un campo eléctrico empuja los iones hacia el tubo de vuelo.</li>
                        <li><b>Separación (TOF - Time of Flight):</b> ¡Carrera de iones! Los ligeros vuelan rápido; los pesados, lento. El tiempo que tardan en llegar al detector revela su masa exacta.</li>
                        <li><b>Detección:</b> Se genera un "Pico" en el espectro cada vez que un grupo de iones golpea la placa final.</li>
                    </ol>`;
                },
                
                render: (p, div) => {
                    // --- CONFIGURACIÓN DE ESTILO ESTÁNDAR ---
                    div.style.cssText = "width:100%; height:100%; display:flex; flex-direction:column; align-items:center; padding:20px; box-sizing:border-box; overflow-y:auto; justify-content:flex-start;";
                    div.innerHTML = '';

                    const isNetwork = p.technique.includes('Redes');

                    if (isNetwork) {
                        // === MODO REDES METABÓLICAS ===
                        const netContainer = document.createElement('div');
                        netContainer.style.cssText = "width:95%; max-width:700px; height:450px; background:white; border-radius:12px; box-shadow:0 4px 15px rgba(0,0,0,0.1); position:relative; overflow:hidden;";
                        div.appendChild(netContainer);
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = 700; canvas.height = 450;
                        netContainer.appendChild(canvas);
                        
                        const ctx = canvas.getContext('2d');
                        
                        // Nodos (Metabolitos)
                        const nodes = [
                            {id: "Glucose", x: 350, y: 50, r: 25, color: "#3498db"},
                            {id: "G6P", x: 350, y: 130, r: 20, color: "#95a5a6"},
                            {id: "F6P", x: 350, y: 200, r: 20, color: "#95a5a6"},
                            {id: "Pyruvate", x: 350, y: 300, r: 25, color: "#e67e22"}, // Hub
                            {id: "Acetyl-CoA", x: 350, y: 380, r: 25, color: "#e74c3c"},
                            {id: "Lactate", x: 500, y: 300, r: 20, color: "#2ecc71"},
                            {id: "Alanine", x: 200, y: 300, r: 20, color: "#9b59b6"}
                        ];
                        
                        // Aristas (Enzimas)
                        const edges = [
                            {from: 0, to: 1}, {from: 1, to: 2}, {from: 2, to: 3}, // Glucólisis
                            {from: 3, to: 4}, // Link reacción
                            {from: 3, to: 5}, // Fermentación
                            {from: 3, to: 6}  // Transaminación
                        ];
                        
                        // Animación de flujo metabólico
                        const particles = [];
                        
                        const animateNet = () => {
                            ctx.clearRect(0,0,canvas.width, canvas.height);
                            
                            // Dibujar conexiones
                            edges.forEach(e => {
                                const n1 = nodes[e.from];
                                const n2 = nodes[e.to];
                                ctx.beginPath();
                                ctx.moveTo(n1.x, n1.y);
                                ctx.lineTo(n2.x, n2.y);
                                ctx.strokeStyle = "#bdc3c7";
                                ctx.lineWidth = 4;
                                ctx.stroke();
                            });
                            
                            // Generar partículas (Flux)
                            if(Math.random() > 0.9) {
                                particles.push({
                                    pathIdx: 0, 
                                    progress: 0, 
                                    edge: edges[Math.floor(Math.random() * 3)] // Solo arriba al inicio
                                });
                            }
                            
                            // Mover y dibujar partículas
                            for(let i = particles.length-1; i>=0; i--) {
                                const pt = particles[i];
                                pt.progress += 0.02;
                                
                                const n1 = nodes[pt.edge.from];
                                const n2 = nodes[pt.edge.to];
                                
                                const cx = n1.x + (n2.x - n1.x) * pt.progress;
                                const cy = n1.y + (n2.y - n1.y) * pt.progress;
                                
                                ctx.beginPath();
                                ctx.arc(cx, cy, 4, 0, Math.PI*2);
                                ctx.fillStyle = "#f1c40f";
                                ctx.fill();
                                
                                if(pt.progress >= 1) {
                                    // Lógica de bifurcación en Pyruvate (idx 3)
                                    if(pt.edge.to === 3) {
                                        const nextOpts = [3, 4, 5]; // Indices en edges array
                                        pt.edge = edges[nextOpts[Math.floor(Math.random()*3)]];
                                        pt.progress = 0;
                                    } else if(pt.edge.to === 1 || pt.edge.to === 2) {
                                        // Seguir bajando
                                        pt.edge = edges[edges.indexOf(pt.edge) + 1];
                                        pt.progress = 0;
                                    } else {
                                        particles.splice(i, 1);
                                    }
                                }
                            }
                            
                            // Dibujar Nodos
                            nodes.forEach(n => {
                                ctx.beginPath();
                                ctx.arc(n.x, n.y, n.r, 0, Math.PI*2);
                                ctx.fillStyle = "white";
                                ctx.fill();
                                ctx.strokeStyle = n.color;
                                ctx.lineWidth = 3;
                                ctx.stroke();
                                
                                ctx.fillStyle = "#555";
                                ctx.font = "bold 10px sans-serif";
                                ctx.textAlign = "center";
                                ctx.textBaseline = "middle";
                                ctx.fillText(n.id, n.x, n.y);
                            });
                            
                            if(document.body.contains(canvas)) requestAnimationFrame(animateNet);
                        };
                        animateNet();

                    } else {
                        // === MODO ESPECTROMETRÍA DE MASAS (MALDI-TOF SIMULATOR) ===
                        
                        // 1. ÁREA DE MÁQUINA
                        const machineDiv = document.createElement('div');
                        machineDiv.style.cssText = "width:95%; max-width:800px; height:250px; background:#2c3e50; border-radius:8px; position:relative; overflow:hidden; box-shadow:0 4px 10px rgba(0,0,0,0.2); margin-bottom:15px; flex-shrink:0;";
                        
                        // Elementos de la máquina
                        machineDiv.innerHTML = `
                            <div style="position:absolute; bottom:10px; left:20px; width:60px; height:20px; background:#95a5a6; border-radius:2px;"></div> <div style="position:absolute; top:20px; left:40px; width:10px; height:60px; background:#e74c3c; border-radius:2px; transform:rotate(15deg);"></div> <div style="position:absolute; right:0; top:0; bottom:0; width:40px; background:#34495e; border-left:4px solid #2ecc71; display:flex; align-items:center; justify-content:center; color:white; font-size:0.8rem; writing-mode:vertical-rl;">DETECTOR</div>
                            <div style="position:absolute; top:10px; left:10px; color:rgba(255,255,255,0.5); font-family:monospace;">MALDI-TOF CHAMBER</div>
                        `;
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = 800; canvas.height = 250;
                        canvas.style.position = "absolute";
                        canvas.style.top = "0"; canvas.style.left = "0";
                        machineDiv.appendChild(canvas);
                        div.appendChild(machineDiv);
                        
                        // 2. ÁREA DE ESPECTRO (Monitor)
                        const monitorDiv = document.createElement('div');
                        monitorDiv.style.cssText = "width:95%; max-width:800px; height:200px; background:black; border:4px solid #555; border-radius:4px; position:relative; padding:10px; box-sizing:border-box;";
                        monitorDiv.innerHTML = `<div style="position:absolute; top:5px; right:10px; color:#2ecc71; font-family:monospace; font-size:0.8rem;">● LIVE ACQUISITION</div>`;
                        
                        const specCanvas = document.createElement('canvas');
                        specCanvas.width = 780; specCanvas.height = 180;
                        monitorDiv.appendChild(specCanvas);
                        div.appendChild(monitorDiv);
                        
                        const ctx = canvas.getContext('2d');
                        const sCtx = specCanvas.getContext('2d');
                        
                        // Configuración de Iones
                        // Masa pequeña = Rápido | Masa grande = Lento
                        const ions = [];
                        const laserPower = p.laser_power;
                        
                        // Función disparo
                        const fireLaser = () => {
                            // Flash visual
                            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                            ctx.beginPath();
                            ctx.moveTo(45, 80); ctx.lineTo(50, 230); ctx.lineTo(55, 80);
                            ctx.fill();
                            
                            // Crear partículas
                            const numParticles = Math.floor(laserPower / 5);
                            for(let i=0; i<numParticles; i++) {
                                const mass = 10 + Math.random() * 90; // Masa 10 a 100
                                const speed = (100 / mass) * (laserPower/20); // Velocidad inversa a masa
                                
                                ions.push({
                                    x: 50, y: 230,
                                    vx: speed + Math.random(),
                                    vy: -2 - Math.random(), // Salir hacia arriba un poco
                                    mass: mass,
                                    color: `hsl(${mass*3}, 70%, 60%)`, // Color por masa
                                    active: true
                                });
                            }
                        };
                        
                        // Datos del espectro (Histograma acumulativo)
                        const spectrum = new Array(800).fill(0);
                        
                        const animateMS = () => {
                            // Limpiar
                            ctx.clearRect(0,0,canvas.width, canvas.height);
                            sCtx.fillStyle = "rgba(0, 0, 0, 0.1)"; // Trail effect en monitor
                            sCtx.fillRect(0,0,specCanvas.width, specCanvas.height);
                            
                            // Dibujar iones
                            ions.forEach(ion => {
                                if(!ion.active) return;
                                
                                // Física simple
                                ion.x += ion.vx;
                                ion.y += ion.vy;
                                ion.vy += 0.05; // Gravedad leve (drift)
                                
                                // Dibujar bola
                                ctx.beginPath();
                                ctx.arc(ion.x, ion.y, 3 + ion.mass/20, 0, Math.PI*2);
                                ctx.fillStyle = ion.color;
                                ctx.fill();
                                
                                // Colisión con detector (Derecha)
                                if (ion.x > 760) {
                                    ion.active = false;
                                    // Registrar en espectro
                                    // Mapear masa a posición X del monitor
                                    // Masa pequeña (rápida) llega antes -> m/z bajo -> izquierda? 
                                    // En TOF real: Tiempo es proporcional a raiz(m/z).
                                    // Aquí simplificamos: mapeamos masa directa a posición X del espectro
                                    const specX = Math.floor((ion.mass / 100) * 780);
                                    spectrum[specX] += 20; // Subir pico
                                    
                                    // Flash en detector
                                    ctx.fillStyle = "#2ecc71";
                                    ctx.fillRect(760, 0, 40, 250);
                                }
                            });
                            
                            // Dibujar Espectro
                            sCtx.beginPath();
                            sCtx.strokeStyle = "#00ff00";
                            sCtx.lineWidth = 2;
                            for(let i=0; i<spectrum.length; i++) {
                                // Decaimiento del pico (para que bajen después del impacto)
                                if(spectrum[i] > 0) spectrum[i] -= 0.5;
                                
                                const h = Math.min(150, spectrum[i]);
                                sCtx.moveTo(i, 180);
                                sCtx.lineTo(i, 180 - h);
                            }
                            sCtx.stroke();
                            
                            // Texto Ejes Monitor
                            sCtx.fillStyle = "#00ff00";
                            sCtx.font = "10px monospace";
                            sCtx.fillText("m/z (Mass-to-Charge Ratio) ->", 300, 170);
                            sCtx.fillText("Intensity", 5, 20);
                            
                            // Laser loop
                            if(Math.random() > 0.95) fireLaser();
                            
                            if(document.body.contains(canvas)) requestAnimationFrame(animateMS);
                        };
                        animateMS();
                    }
                }
            },
          {
                id: 9,
                title: "Tema 9. Tendencias Emergentes (TGS, Epigenómica, GWAS)",
                desc: "Análisis avanzados: Nanopore, Metilación y Asociación Genómica",
                icon: "fa-dna",
                controls: [
                    {id: 'trend_module', type: 'select', label: 'Módulo de Estudio', options: ['1. Tercera Generación (Nanopore)', '2. Epigenómica (Metilación DNA)', '3. GWAS (Asociación)']},
                    {id: 'parameter', type: 'range', label: 'Sensibilidad / Longitud', min: 1, max: 10, step: 1, val: 5},
                    {id: 'action_trigger', type: 'select', label: 'Acción', options: ['Visualizar Datos Crudos', 'Ejecutar Procesamiento']}
                ],
                // CÓDIGO R COMPLETO Y CONTEXTUAL (CAMBIA SEGÚN EL MÓDULO)
                code: (p) => {
                    if (p.trend_module.includes('Nanopore')) return `
<span class="c-com"># ANÁLISIS DE TERCERA GENERACIÓN (LONG-READS)</span>
<span class="c-com"># Tecnología: Oxford Nanopore Technologies (ONT)</span>

<span class="c-kwd">library</span>(rhdf5)
<span class="c-kwd">library</span>(NanoPlot)

<span class="c-com"># 1. Extracción de señal cruda (Fast5)</span>
<span class="c-com"># Leemos la corriente iónica (picoamperios)</span>
<span class="c-var">f5_file</span> <span class="c-op"><-</span> <span class="c-str">"reads/batch_0.fast5"</span>
<span class="c-var">raw_signal</span> <span class="c-op"><-</span> <span class="c-fn">h5read</span>(<span class="c-var">f5_file</span>, <span class="c-str">"Raw/Reads/Read_1/Signal"</span>)

<span class="c-com"># 2. Basecalling (Guppy / Dorado)</span>
<span class="c-com"># Red neuronal recurrente (RNN) traduce señal -> secuencia</span>
<span class="c-fn">system</span>(<span class="c-str">"guppy_basecaller -i fast5_dir -s fastq_out --flowcell FLO-MIN106"</span>)

<span class="c-com"># 3. Control de Calidad (Longitud N50)</span>
<span class="c-var">reads</span> <span class="c-op"><-</span> <span class="c-fn">readFastq</span>(<span class="c-str">"fastq_out/pass.fastq"</span>)
<span class="c-fn">NanoPlot</span>(<span class="c-arg">fastq</span> = <span class="c-var">reads</span>, <span class="c-arg">N50</span> = <span class="c-kwd">TRUE</span>, <span class="c-arg">title</span> = <span class="c-str">"Long Read Metrics"</span>)

<span class="c-com"># 4. Detección de Variantes Estructurales (SVs)</span>
<span class="c-com"># Mapeo con minimap2 y call con Sniffles</span>
<span class="c-fn">system</span>(<span class="c-str">"minimap2 -ax map-ont ref.fa reads.fq | samtools sort > aln.bam"</span>)
<span class="c-var">sv_vcf</span> <span class="c-op"><-</span> <span class="c-fn">sniffles</span>(<span class="c-arg">input</span> = <span class="c-str">"aln.bam"</span>)`;

                    if (p.trend_module.includes('Epigenómica')) return `
<span class="c-com"># ANÁLISIS EPIGENÓMICO (BISULFITE SEQUENCING)</span>
<span class="c-com"># Objetivo: Detectar 5-metilcitosina (5mC)</span>

<span class="c-kwd">library</span>(methylKit)
<span class="c-kwd">library</span>(GenomicRanges)

<span class="c-com"># 1. Tratamiento in-silico (Alineamiento)</span>
<span class="c-com"># Citosinas no metiladas (C) se leen como Timinas (T)</span>
<span class="c-var">file.list</span> <span class="c-op"><-</span> <span class="c-fn">list</span>(<span class="c-str">"tumor.bismark.cov"</span>, <span class="c-str">"normal.bismark.cov"</span>)
<span class="c-var">meth</span> <span class="c-op"><-</span> <span class="c-fn">methRead</span>(<span class="c-var">file.list</span>, <span class="c-arg">sample.id</span>=<span class="c-fn">list</span>(<span class="c-str">"tumor"</span>,<span class="c-str">"normal"</span>), <span class="c-arg">assembly</span>=<span class="c-str">"hg38"</span>)

<span class="c-com"># 2. Filtrar por cobertura (min 10x)</span>
<span class="c-var">meth</span> <span class="c-op"><-</span> <span class="c-fn">filterByCoverage</span>(<span class="c-var">meth</span>, <span class="c-arg">lo.count</span>=<span class="c-num">10</span>)

<span class="c-com"># 3. Calcular Diferencial (DMRs)</span>
<span class="c-var">myDiff</span> <span class="c-op"><-</span> <span class="c-fn">calculateDiffMeth</span>(<span class="c-var">meth</span>)
<span class="c-var">diffAnn</span> <span class="c-op"><-</span> <span class="c-fn">annotateWithGeneParts</span>(<span class="c-fn">as</span>(<span class="c-var">myDiff</span>,<span class="c-str">"GRanges"</span>), <span class="c-var">gene.obj</span>)

<span class="c-com"># 4. Visualización (Lollipop Plot)</span>
<span class="c-fn">plotLollipop</span>(<span class="c-var">myDiff</span>, <span class="c-arg">chr</span>=<span class="c-str">"chr17"</span>, <span class="c-arg">start</span>=<span class="c-num">7.5e6</span>, <span class="c-arg">end</span>=<span class="c-num">7.6e6</span>)`;

                    return `
<span class="c-com"># ESTUDIO DE ASOCIACIÓN DE GENOMA COMPLETO (GWAS)</span>
<span class="c-com"># Fenotipo: Diabetes Tipo 2 | Población: 10,000 individuos</span>

<span class="c-kwd">library</span>(qqman)
<span class="c-kwd">library</span>(GWASTools)

<span class="c-com"># 1. Control de Calidad (QC)</span>
<span class="c-com"># Filtros: MAF > 0.01, HWE > 1e-6, Call Rate > 95%</span>
<span class="c-var">clean_data</span> <span class="c-op"><-</span> <span class="c-fn">plinkQC</span>(<span class="c-var">raw_data</span>, <span class="c-arg">maf</span>=<span class="c-num">0.01</span>, <span class="c-arg">geno</span>=<span class="c-num">0.05</span>)

<span class="c-com"># 2. Test de Asociación (Regresión Logística)</span>
<span class="c-var">gwas_res</span> <span class="c-op"><-</span> <span class="c-fn">assocTest</span>(<span class="c-var">clean_data</span>, <span class="c-arg">model</span>=<span class="c-str">"logistic"</span>, <span class="c-arg">formula</span> = <span class="c-var">status</span> ~ <span class="c-var">snp</span> + <span class="c-var">age</span> + <span class="c-var">sex</span>)

<span class="c-com"># 3. Corrección por Múltiples Pruebas</span>
<span class="c-com"># Umbral de Bonferroni: 0.05 / 1,000,000 SNPs = 5e-8</span>
<span class="c-var">significant_snps</span> <span class="c-op"><-</span> <span class="c-fn">subset</span>(<span class="c-var">gwas_res</span>, <span class="c-var">P</span> <span class="c-op"><</span> <span class="c-num">5e-8</span>)

<span class="c-com"># 4. Visualización: Manhattan Plot</span>
<span class="c-fn">manhattan</span>(<span class="c-var">gwas_res</span>, 
          <span class="c-arg">chr</span>=<span class="c-str">"CHR"</span>, 
          <span class="c-arg">bp</span>=<span class="c-str">"BP"</span>, 
          <span class="c-arg">p</span>=<span class="c-str">"P"</span>, 
          <span class="c-arg">snp</span>=<span class="c-str">"SNP"</span>,
          <span class="c-arg">col</span>=<span class="c-fn">c</span>(<span class="c-str">"blue4"</span>, <span class="c-str">"orange3"</span>),
          <span class="c-arg">suggestiveline</span> = <span class="c-kwd">FALSE</span>,
          <span class="c-arg">genomewideline</span> = <span class="c-op">-</span><span class="c-fn">log10</span>(<span class="c-num">5e-8</span>))`;
                },
                
                explain: (p) => {
                    const module = p.trend_module;
                    if(module.includes('Nanopore')) return `
                        <div class="exp-highlight"><b>📏 Tercera Generación (TGS)</b></div>
                        <p>A diferencia de Illumina (lecturas cortas, ~150bp), tecnologías como <b>Nanopore</b> producen lecturas ultra-largas (10kb - 1Mb).</p>
                        <ul>
                            <li><b>Squiggle Plot:</b> Representa el cambio en la corriente eléctrica cuando el ADN pasa por el poro. Cada "garabato" es una secuencia de bases.</li>
                            <li><b>Ventaja:</b> Permite ensamblar genomas completos y detectar variantes estructurales (SV) grandes.</li>
                        </ul>`;
                    if(module.includes('Epigenómica')) return `
                        <div class="exp-highlight"><b>🧬 Epigenómica: Metilación del ADN</b></div>
                        <p>Estudiamos las marcas químicas sobre el ADN que regulan la expresión génica sin cambiar la secuencia.</p>
                        <ul>
                            <li><b>Conversión por Bisulfito:</b> Técnica clave. Convierte Citosinas no metiladas (C) en Uracilos (T). Las Citosinas Metiladas (5mC) están protegidas y permanecen como C.</li>
                            <li><b>Aplicación:</b> Detección temprana de cáncer (patrones de hipermetilación en promotores).</li>
                        </ul>`;
                    return `
                        <div class="exp-highlight"><b>📊 GWAS (Genome-Wide Association Study)</b></div>
                        <p>Busca variantes genéticas (SNPs) comunes asociadas a rasgos complejos en poblaciones grandes.</p>
                        <ul>
                            <li><b>Manhattan Plot:</b> Cada punto es un SNP. Eje X = Cromosomas, Eje Y = Significancia estadística (-log10 P).</li>
                            <li><b>Torres:</b> Los picos altos indican la ubicación de genes de riesgo. Cuanto más alto, más segura es la asociación.</li>
                        </ul>`;
                },
                
                render: (p, div) => {
                    // --- SETUP LAYOUT (FLEX + SCROLL) ---
                    div.style.cssText = "width:100%; height:100%; display:flex; flex-direction:column; align-items:center; padding:20px; overflow-y:auto; justify-content:flex-start; box-sizing:border-box;";
                    div.innerHTML = '';

                    const module = p.trend_module;
                    const action = p.action_trigger;
                    const param = p.parameter;

                    // 1. VISUALIZADOR PRINCIPAL
                    const container = document.createElement('div');
                    container.style.cssText = `width: 95%; max-width: 800px; height: 450px; background: white; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); position: relative; overflow: hidden; flex-shrink: 0; margin-bottom: 20px;`;
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = 800; canvas.height = 450;
                    canvas.style.width = "100%"; canvas.style.height = "100%";
                    container.appendChild(canvas);
                    div.appendChild(container);
                    
                    const ctx = canvas.getContext('2d');
                    const w = canvas.width;
                    const h = canvas.height;
                    const cx = w/2;
                    const cy = h/2;

                    // --- ANIMACIÓN NANOPORE ---
                    if (module.includes('Nanopore')) {
                        let offset = 0;
                        const animateNanopore = () => {
                            if(!document.body.contains(canvas)) return;
                            ctx.clearRect(0,0,w,h);
                            
                            // Fondo oscuro técnico
                            ctx.fillStyle = "#1e1e1e"; ctx.fillRect(0,0,w,h);
                            
                            // Dibujar Membrana y Poro
                            ctx.fillStyle = "#34495e";
                            ctx.fillRect(0, cy-20, w, 40); // Membrana
                            
                            // Poro (Proteína)
                            ctx.fillStyle = "#f1c40f";
                            ctx.beginPath();
                            ctx.moveTo(cx-30, cy-30); ctx.lineTo(cx+30, cy-30);
                            ctx.lineTo(cx+10, cy+30); ctx.lineTo(cx-10, cy+30);
                            ctx.fill();
                            
                            // Hebra de ADN pasando
                            ctx.lineWidth = 4;
                            ctx.strokeStyle = "#e74c3c"; // Backbone
                            ctx.beginPath();
                            ctx.moveTo(cx, 0); ctx.lineTo(cx, h);
                            
                            // Efecto de movimiento en el ADN (Bases)
                            ctx.setLineDash([10, 15]);
                            ctx.lineDashOffset = -offset;
                            ctx.stroke();
                            ctx.setLineDash([]);
                            
                            // Señal Eléctrica (Squiggle) - Panel derecho
                            ctx.fillStyle = "black";
                            ctx.fillRect(cx + 100, 50, 280, 200);
                            ctx.strokeStyle = "#00ff00";
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            
                            // Dibujar onda basada en el offset
                            for(let i=0; i<280; i++) {
                                const x = cx + 100 + i;
                                // Onda simulada pseudo-aleatoria
                                const signal = 150 + Math.sin((i + offset)*0.1) * 30 + Math.sin((i + offset)*0.5) * 10;
                                if(i===0) ctx.moveTo(x, signal);
                                else ctx.lineTo(x, signal);
                            }
                            ctx.stroke();
                            
                            // Texto Monitor
                            ctx.font = "12px monospace"; ctx.fillStyle = "#00ff00";
                            ctx.fillText("LIVE CURRENT (pA)", cx + 110, 70);
                            ctx.fillText(`Read Len: ${(offset * 10).toFixed(0)} bp`, cx + 110, 230);
                            
                            if (action.includes('Ejecutar')) {
                                offset += param; // Velocidad según parámetro
                            } else {
                                offset += 0.5; // Velocidad idle
                            }
                            requestAnimationFrame(animateNanopore);
                        };
                        animateNanopore();
                        
                        // Panel Info Extra
                        const infoDiv = document.createElement('div');
                        infoDiv.style.cssText = `display:flex; gap:10px; justify-content:center; margin-top:10px;`;
                        infoDiv.innerHTML = `<span class="badge" style="background:#e74c3c; color:white; padding:5px 10px; border-radius:4px;">Single Molecule</span> <span class="badge" style="background:#2ecc71; color:white; padding:5px 10px; border-radius:4px;">Real-Time</span>`;
                        div.appendChild(infoDiv);
                    }

                    // --- ANIMACIÓN EPIGENÓMICA ---
                    else if (module.includes('Epigenómica')) {
                        // Estado inicial
                        const bases = [];
                        const seqLen = 12;
                        const spacing = 50;
                        const startX = (w - (seqLen*spacing))/2;
                        
                        // Generar secuencia fija con CpGs
                        const seqTxt = "ACGT CG AT CG GC";
                        const cleanSeq = seqTxt.replace(/ /g, '');
                        
                        for(let i=0; i<cleanSeq.length; i++) {
                            const char = cleanSeq[i];
                            // Metilación aleatoria en C
                            let isMeth = false;
                            if(char === 'C' && Math.random() > 0.3) isMeth = true;
                            
                            bases.push({
                                char: char,
                                x: startX + i*spacing,
                                y: cy,
                                isMeth: isMeth,
                                converted: false
                            });
                        }
                        
                        let reactionProgress = 0;
                        
                        const animateEpi = () => {
                            if(!document.body.contains(canvas)) return;
                            ctx.clearRect(0,0,w,h);
                            
                            // Título
                            ctx.font = "bold 16px sans-serif"; ctx.fillStyle = "#333"; ctx.textAlign="center";
                            ctx.fillText("Reacción de Bisulfito de Sodio", cx, 40);
                            
                            // Dibujar hebra
                            ctx.beginPath(); ctx.moveTo(startX, cy); ctx.lineTo(startX + cleanSeq.length*spacing - spacing, cy);
                            ctx.strokeStyle = "#ccc"; ctx.lineWidth=4; ctx.stroke();
                            
                            // Dibujar bases
                            bases.forEach(b => {
                                let color = "#3498db"; // C normal
                                let text = b.char;
                                
                                if (b.char === 'C') {
                                    if (b.isMeth) {
                                        color = "#2c3e50"; // C Metilada (Protegida)
                                        // Dibujar piruleta (Methyl group)
                                        ctx.beginPath(); ctx.moveTo(b.x, b.y-15); ctx.lineTo(b.x, b.y-35);
                                        ctx.strokeStyle = "#333"; ctx.lineWidth=2; ctx.stroke();
                                        ctx.beginPath(); ctx.arc(b.x, b.y-35, 6, 0, Math.PI*2);
                                        ctx.fillStyle = "black"; ctx.fill();
                                        ctx.fillText("CH3", b.x, b.y-45);
                                    } else {
                                        // C no metilada
                                        if (b.converted) {
                                            color = "#9b59b6"; // Uracilo
                                            text = "U";
                                        }
                                    }
                                } else {
                                    color = "#95a5a6"; // Otras
                                }
                                
                                // Círculo Base
                                ctx.beginPath(); ctx.arc(b.x, b.y, 18, 0, Math.PI*2);
                                ctx.fillStyle = color; ctx.fill();
                                ctx.fillStyle = "white"; ctx.font = "bold 14px monospace";
                                ctx.fillText(text, b.x, b.y+5);
                            });
                            
                            // Animación de reacción
                            if (action.includes('Ejecutar')) {
                                reactionProgress += 0.01;
                                
                                // Efecto nube química
                                ctx.fillStyle = `rgba(255, 235, 59, ${Math.sin(reactionProgress*Math.PI) * 0.3})`;
                                ctx.fillRect(0,0,w,h);
                                
                                if (reactionProgress > 0.5) {
                                    bases.forEach(b => {
                                        if (b.char === 'C' && !b.isMeth) b.converted = true;
                                    });
                                }
                                
                                if (reactionProgress < 1) requestAnimationFrame(animateEpi);
                            } else {
                                // Reset si no ejecuta
                                bases.forEach(b => { if(!b.isMeth && b.char==='C') b.converted=false; });
                                requestAnimationFrame(animateEpi);
                            }
                        };
                        animateEpi();
                    }

                    // --- ANIMACIÓN GWAS ---
                    else {
                        const numChr = 22;
                        const points = [];
                        
                        // Pre-calcular puntos del Manhattan Plot
                        for(let c=0; c<numChr; c++) {
                            const baseX = 50 + c * 32;
                            for(let i=0; i<30; i++) {
                                let pval = Math.random() * 4; // Ruido base
                                // Picos en cromosoma 6 y 19
                                if ((c===5 || c===18) && i>10 && i<20) pval = 4 + Math.random() * (param); // Altura según slider
                                
                                points.push({
                                    x: baseX + Math.random()*20,
                                    targetY: h - 50 - (pval * 30),
                                    y: h - 50, // Empiezan abajo
                                    c: c % 2 === 0 ? "#2c3e50" : "#95a5a6",
                                    val: pval
                                });
                            }
                        }
                        
                        let progress = 0;
                        const animateGWAS = () => {
                            if(!document.body.contains(canvas)) return;
                            ctx.clearRect(0,0,w,h);
                            
                            // Ejes
                            ctx.beginPath(); ctx.moveTo(40, h-40); ctx.lineTo(w-20, h-40); ctx.stroke(); // X
                            ctx.beginPath(); ctx.moveTo(40, h-40); ctx.lineTo(40, 20); ctx.stroke(); // Y
                            
                            // Línea de significancia
                            const sigY = h - 50 - (7.3 * 30); // 5e-8
                            ctx.beginPath(); ctx.moveTo(40, sigY); ctx.lineTo(w-20, sigY);
                            ctx.strokeStyle = "#e74c3c"; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
                            ctx.fillStyle = "#e74c3c"; ctx.fillText("Significancia (5e-8)", w-120, sigY-5);
                            
                            // Dibujar puntos
                            points.forEach(pt => {
                                // Interpolación si se ejecuta
                                if (action.includes('Ejecutar')) {
                                    pt.y += (pt.targetY - pt.y) * 0.1;
                                }
                                
                                ctx.fillStyle = pt.c;
                                // Si cruza la línea, es verde (hit)
                                if (pt.y < sigY) ctx.fillStyle = "#2ecc71";
                                
                                ctx.beginPath(); ctx.arc(pt.x, pt.y, 3, 0, Math.PI*2); ctx.fill();
                                
                                // Etiqueta Hit
                                if (pt.y < sigY && Math.abs(pt.y - pt.targetY) < 1) {
                                    ctx.fillStyle = "#333"; ctx.font = "bold 10px sans-serif";
                                    ctx.fillText("HIT", pt.x-10, pt.y-10);
                                }
                            });
                            
                            requestAnimationFrame(animateGWAS);
                        };
                        animateGWAS();
                    }
                }
            },
            {
                id: 10,
                title: "Tema 10. IA y Deep Learning en Genómica",
                desc: "Simulador de Arquitecturas: CNN, RNN y Transformers",
                icon: "fa-brain",
                controls: [
                    {id: 'model_type', type: 'select', label: 'Arquitectura DL', options: ['1. CNN (Detección de Motivos)', '2. RNN/LSTM (Secuencias)', '3. Autoencoder (Reducción)', '4. Transformer (Atención)']},
                    {id: 'epochs', type: 'range', label: 'Duración (Épocas)', min: 10, max: 100, step: 10, val: 30}
                ],
                // CÓDIGO R (KERAS/TENSORFLOW) ADAPTADO AL MODELO
                code: (p) => {
                    if (p.model_type.includes('CNN')) return `
<span class="c-com"># DEEP LEARNING: CNN PARA SECUENCIAS DE ADN</span>
<span class="c-com"># Objetivo: Predecir sitios de unión a factores de transcripción (TFBS)</span>

<span class="c-kwd">library</span>(keras)

<span class="c-com"># 1. Preparación de Datos (One-Hot Encoding)</span>
<span class="c-com"># Convertir ACGT en matriz binaria [4, Longitud]</span>
<span class="c-var">x_train</span> <span class="c-op"><-</span> <span class="c-fn">one_hot_encode</span>(<span class="c-var">sequences</span>) 

<span class="c-com"># 2. Arquitectura CNN (1D)</span>
<span class="c-var">model</span> <span class="c-op"><-</span> <span class="c-fn">keras_model_sequential</span>() %>%
  <span class="c-com"># Capa Convolucional: Escanea motivos (k-mers)</span>
  <span class="c-fn">layer_conv_1d</span>(<span class="c-arg">filters</span>=32, <span class="c-arg">kernel_size</span>=12, <span class="c-arg">activation</span>=<span class="c-str">"relu"</span>, 
                <span class="c-arg">input_shape</span>=<span class="c-fn">c</span>(100, 4)) %>%
  <span class="c-fn">layer_max_pooling_1d</span>(<span class="c-arg">pool_size</span>=4) %>%
  <span class="c-fn">layer_flatten</span>() %>%
  <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span>=1, <span class="c-arg">activation</span>=<span class="c-str">"sigmoid"</span>)

<span class="c-com"># 3. Entrenamiento</span>
<span class="c-var">model</span> %>% <span class="c-fn">compile</span>(<span class="c-arg">loss</span>=<span class="c-str">"binary_crossentropy"</span>, <span class="c-arg">optimizer</span>=<span class="c-str">"adam"</span>)
<span class="c-var">history</span> <span class="c-op"><-</span> <span class="c-var">model</span> %>% <span class="c-fn">fit</span>(<span class="c-var">x_train</span>, <span class="c-var">y_train</span>, <span class="c-arg">epochs</span>=${p.epochs})`;

                    if (p.model_type.includes('RNN')) return `
<span class="c-com"># RED NEURONAL RECURRENTE (LSTM/GRU)</span>
<span class="c-com"># Objetivo: Clasificación de función de proteínas (Secuencial)</span>

<span class="c-var">model</span> <span class="c-op"><-</span> <span class="c-fn">keras_model_sequential</span>() %>%
  <span class="c-com"># Embedding: Convertir aminoácidos a vectores densos</span>
  <span class="c-fn">layer_embedding</span>(<span class="c-arg">input_dim</span>=21, <span class="c-arg">output_dim</span>=64) %>%
  
  <span class="c-com"># LSTM Bidireccional: Lee la secuencia en ambos sentidos</span>
  <span class="c-fn">layer_bidirectional</span>(<span class="c-fn">layer_lstm</span>(<span class="c-arg">units</span>=64)) %>%
  
  <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span>=10, <span class="c-arg">activation</span>=<span class="c-str">"softmax"</span>)

<span class="c-fn">summary</span>(<span class="c-var">model</span>)`;

                    if (p.model_type.includes('Autoencoder')) return `
<span class="c-com"># AUTOENCODER (APRENDIZAJE NO SUPERVISADO)</span>
<span class="c-com"># Objetivo: Denoising y reducción de dimensiones (scRNA-seq)</span>

<span class="c-com"># Encoder: Comprime 20,000 genes a 32 dimensiones latentes</span>
<span class="c-var">input</span> <span class="c-op"><-</span> <span class="c-fn">layer_input</span>(<span class="c-arg">shape</span>=20000)
<span class="c-var">encoded</span> <span class="c-op"><-</span> <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span>=128, <span class="c-arg">activation</span>=<span class="c-str">"relu"</span>)(<span class="c-var">input</span>)
<span class="c-var">bottleneck</span> <span class="c-op"><-</span> <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span>=32, <span class="c-arg">activation</span>=<span class="c-str">"relu"</span>)(<span class="c-var">encoded</span>)

<span class="c-com"># Decoder: Reconstruye la expresión original</span>
<span class="c-var">decoded</span> <span class="c-op"><-</span> <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span>=128, <span class="c-arg">activation</span>=<span class="c-str">"relu"</span>)(<span class="c-var">bottleneck</span>)
<span class="c-var">output</span> <span class="c-op"><-</span> <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span>=20000, <span class="c-arg">activation</span>=<span class="c-str">"linear"</span>)(<span class="c-var">decoded</span>)

<span class="c-var">autoencoder</span> <span class="c-op"><-</span> <span class="c-fn">keras_model</span>(<span class="c-var">input</span>, <span class="c-var">output</span>)`;

                    return `
<span class="c-com"># TRANSFORMERS (MECANISMO DE ATENCIÓN)</span>
<span class="c-com"># Objetivo: Predicción de estructura (estilo AlphaFold) o Modelos de Lenguaje (DNA-BERT)</span>

<span class="c-kwd">library</span>(attention)

<span class="c-com"># Capa de Auto-Atención (Self-Attention)</span>
<span class="c-com"># Permite al modelo enfocar relaciones distantes en el genoma</span>
<span class="c-var">attn_layer</span> <span class="c-op"><-</span> <span class="c-fn">layer_multi_head_attention</span>(
    <span class="c-arg">num_heads</span> = 8, 
    <span class="c-arg">key_dim</span> = 64
)

<span class="c-com"># Visualizar mapa de atención</span>
<span class="c-com"># Muestra qué bases están "mirando" a qué otras bases</span>
<span class="c-fn">plot_attention_heatmap</span>(<span class="c-var">attention_weights</span>)`;
                },
                
                explain: (p) => {
                    const model = p.model_type;
                    if(model.includes('CNN')) return `
                        <div class="exp-highlight"><b>👁️ Convolutional Neural Networks (CNN)</b></div>
                        <p>Inspiradas en la corteza visual. En genómica, en lugar de detectar "bordes" en fotos, detectan <b>motivos de secuencia</b> (ej. cajas TATA, sitios de unión) deslizando filtros sobre el ADN.</p>
                        <ul><li><b>Invarianza espacial:</b> Detecta el motivo sin importar dónde esté en la secuencia.</li></ul>`;
                    if(model.includes('RNN')) return `
                        <div class="exp-highlight"><b>📝 Recurrent Neural Networks (RNN/LSTM)</b></div>
                        <p>Diseñadas para datos secuenciales (como el lenguaje o proteínas). Tienen "memoria" interna para recordar lo que vieron antes.</p>
                        <ul><li><b>Uso:</b> Predecir estructura secundaria, nanopore basecalling.</li></ul>`;
                    if(model.includes('Autoencoder')) return `
                        <div class="exp-highlight"><b>📉 Autoencoders</b></div>
                        <p>Redes que aprenden a comprimir datos (Encoder) y descomprimirlos (Decoder). El "cuello de botella" obliga a la red a aprender las características más importantes y eliminar ruido.</p>`;
                    return `
                        <div class="exp-highlight"><b>🤖 Transformers</b></div>
                        <p>La tecnología detrás de ChatGPT y AlphaFold. Usan <b>Mecanismos de Atención</b> para entender el contexto global de una secuencia, sin importar la distancia entre elementos.</p>`;
                },
                
                render: (p, div) => {
                    // --- LAYOUT MASTER (FLEX + SCROLL) ---
                    div.style.cssText = "width:100%; height:100%; display:flex; flex-direction:column; align-items:center; padding:20px; box-sizing:border-box; overflow-y:auto; justify-content:flex-start;";
                    div.innerHTML = '';
                    
                    const mode = p.model_type;
                    
                    // 1. ÁREA DE ARQUITECTURA (CANVAS)
                    const container = document.createElement('div');
                    container.style.cssText = "width:95%; max-width:800px; height:350px; background:#1e1e1e; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,0.3); position:relative; margin-bottom:20px; flex-shrink:0; overflow:hidden;";
                    
                    const title = document.createElement('div');
                    title.innerHTML = `<i class="fas fa-network-wired"></i> Architecture: <b>${mode.split(' ')[1]}</b>`;
                    title.style.cssText = "position:absolute; top:15px; left:20px; color:#4CAF50; font-weight:bold; z-index:10; font-family:monospace;";
                    container.appendChild(title);
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = 800; canvas.height = 350;
                    canvas.style.width="100%"; canvas.style.height="100%";
                    container.appendChild(canvas);
                    div.appendChild(container);
                    
                    const ctx = canvas.getContext('2d');
                    let frame = 0;
                    
                    // --- ANIMACIÓN CNN (SCANNING) ---
                    if (mode.includes('CNN')) {
                        const seq = "ATGCGTACGTTAGCCTAAGCTACGG".split('');
                        const cellSize = 30;
                        const startX = 50;
                        const yPos = 150;
                        
                        const animateCNN = () => {
                            if(!document.body.contains(canvas)) return;
                            ctx.clearRect(0,0,800,350);
                            
                            // Dibujar Secuencia (Input)
                            seq.forEach((b, i) => {
                                ctx.fillStyle = "#333";
                                ctx.fillRect(startX + i*cellSize, yPos, cellSize-2, cellSize);
                                ctx.fillStyle = b==='A'?"#2ecc71":b==='C'?"#3498db":b==='G'?"#f1c40f":"#e74c3c";
                                ctx.font = "bold 16px monospace"; ctx.textAlign="center";
                                ctx.fillText(b, startX + i*cellSize + cellSize/2, yPos+20);
                            });
                            ctx.fillStyle="white"; ctx.fillText("INPUT SEQUENCE (One-Hot)", 400, yPos+50);
                            
                            // Dibujar Filtro (Kernel) deslizándose
                            const filterSize = 3;
                            const totalSteps = seq.length - filterSize + 1;
                            const currentStep = Math.floor(frame / 20) % totalSteps;
                            const smoothX = startX + currentStep * cellSize;
                            
                            ctx.strokeStyle = "#00e676"; ctx.lineWidth = 3;
                            ctx.strokeRect(smoothX - 2, yPos - 2, cellSize*filterSize + 2, cellSize + 4);
                            ctx.fillStyle = "#00e676"; ctx.fillText("KERNEL (Filter)", smoothX + (cellSize*filterSize)/2, yPos - 15);
                            
                            // Dibujar Feature Map (Output)
                            const mapStartX = 100;
                            const mapY = 250;
                            for(let i=0; i<totalSteps; i++) {
                                ctx.fillStyle = "#444";
                                ctx.fillRect(mapStartX + i*25, mapY, 20, 20);
                                
                                if (i === currentStep) {
                                    ctx.fillStyle = "#00e676"; // Activación
                                    ctx.fillRect(mapStartX + i*25, mapY, 20, 20);
                                    
                                    // Líneas conectoras
                                    ctx.beginPath();
                                    ctx.moveTo(smoothX + (cellSize*filterSize)/2, yPos+35);
                                    ctx.lineTo(mapStartX + i*25 + 10, mapY);
                                    ctx.strokeStyle = "rgba(0, 230, 118, 0.5)"; ctx.lineWidth=1;
                                    ctx.stroke();
                                }
                            }
                            ctx.fillStyle="white"; ctx.fillText("FEATURE MAP (Activation)", 400, mapY+40);
                            
                            frame++;
                            requestAnimationFrame(animateCNN);
                        };
                        animateCNN();
                    }
                    
                    // --- ANIMACIÓN RNN/LSTM (SEQUENTIAL) ---
                    else if (mode.includes('RNN')) {
                        const seq = "MSEKK QLIV".split(''); // Proteína
                        
                        const animateRNN = () => {
                            if(!document.body.contains(canvas)) return;
                            ctx.clearRect(0,0,800,350);
                            
                            const step = Math.floor(frame / 40) % (seq.length + 2);
                            
                            // Dibujar cadena
                            seq.forEach((aa, i) => {
                                const x = 100 + i * 50;
                                const y = 250;
                                ctx.fillStyle = (i === step) ? "#f1c40f" : "#555";
                                ctx.beginPath(); ctx.arc(x, y, 20, 0, Math.PI*2); ctx.fill();
                                ctx.fillStyle = "white"; ctx.font="14px Arial";
                                ctx.fillText(aa, x, y+5);
                                if(i===step) { ctx.fillStyle="#f1c40f"; ctx.fillText("t="+i, x, y+40); }
                            });
                            
                            // Hidden State (Caja negra)
                            const hx = 350, hy = 100;
                            ctx.fillStyle = "#3498db";
                            ctx.roundRect(hx, hy, 100, 60, 10); ctx.fill();
                            ctx.fillStyle = "white"; ctx.fillText("HIDDEN STATE", hx+50, hy+35);
                            
                            // Flechas flujo
                            if (step < seq.length) {
                                const currX = 100 + step * 50;
                                // Input a Hidden
                                ctx.beginPath(); ctx.moveTo(currX, 230); ctx.lineTo(hx+20, hy+60);
                                ctx.strokeStyle = "#f1c40f"; ctx.lineWidth=2; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
                                
                                // Recurrencia (Self-loop)
                                ctx.beginPath(); ctx.arc(hx+110, hy+30, 15, 1.5*Math.PI, 0.5*Math.PI);
                                ctx.stroke();
                            }
                            
                            frame++;
                            requestAnimationFrame(animateRNN);
                        };
                        animateRNN();
                    }
                    
                    // --- ANIMACIÓN AUTOENCODER (COMPRESSION) ---
                    else if (mode.includes('Autoencoder')) {
                        const animateAE = () => {
                            if(!document.body.contains(canvas)) return;
                            ctx.clearRect(0,0,800,350);
                            
                            const centerX = 400, centerY = 175;
                            
                            // Capas: Input(10) -> Enc(6) -> Latent(3) -> Dec(6) -> Output(10)
                            const layers = [10, 6, 2, 6, 10];
                            const layerX = [100, 250, 400, 550, 700];
                            
                            layers.forEach((count, lIdx) => {
                                const x = layerX[lIdx];
                                const stepY = 250 / count;
                                const startY = centerY - (count * stepY)/2;
                                
                                for(let i=0; i<count; i++) {
                                    const y = startY + i*stepY + stepY/2;
                                    
                                    // Nodo
                                    ctx.fillStyle = lIdx===2 ? "#e74c3c" : "#3498db"; // Latent space rojo
                                    ctx.beginPath(); ctx.arc(x, y, 6, 0, Math.PI*2); ctx.fill();
                                    
                                    // Conexiones a siguiente capa
                                    if(lIdx < layers.length - 1) {
                                        const nextCount = layers[lIdx+1];
                                        const nextStepY = 250 / nextCount;
                                        const nextStartY = centerY - (nextCount * nextStepY)/2;
                                        
                                        for(let j=0; j<nextCount; j++) {
                                            const nextY = nextStartY + j*nextStepY + nextStepY/2;
                                            
                                            // Animar flujo
                                            ctx.strokeStyle = "rgba(255,255,255,0.1)";
                                            ctx.lineWidth = 1;
                                            ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(layerX[lIdx+1], nextY); ctx.stroke();
                                            
                                            // Pulso viajero
                                            const offset = (frame % 50) / 50;
                                            const px = x + (layerX[lIdx+1] - x) * offset;
                                            const py = y + (nextY - y) * offset;
                                            
                                            // Solo dibujar algunas partículas para no saturar
                                            if (Math.random() > 0.98) {
                                                ctx.fillStyle = "white"; ctx.fillRect(px, py, 2, 2);
                                            }
                                        }
                                    }
                                }
                                
                                // Etiquetas
                                ctx.fillStyle = "#999"; ctx.font="12px Arial";
                                const label = lIdx===0?"Input":lIdx===2?"Latent (Z)":lIdx===4?"Reconstruction":"";
                                ctx.fillText(label, x, 330);
                            });
                            
                            frame++;
                            requestAnimationFrame(animateAE);
                        };
                        animateAE();
                    }
                    
                    // --- ANIMACIÓN TRANSFORMER (ATTENTION MAP) ---
                    else {
                        const animateAttn = () => {
                            if(!document.body.contains(canvas)) return;
                            ctx.clearRect(0,0,800,350);
                            
                            const seq = "M K L V I N G".split(' ');
                            const startX = 200, startY = 50;
                            const cellSize = 40;
                            
                            // Dibujar Matriz de Atención
                            for(let i=0; i<seq.length; i++) {
                                // Etiquetas Ejes
                                ctx.fillStyle = "white"; ctx.font="bold 14px monospace";
                                ctx.fillText(seq[i], startX - 20, startY + i*cellSize + 25);
                                ctx.fillText(seq[i], startX + i*cellSize + 15, startY - 10);
                                
                                for(let j=0; j<seq.length; j++) {
                                    // Calor simulado (Diagonal fuerte + aleatorio)
                                    let heat = 0;
                                    if(i===j) heat = 0.8; // Self
                                    else if (Math.abs(i-j)===3) heat = 0.6 + Math.sin(frame*0.1)*0.2; // Contacto distante
                                    else heat = Math.random()*0.2;
                                    
                                    ctx.fillStyle = `rgba(231, 76, 60, ${heat})`;
                                    ctx.fillRect(startX + j*cellSize, startY + i*cellSize, cellSize-2, cellSize-2);
                                }
                            }
                            
                            // Info lateral
                            ctx.fillStyle = "#ddd"; ctx.font="14px sans-serif";
                            ctx.fillText("Self-Attention Map", 550, 100);
                            ctx.font="12px sans-serif"; ctx.fillStyle = "#999";
                            ctx.fillText("Muestra qué residuos", 550, 130);
                            ctx.fillText("interactúan entre sí.", 550, 150);
                            
                            frame++;
                            requestAnimationFrame(animateAttn);
                        };
                        animateAttn();
                    }
                    
                    // 2. MONITOR DE ENTRENAMIENTO (ABAJO)
                    const monitorDiv = document.createElement('div');
                    monitorDiv.style.cssText = "width:95%; max-width:800px; height:150px; background:white; border-radius:8px; padding:15px; box-shadow:0 4px 10px rgba(0,0,0,0.1); flex-shrink:0; display:grid; grid-template-columns: 1fr 1fr; gap:20px;";
                    
                    // Gráfica Loss
                    const lossCanvas = document.createElement('canvas');
                    lossCanvas.style.width="100%"; lossCanvas.style.height="100%";
                    const accCanvas = document.createElement('canvas');
                    accCanvas.style.width="100%"; accCanvas.style.height="100%";
                    
                    monitorDiv.appendChild(lossCanvas);
                    monitorDiv.appendChild(accCanvas);
                    div.appendChild(monitorDiv);
                    
                    // Lógica simple de dibujo de curvas
                    setTimeout(() => {
                        // Simular curvas de entrenamiento
                        const drawCurve = (cnv, color, label) => {
                            cnv.width = cnv.offsetWidth; cnv.height = cnv.offsetHeight;
                            const c = cnv.getContext('2d');
                            const w = cnv.width, h = cnv.height;
                            
                            c.beginPath(); c.strokeStyle="#eee"; c.rect(0,0,w,h); c.stroke();
                            
                            c.beginPath();
                            c.strokeStyle = color; c.lineWidth = 2;
                            c.moveTo(0, h);
                            
                            for(let i=0; i<=w; i+=5) {
                                // Curva exponencial inversa
                                const x = i;
                                const y = h - (1 - Math.exp(-i/100)) * (h-20);
                                c.lineTo(x, label==='Loss'? (h-y)+20 : y);
                            }
                            c.stroke();
                            
                            c.fillStyle = "#333"; c.font="bold 12px sans-serif";
                            c.fillText(label, 10, 20);
                        };
                        
                        drawCurve(lossCanvas, "#e74c3c", "Training Loss");
                        drawCurve(accCanvas, "#2ecc71", "Validation Accuracy");
                    }, 500);
                    
                    // Botón Continuar
                    setTimeout(() => {
                        document.getElementById('continueBtn').style.display = 'block';
                    }, 3000);
                }
              }
        ];

        // --- FUNCIONES DEL SIMULADOR (se mantienen igual) ---
        let currentLesson = 0;
        const params = {};

        function init() {
            renderMenu();
            loadLesson(0);
            
            document.getElementById('continueBtn').addEventListener('click', () => {
                if(currentLesson < lessons.length - 1) {
                    loadLesson(currentLesson + 1);
                } else {
                    alert('¡Has completado todos los temas! 🎉');
                }
            });
        }

        function renderMenu() {
            const menu = document.getElementById('menuList');
            menu.innerHTML = '';
            
            lessons.forEach((lesson, idx) => {
                const item = document.createElement('a');
                item.className = `menu-item ${idx === currentLesson ? 'active' : ''}`;
                item.href = '#';
                item.onclick = (e) => {
                    e.preventDefault();
                    loadLesson(idx);
                };
                
                item.innerHTML = `
                    <div class="menu-icon">
                        <i class="fas ${lesson.icon}"></i>
                    </div>
                    <div class="menu-text">
                        <h4>${lesson.title}</h4>
                        <p>${lesson.desc}</p>
                    </div>
                `;
                
                menu.appendChild(item);
            });
            
            // Actualizar barra de progreso
            const progress = ((currentLesson + 1) / lessons.length) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
        }

        function loadLesson(idx) {
            currentLesson = idx;
            const lesson = lessons[idx];
            
            // Actualizar menú
            renderMenu();
            
            // Cargar controles
            renderControls(lesson.controls);
            
            // Cargar código
            updateCode(lesson.code(params));
            
            // Cargar explicación
            updateExplanation(lesson.explain(params));
            
            // Renderizar visualización
            lesson.render(params, document.getElementById('plotContent'));
            
            // Ocultar botón continuar inicialmente
            document.getElementById('continueBtn').style.display = 'none';
        }

        function renderControls(controls) {
            const controlsDiv = document.getElementById('controlsArea');
            controlsDiv.innerHTML = '';
            
            controls.forEach(control => {
                const group = document.createElement('div');
                group.className = 'control-group';
                
                const label = document.createElement('span');
                label.className = 'control-label';
                label.textContent = control.label;
                
                group.appendChild(label);
                
                if(control.type === 'select') {
                    const select = document.createElement('select');
                    select.id = `ctrl-${control.id}`;
                    
                    control.options.forEach(option => {
                        const opt = document.createElement('option');
                        opt.value = option;
                        opt.textContent = option;
                        if(option === (params[control.id] || control.options[0])) {
                            opt.selected = true;
                        }
                        select.appendChild(opt);
                    });
                    
                    select.onchange = (e) => {
                        params[control.id] = e.target.value;
                        updateLesson();
                    };
                    
                    group.appendChild(select);
                    
                } else if(control.type === 'range') {
                    const range = document.createElement('input');
                    range.type = 'range';
                    range.id = `ctrl-${control.id}`;
                    range.min = control.min;
                    range.max = control.max;
                    range.step = control.step || 1; 
                    range.value = params[control.id] || control.val;
                    
                    const value = document.createElement('span');
                    value.className = 'control-value';
                    value.textContent = range.value;
                    value.style.minWidth = '30px';
                    value.style.textAlign = 'right';
                    
                    // ONINPUT: Actualización visual rápida (sin lag)
                    range.oninput = (e) => {
                        value.textContent = e.target.value;
                    };

                    // ONCHANGE: Actualización lógica pesada (al soltar)
                    range.onchange = (e) => {
                        params[control.id] = parseFloat(e.target.value);
                        updateLesson();
                    };
                    
                    group.appendChild(range);
                    group.appendChild(value);
                }
                
                controlsDiv.appendChild(group);
                
                // Inicializar si no existe
                if(params[control.id] === undefined) {
                    params[control.id] = control.val !== undefined ? control.val : control.options[0];
                }
            });
        }

        function updateCode(code) {
            const editor = document.getElementById('codeEditor');
            editor.innerHTML = code;
        }

        function updateExplanation(html) {
            const explanation = document.getElementById('explanationText');
            explanation.innerHTML = html;
        }

        function updateLesson() {
            const lesson = lessons[currentLesson];
            updateCode(lesson.code(params));
            updateExplanation(lesson.explain(params));
            lesson.render(params, document.getElementById('plotContent'));
        }

        function showTooltip(e, event) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = e.target.dataset.tooltip;
            tooltip.style.left = event.clientX + 10 + 'px';
            tooltip.style.top = event.clientY + 10 + 'px';
            tooltip.style.opacity = '1';
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.opacity = '0';
        }

        // Inicializar simulador
        init();
    </script>

</body>
</html>
