
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algoritmos e Inteligencia Artificial</title>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        /* --- CONFIGURACI√ìN BASE --- */
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #252526;
            --text-main: #d4d4d4;
            --accent: #007acc;
            --keyword: #c586c0;
            --function: #dcdcaa;
            --string: #ce9178;
            --comment: #6a9955;
            --sidebar-w: 300px;
            --success: #4CAF50;
            --warning: #FF9800;
            --danger: #f44336;
            --info: #2196F3;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body { 
            background: var(--bg-dark); 
            font-family: 'Roboto', sans-serif; 
            color: var(--text-main); 
            height: 100vh; 
            display: flex; 
            overflow: hidden; 
        }

        /* --- SIDEBAR --- */
        .sidebar { 
            width: var(--sidebar-w); 
            background: #2d2d2d; 
            display: flex; 
            flex-direction: column; 
            border-right: 1px solid #000;
            min-width: 250px;
        }
        
        .header { 
            padding: 20px 15px; 
            background: linear-gradient(135deg, #007acc 0%, #005a9e 100%); 
            color: white; 
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .header h2 { 
            margin: 0 0 5px 0; 
            font-size: 1.1rem; 
            font-weight: 700; 
        }
        
        .header span { 
            font-size: 0.8rem; 
            opacity: 0.9; 
            display: block;
        }
        
        .menu { 
            flex: 1; 
            overflow-y: auto; 
            padding: 10px 0;
        }
        
        .menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 15px;
            color: #ccc;
            cursor: pointer;
            border-left: 4px solid transparent;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            transition: all 0.3s ease;
            text-decoration: none;
            position: relative;
            overflow: hidden;
        }
        
        .menu-item:hover { 
            background: rgba(255,255,255,0.05); 
            color: white; 
            padding-left: 18px;
        }
        
        .menu-item.active { 
            background: rgba(0, 122, 204, 0.15); 
            border-left-color: #007acc; 
            color: white; 
            font-weight: 600;
        }
        
        .menu-item.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 3px;
            background: #007acc;
            box-shadow: 0 0 10px #007acc;
        }
        
        .menu-icon {
            font-size: 1rem;
            width: 24px;
            text-align: center;
            color: #007acc;
        }
        
        .menu-item.active .menu-icon {
            color: white;
        }
        
        .menu-text h4 {
            margin: 0 0 4px 0;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .menu-text p {
            margin: 0;
            font-size: 0.75rem;
            color: #aaa;
            line-height: 1.3;
        }

        /* --- √ÅREA PRINCIPAL --- */
        .main { 
            flex: 1;
            display: flex; 
            flex-direction: row; /* Colocar paneles lado a lado */
            height: 100%; 
            overflow: hidden;
        }

        /* Columna Izquierda: Contiene C√≥digo y Explicaci√≥n */
        .left-column {
            flex: 4; /* 40% del ancho */
            display: flex;
            flex-direction: column;
            border-right: 1px solid rgba(255,255,255,0.1);
            min-width: 350px;
        }
        
        /* Contenedor Superior */
        .top-split { 
            flex: 4; /* ANTES ERA 2. Ahora ocupa 4 partes del espacio (80%) */
            display: flex; 
            border-bottom: 1px solid rgba(255,255,255,0.1); 
            overflow: hidden; 
            min-height: 0;
        }
        
        /* Panel C√≥digo */
        .code-panel { 
            flex: 3; /* Ocupa 60% de la altura izquierda */
            display: flex; 
            flex-direction: column; 
            background: #1e1e1e; 
            border-bottom: 1px solid rgba(255,255,255,0.1);
            overflow: hidden;
        }
        
        .panel-title { 
            background: #2d2d2d; 
            padding: 10px 15px; 
            font-size: 0.8rem; 
            text-transform: uppercase; 
            font-weight: 600; 
            color: #bbb; 
            display: flex; 
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .panel-title span:last-child {
            color: var(--success);
            font-weight: 500;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        
        .editor { 
            flex: 1; 
            padding: 20px; 
            font-family: 'Fira Code', monospace; 
            font-size: 0.9rem; 
            overflow: auto; 
            line-height: 1.6; 
            white-space: pre-wrap;
            background: #1e1e1e;
        }
        
        /* Sintaxis mejorada */
        .c-kwd { color: var(--keyword); font-weight: 500; } 
        .c-fn { color: var(--function); } 
        .c-str { color: var(--string); } 
        .c-com { color: var(--comment); font-style: italic; opacity: 0.9; }
        .c-arg { color: #9cdcfe; } 
        .c-num { color: #b5cea8; }
        .c-var { color: #569cd6; }
        .c-op { color: #d4d4d4; }

        /* Panel Gr√°fico */
        .viz-panel { 
            flex: 6; /* 60% del ancho total (M√°s espacio para la gr√°fica) */
            display: flex; 
            flex-direction: column; 
            background: #fff; 
            color: #333; 
            position: relative; 
            height: 100%; /* Altura completa */
        }
        
        .controls { 
            background: #f8f9fa; 
            padding: 12px 15px; 
            border-bottom: 1px solid #dee2e6; 
            display: flex; 
            gap: 15px; 
            flex-wrap: wrap; 
            align-items: center; 
            min-height: 50px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .control-label {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            white-space: nowrap;
            color: #495057;
        }
        
        .canvas { 
            flex: 1; 
            position: relative; 
            overflow: auto; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            background: linear-gradient(45deg, #f8f9fa 25%, #fff 25%, #fff 50%, #f8f9fa 50%, #f8f9fa 75%, #fff 75%, #fff);
            background-size: 20px 20px;
        }
        
        /* --- PANEL EXPLICACI√ìN --- */
        .explanation-panel { 
            flex: 2; /* Ocupa 40% de la altura izquierda */
            background: #252526; 
            padding: 15px; 
            overflow-y: auto; 
            font-family: 'Segoe UI', sans-serif; 
            border-top: 2px solid #007acc; /* Separador visual */
        }
        
        .exp-title { 
            color: #007acc; 
            font-weight: 600; 
            font-size: 1.2rem; 
            margin-bottom: 15px; 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .exp-text { 
            line-height: 1.7; 
            color: #e9ecef; 
            font-size: 0.95rem; 
        }
        
        .exp-text b {
            color: #007acc;
            font-weight: 600;
        }
        
        .exp-text i {
            color: #6a9955;
            font-style: italic;
        }
        
        .exp-highlight { 
            background: rgba(0, 122, 204, 0.15); 
            padding: 8px 12px; 
            border-radius: 6px; 
            color: #e9ecef; 
            border-left: 3px solid #007acc;
            margin: 10px 0;
        }
        
        .exp-note {
            background: rgba(255, 152, 0, 0.1);
            padding: 8px 12px;
            border-radius: 6px;
            color: #ffcc80;
            border-left: 3px solid #FF9800;
            margin: 10px 0;
            font-size: 0.9rem;
        }

        /* --- CONTROLES UI MEJORADOS --- */
        select, input[type="range"] { 
            padding: 6px 10px; 
            border: 1px solid #ced4da; 
            border-radius: 4px; 
            font-size: 0.8rem; 
            background: white;
            transition: all 0.2s;
        }
        
        select:focus, input[type="range"]:focus {
            outline: none;
            border-color: #007acc;
            box-shadow: 0 0 0 3px rgba(0,122,204,0.1);
        }
        
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        /* --- GR√ÅFICOS Y ANIMACIONES --- */
        .dot { 
            position: absolute; 
            width: 12px; 
            height: 12px; 
            border-radius: 50%; 
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); 
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            border: 2px solid white;
        }
        
        .cluster-center {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 3px solid #000;
            background: #fff;
            transform: rotate(45deg);
            z-index: 10;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }
        
        .tree-node {
            position: absolute;
            background: white;
            border: 2px solid;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.8rem;
            text-align: center;
            min-width: 80px;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
            z-index: 10;
            transition: all 0.3s;
        }
        
        .tree-node:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .tree-line {
            position: absolute;
            background: #666;
            transform-origin: top left;
        }
        
        .svm-boundary {
            position: absolute;
            border: 2px dashed;
            border-radius: 50%;
            pointer-events: none;
            transition: all 0.5s;
        }
        
        /* Barras (VarImp) */
        .bar-container { 
            width: 90%; 
            display: flex; 
            flex-direction: column; 
            gap: 12px; 
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .bar-row { 
            display: flex; 
            align-items: center; 
            gap: 15px; 
        }
        
        .bar-label { 
            width: 120px; 
            text-align: right; 
            font-size: 0.8rem; 
            font-weight: 600;
            color: #333;
        }
        
        .bar-bg { 
            flex: 1; 
            background: #e9ecef; 
            height: 20px; 
            border-radius: 10px; 
            overflow: hidden; 
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .bar-fill { 
            height: 100%; 
            background: linear-gradient(90deg, #007acc, #00bcd4); 
            width: 0%; 
            transition: width 1s cubic-bezier(0.4, 0, 0.2, 1); 
            border-radius: 10px;
        }
        
        .bar-value {
            width: 40px;
            text-align: center;
            font-size: 0.8rem;
            font-weight: 600;
            color: #333;
        }

        /* PCA 3D */
        .scene-3d {
            width: 300px;
            height: 300px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 1s ease;
            perspective: 1000px;
        }
        
        .axis-3d {
            position: absolute;
            background: #333;
            transform-origin: 0 0;
        }
        
        /* Tooltip */
        .tooltip { 
            position: absolute; 
            background: rgba(0,0,0,0.9); 
            color: white; 
            padding: 8px 12px; 
            border-radius: 6px; 
            font-size: 0.8rem; 
            pointer-events: none; 
            opacity: 0; 
            z-index: 1000; 
            transition: opacity 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            max-width: 200px;
            white-space: nowrap;
        }
        
        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(0,0,0,0.9) transparent transparent transparent;
        }

        /* Scrollbar personalizado */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #2d2d2d;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #666;
        }

        /* Animaciones */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }

        /* Ajustes responsive */
        @media (max-width: 1000px) {
            .main { flex-direction: column; }
            .left-column { width: 100%; height: 50%; border-right: none; }
            .viz-panel { width: 100%; height: 50%; }
        }
            
            .top-split {
                flex-direction: column;
            }
            
            .code-panel, .viz-panel {
                min-height: 300px;
            }
            
            .code-panel {
                border-right: none;
                border-bottom: 1px solid rgba(255,255,255,0.1);
            }
        }

    </style>
</head>
<body>

    <div class="sidebar">
        <div class="header">
            <h2>M√ÅSTER BIOINFORM√ÅTICA</h2>
            <span>Algoritmos e Inteligencia Artificial</span>
        </div>
        <div class="menu" id="menuList"></div>
    </div>

    <div class="main">
        
        <div class="left-column">
            
            <div class="code-panel">
                <div class="panel-title">
                    <span><i class="fas fa-file-code"></i> Script R</span>
                    <span><i class="fas fa-circle"></i> LIVE</span>
                </div>
                <div class="editor" id="codeEditor"></div>
            </div>

            <div class="explanation-panel">
                <div class="exp-title"><i class="fas fa-chalkboard-teacher"></i> Explicaci√≥n del Profesor</div>
                <div class="exp-text" id="explanationText"></div>
            </div>

        </div>

        <div class="viz-panel">
            <div class="controls" id="controlsArea"></div>
            <div class="canvas" id="canvasArea">
                <div id="plotContent" style="width:100%; height:100%; position:relative; display:flex; justify-content:center; align-items:center;"></div>
                <div class="tooltip" id="tooltip"></div>
            </div>
        </div>

    </div>

    <script>
        // --- BASE DE DATOS DE LOS 10 TEMAS COMPLETOS Y MEJORADOS ---
        const lessons = [
            {
                id: 1,
                title: "Tema 1. Intro & Preprocesamiento",
                desc: "Escalado y Normalizaci√≥n",
                icon: "fa-sliders-h",
                controls: [
                    {id: 'method', type: 'select', label: 'T√©cnica Caret', options: ['raw (Datos Crudos)', 'center (Media=0)', 'scale (SD=1)', 'range (0-1)']},
                    {id: 'outlier', type: 'checkbox', label: 'A√±adir Outliers', value: false}
                ],
                code: (p) => `
<span class="c-com"># TEMA 1: PREPROCESAMIENTO CON CARET</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(caret)
<span class="c-kwd">library</span>(ggplot2)

<span class="c-com"># 1. Cargar datos cl√≠nicos simulados</span>
<span class="c-kwd">set.seed</span>(123)
datos <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">Edad</span> = <span class="c-fn">round</span>(<span class="c-fn">runif</span>(100, 20, 80)),
  <span class="c-arg">Expresion_Genica</span> = <span class="c-fn">round</span>(<span class="c-fn">runif</span>(100, 100, 5000))
)

<span class="c-com"># 2. Configurar m√©todo de preprocesamiento</span>
metodo <- <span class="c-str">"${p.method.split(' ')[0]}"</span>
modelo_pp <- <span class="c-fn">preProcess</span>(datos, 
                    <span class="c-arg">method</span> = <span class="c-fn">c</span>(metodo))

<span class="c-com"># 3. Aplicar transformaci√≥n</span>
datos_norm <- <span class="c-fn">predict</span>(modelo_pp, datos)

<span class="c-com"># 4. Visualizaci√≥n comparativa</span>
<span class="c-fn">par</span>(<span class="c-arg">mfrow</span> = <span class="c-fn">c</span>(1, 2))
<span class="c-fn">plot</span>(datos<span class="c-var">$Edad</span>, datos<span class="c-var">$Expresion_Genica</span>,
     <span class="c-arg">main</span> = <span class="c-str">"Datos Originales"</span>,
     <span class="c-arg">xlab</span> = <span class="c-str">"Edad"</span>, <span class="c-arg">ylab</span> = <span class="c-str">"Expresi√≥n G√©nica"</span>)

<span class="c-fn">plot</span>(datos_norm<span class="c-var">$Edad</span>, datos_norm<span class="c-var">$Expresion_Genica</span>,
     <span class="c-arg">main</span> = <span class="c-str">"Datos Normalizados ("</span> + metodo + <span class="c-str">")"</span>,
     <span class="c-arg">xlab</span> = <span class="c-str">"Edad (norm)"</span>, <span class="c-arg">ylab</span> = <span class="c-str">"Expresi√≥n (norm)"</span>)

<span class="c-com"># 5. Estad√≠sticas resumen</span>
<span class="c-fn">cat</span>(<span class="c-str">"\\n=== RESUMEN ESTAD√çSTICO ===\\n"</span>)
<span class="c-fn">print</span>(<span class="c-fn">summary</span>(datos_norm))`,
                explain: (p) => {
                    let m = p.method.split(' ')[0];
                    if(m === 'raw') return `
                        <div class="exp-highlight">
                            <b>üìä Datos Crudos:</b> Observa la escala de los ejes. El eje Y (Expresi√≥n G√©nica) tiene valores entre 100-5000, mientras el eje X (Edad) est√° entre 20-80.
                        </div>
                        <p><b>Problema:</b> Los algoritmos basados en distancias (K-NN, SVM) dar√°n mucha m√°s importancia al eje Y porque los valores son m√°s grandes.</p>
                        <div class="exp-note">
                            <i class="fas fa-exclamation-triangle"></i> <b>Consecuencia:</b> Un paciente de 30 a√±os con expresi√≥n 4500 se considerar√° m√°s similar a uno de 80 a√±os con expresi√≥n 4600 que a uno de 31 a√±os con expresi√≥n 200.
                        </div>`;
                    if(m === 'center') return `
                        <div class="exp-highlight">
                            <b>üéØ Center (Centrado):</b> Restamos la media a cada variable. Ahora todas tienen media = 0.
                        </div>
                        <p><b>Ventaja:</b> Eliminamos el sesgo de ubicaci√≥n. <b>Limitaci√≥n:</b> No corregimos las diferencias de escala entre variables.</p>
                        <p><i>F√≥rmula:</i> x' = x - Œº</p>`;
                    if(m === 'scale') return `
                        <div class="exp-highlight">
                            <b>‚öñÔ∏è Scale (Estandarizaci√≥n):</b> Dividimos por la desviaci√≥n est√°ndar. Todas las variables ahora tienen media = 0 y desviaci√≥n est√°ndar = 1.
                        </div>
                        <p><b>Ventaja:</b> Variables comparables en escala. <b>Esencial para:</b> PCA, SVM, K-means, LDA.</p>
                        <p><i>F√≥rmula:</i> x' = (x - Œº) / œÉ</p>
                        <div class="exp-note">
                            <i class="fas fa-check-circle"></i> <b>Recomendado:</b> Usar scale cuando no conozcas la distribuci√≥n de tus datos.
                        </div>`;
                    return `
                        <div class="exp-highlight">
                            <b>üìà Range (Normalizaci√≥n Min-Max):</b> Escalamos todos los valores al rango [0, 1].
                        </div>
                        <p><b>Ventaja:</b> Valores acotados, √∫til para redes neuronales. <b>Limitaci√≥n:</b> Sensible a outliers.</p>
                        <p><i>F√≥rmula:</i> x' = (x - min) / (max - min)</p>
                        <div class="exp-note">
                            <i class="fas fa-lightbulb"></i> <b>Tip:</b> Usar range cuando trabajes con algoritmos sensibles a la escala como redes neuronales o K-NN.
                        </div>`;
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    const m = p.method.split(' ')[0];
                    
                    // Crear contenedor para los dos gr√°ficos
                    const container = document.createElement('div');
                    container.style.cssText = `
                        display: flex;
                        width: 100%;
                        height: 100%;
                        padding: 20px;
                        gap: 30px;
                    `;
                    
                    // Gr√°fico original
                    const originalDiv = document.createElement('div');
                    originalDiv.style.cssText = `
                        flex: 1;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        position: relative;
                    `;
                    
                    const originalTitle = document.createElement('div');
                    originalTitle.innerHTML = `<b style="color:#333;">Datos Originales</b>`;
                    originalTitle.style.cssText = 'margin-bottom: 15px; font-size: 0.9rem;';
                    originalDiv.appendChild(originalTitle);
                    
                    // Ejes originales
                    const axisX1 = document.createElement('div');
                    axisX1.style.cssText = `
                        position: absolute;
                        bottom: 20px;
                        width: calc(100% - 40px);
                        border-top: 2px solid #333;
                        text-align: center;
                        font-size: 11px;
                        color: #333;
                        padding-top: 5px;
                    `;
                    axisX1.innerText = "Edad (20-80 a√±os)";
                    originalDiv.appendChild(axisX1);
                    
                    const axisY1 = document.createElement('div');
                    axisY1.style.cssText = `
                        position: absolute;
                        left: 20px;
                        height: calc(100% - 40px);
                        border-left: 2px solid #333;
                        display: flex;
                        align-items: center;
                        font-size: 11px;
                        writing-mode: vertical-rl;
                        transform: rotate(180deg);
                        color: #333;
                        padding-left: 5px;
                    `;
                    axisY1.innerText = "Expresi√≥n G√©nica (100-5000)";
                    originalDiv.appendChild(axisY1);
                    
                    // Puntos originales
                    for(let i=0; i<40; i++) {
                        const x = Math.random() * 80 + 10;
                        const y = Math.random() * 30 + 35;
                        const dot = document.createElement('div');
                        dot.className = 'dot';
                        dot.style.left = x + '%';
                        dot.style.top = y + '%';
                        dot.style.backgroundColor = '#007acc';
                        dot.dataset.tooltip = `Edad: ${Math.round((x/100)*60+20)}, Expresi√≥n: ${Math.round((y/100)*4900+100)}`;
                        dot.onmouseover = showTooltip;
                        dot.onmouseout = hideTooltip;
                        originalDiv.appendChild(dot);
                    }
                    
                    // Gr√°fico normalizado
                    const normalizedDiv = document.createElement('div');
                    normalizedDiv.style.cssText = `
                        flex: 1;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        position: relative;
                    `;
                    
                    const normalizedTitle = document.createElement('div');
                    normalizedTitle.innerHTML = `<b style="color:#333;">Datos Normalizados (${m})</b>`;
                    normalizedTitle.style.cssText = 'margin-bottom: 15px; font-size: 0.9rem;';
                    normalizedDiv.appendChild(normalizedTitle);
                    
                    // Ejes normalizados
                    const axisX2 = document.createElement('div');
                    axisX2.style.cssText = axisX1.style.cssText;
                    axisX2.innerText = m === 'raw' ? "Edad" : "Variable X (normalizada)";
                    normalizedDiv.appendChild(axisX2);
                    
                    const axisY2 = document.createElement('div');
                    axisY2.style.cssText = axisY1.style.cssText;
                    axisY2.innerText = m === 'raw' ? "Expresi√≥n G√©nica" : "Variable Y (normalizada)";
                    normalizedDiv.appendChild(axisY2);
                    
                    // Puntos normalizados
                    for(let i=0; i<40; i++) {
                        let x = Math.random() * 80 + 10;
                        let y = Math.random() * 30 + 35;
                        
                        if(m !== 'raw') {
                            // Simular normalizaci√≥n
                            x = 50 + (Math.random() - 0.5) * (m === 'range' ? 30 : 60);
                            y = 50 + (Math.random() - 0.5) * (m === 'range' ? 30 : 60);
                        }
                        
                        const dot = document.createElement('div');
                        dot.className = 'dot';
                        dot.style.left = x + '%';
                        dot.style.top = y + '%';
                        dot.style.backgroundColor = m === 'raw' ? '#007acc' : 
                                                   m === 'center' ? '#00bcd4' : 
                                                   m === 'scale' ? '#4CAF50' : '#FF9800';
                        dot.dataset.tooltip = `X: ${(x/100).toFixed(2)}, Y: ${(y/100).toFixed(2)}`;
                        dot.onmouseover = showTooltip;
                        dot.onmouseout = hideTooltip;
                        normalizedDiv.appendChild(dot);
                    }
                    
                    // Outlier si est√° activado
                    if(p.outlier) {
                        const outlier = document.createElement('div');
                        outlier.className = 'dot';
                        outlier.style.backgroundColor = '#f44336';
                        outlier.style.width = '15px';
                        outlier.style.height = '15px';
                        outlier.style.zIndex = '100';
                        
                        if(m === 'range') {
                            outlier.style.left = '95%';
                            outlier.style.top = '95%';
                        } else if(m === 'raw') {
                            outlier.style.left = '90%';
                            outlier.style.top = '10%';
                        } else {
                            outlier.style.left = '90%';
                            outlier.style.top = '10%';
                        }
                        
                        outlier.dataset.tooltip = 'OUTLIER: Valor at√≠pico que distorsiona la normalizaci√≥n';
                        outlier.onmouseover = showTooltip;
                        outlier.onmouseout = hideTooltip;
                        normalizedDiv.appendChild(outlier);
                    }
                    
                    container.appendChild(originalDiv);
                    container.appendChild(normalizedDiv);
                    div.appendChild(container);
                }
            },
            {
                id: 2,
                title: "Tema 2. Reducci√≥n Dim. I",
                desc: "PCA vs t-SNE",
                icon: "fa-project-diagram",
                controls: [
                    {id: 'algo', type: 'select', label: 'Algoritmo', options: ['PCA (Lineal)', 't-SNE (No Lineal)']},
                    {id: 'view', type: 'checkbox', label: 'Vista 3D', value: false}
                ],
                code: (p) => `
<span class="c-com"># TEMA 2: REDUCCI√ìN DE DIMENSIONALIDAD</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(FactoMineR)
<span class="c-kwd">library</span>(Rtsne)
<span class="c-kwd">library</span>(ggplot2)

<span class="c-com"># 1. Datos de expresi√≥n g√©nica (100 genes √ó 50 muestras)</span>
<span class="c-kwd">set.seed</span>(123)
datos_expresion <- <span class="c-fn">matrix</span>(
  <span class="c-fn">rnorm</span>(100 * 50, mean = 0, sd = 1),
  <span class="c-arg">nrow</span> = 50,
  <span class="c-arg">ncol</span> = 100
)
<span class="c-fn">colnames</span>(datos_expresion) <- <span class="c-fn">paste0</span>(<span class="c-str">"Gen_"</span>, 1:100)
<span class="c-fn">rownames</span>(datos_expresion) <- <span class="c-fn">paste0</span>(<span class="c-str">"Muestra_"</span>, 1:50)

<span class="c-com"># 2. Grupos biol√≥gicos simulados (2 grupos)</span>
grupos <- <span class="c-fn">rep</span>(<span class="c-fn">c</span>(<span class="c-str">"Control"</span>, <span class="c-str">"Tratamiento"</span>), each = 25)

<span class="c-kwd">if</span> (<span class="c-str">"${p.algo}"</span> == <span class="c-str">"PCA (Lineal)"</span>) {
  
  <span class="c-com"># 3. AN√ÅLISIS DE COMPONENTES PRINCIPALES (PCA)</span>
  <span class="c-com"># Transformaci√≥n lineal que maximiza la varianza</span>
  pca_result <- <span class="c-fn">PCA</span>(datos_expresion,
                   <span class="c-arg">scale.unit</span> = TRUE,
                   <span class="c-arg">graph</span> = FALSE)
  
  <span class="c-com"># 4. Varianza explicada por cada componente</span>
  var_explicada <- <span class="c-fn">round</span>(pca_result<span class="c-var">$eig</span>[, 2], 1)
  <span class="c-fn">cat</span>(<span class="c-str">"Varianza explicada:\\n"</span>)
  <span class="c-fn">print</span>(var_explicada[1:5])
  
  <span class="c-com"># 5. Visualizaci√≥n 2D/3D</span>
  <span class="c-kwd">if</span> (${p.view}) {
    <span class="c-com"># Plot 3D de los primeros 3 componentes</span>
    <span class="c-kwd">library</span>(plotly)
    plot_ly(<span class="c-arg">x</span> = pca_result<span class="c-var">$ind</span><span class="c-var">$coord</span>[,1],
            <span class="c-arg">y</span> = pca_result<span class="c-var">$ind</span><span class="c-var">$coord</span>[,2],
            <span class="c-arg">z</span> = pca_result<span class="c-var">$ind</span><span class="c-var">$coord</span>[,3],
            <span class="c-arg">color</span> = grupos,
            <span class="c-arg">type</span> = <span class="c-str">"scatter3d"</span>,
            <span class="c-arg">mode</span> = <span class="c-str">"markers"</span>)
  } <span class="c-kwd">else</span> {
    <span class="c-com"># Plot 2D tradicional</span>
    <span class="c-fn">plot</span>(pca_result<span class="c-var">$ind</span><span class="c-var">$coord</span>[,1:2],
         <span class="c-arg">col</span> = <span class="c-fn">factor</span>(grupos),
         <span class="c-arg">pch</span> = 19,
         <span class="c-arg">main</span> = <span class="c-str">"PCA: Componentes 1 vs 2"</span>)
    <span class="c-fn">legend</span>(<span class="c-str">"topright"</span>, <span class="c-arg">legend</span> = <span class="c-fn">levels</span>(<span class="c-fn">factor</span>(grupos)),
           <span class="c-arg">col</span> = 1:2, <span class="c-arg">pch</span> = 19)
  }
  
} <span class="c-kwd">else</span> {
  
  <span class="c-com"># 6. t-SNE (t-Distributed Stochastic Neighbor Embedding)</span>
  <span class="c-com"># T√©cnica no lineal para visualizaci√≥n</span>
  tsne_result <- <span class="c-fn">Rtsne</span>(datos_expresion,
                    <span class="c-arg">perplexity</span> = 30,
                    <span class="c-arg">theta</span> = 0.5,
                    <span class="c-arg">dims</span> = ${p.view ? 3 : 2},
                    <span class="c-arg">verbose</span> = TRUE)
  
  <span class="c-com"># 7. Visualizaci√≥n t-SNE</span>
  <span class="c-kwd">if</span> (${p.view}) {
    <span class="c-kwd">library</span>(plotly)
    plot_ly(<span class="c-arg">x</span> = tsne_result<span class="c-var">$Y</span>[,1],
            <span class="c-arg">y</span> = tsne_result<span class="c-var">$Y</span>[,2],
            <span class="c-arg">z</span> = tsne_result<span class="c-var">$Y</span>[,3],
            <span class="c-arg">color</span> = grupos,
            <span class="c-arg">type</span> = <span class="c-str">"scatter3d"</span>,
            <span class="c-arg">mode</span> = <span class="c-str">"markers"</span>)
  } <span class="c-kwd">else</span> {
    <span class="c-fn">plot</span>(tsne_result<span class="c-var">$Y</span>,
         <span class="c-arg">col</span> = <span class="c-fn">factor</span>(grupos),
         <span class="c-arg">pch</span> = 19,
         <span class="c-arg">main</span> = <span class="c-str">"t-SNE: Proyecci√≥n 2D"</span>,
         <span class="c-arg">xlab</span> = <span class="c-str">"t-SNE 1"</span>,
         <span class="c-arg">ylab</span> = <span class="c-str">"t-SNE 2"</span>)
  }
}`,
                explain: (p) => {
                    if(p.algo === 'PCA (Lineal)') {
                        return `
                        <div class="exp-highlight">
                            <b>üìê PCA (An√°lisis de Componentes Principales)</b>
                        </div>
                        
                        <p><b>Concepto:</b> Transformaci√≥n lineal ortogonal que convierte datos correlacionados en componentes principales no correlacionados.</p>
                        
                        <p><b>Matem√°ticamente:</b></p>
                        <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                            PC‚ÇÅ = w‚ÇÅ‚ÇÅX‚ÇÅ + w‚ÇÅ‚ÇÇX‚ÇÇ + ... + w‚ÇÅ‚ÇöX‚Çö<br>
                            PC‚ÇÇ = w‚ÇÇ‚ÇÅX‚ÇÅ + w‚ÇÇ‚ÇÇX‚ÇÇ + ... + w‚ÇÇ‚ÇöX‚Çö
                        </p>
                        
                        <p><b>Propiedades clave:</b></p>
                        <ul>
                            <li>üìà PC‚ÇÅ explica la m√°xima varianza posible</li>
                            <li>üìâ Cada PC sucesivo explica la m√°xima varianza restante</li>
                            <li>‚öñÔ∏è Los componentes son ortogonales (no correlacionados)</li>
                            <li>üéØ La suma de varianzas se mantiene</li>
                        </ul>
                        
                        ${p.view ? `
                        <div class="exp-note">
                            <i class="fas fa-cube"></i> <b>Vista 3D:</b> Observa c√≥mo PCA rota el espacio 3D original para alinearse con las direcciones de m√°xima varianza.
                        </div>
                        ` : ''}
                        
                        <div class="exp-highlight">
                            <b>üöÄ Aplicaciones en Bioinform√°tica:</b>
                            <p>1. <b>Visualizaci√≥n de datos √≥micos</b></p>
                            <p>2. <b>Eliminaci√≥n de ruido t√©cnico</b></p>
                            <p>3. <b>Detecci√≥n de batch effects</b></p>
                            <p>4. <b>Reducci√≥n de dimensionalidad para ML</b></p>
                        </div>`;
                    } else {
                        return `
                        <div class="exp-highlight">
                            <b>üåÄ t-SNE (t-Distributed Stochastic Neighbor Embedding)</b>
                        </div>
                        
                        <p><b>Concepto:</b> T√©cnica no lineal que preserva la estructura local de los datos en alta dimensi√≥n.</p>
                        
                        <p><b>Algoritmo en dos pasos:</b></p>
                        <p>1. <b>Espacio original:</b> Calcula probabilidades de vecindad usando distribuci√≥n Gaussiana</p>
                        <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                            p‚±º‚Çó·µ¢ = exp(-||x·µ¢ - x‚±º||¬≤ / 2œÉ·µ¢¬≤) / Œ£‚Çñ‚â†·µ¢ exp(-||x·µ¢ - x‚Çñ||¬≤ / 2œÉ·µ¢¬≤)
                        </p>
                        <p>2. <b>Espacio reducido:</b> Usa distribuci√≥n t de Student para evitar el "crowding problem"</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-exclamation-triangle"></i> <b>¬°Atenci√≥n! t-SNE NO preserva:</b>
                            <p>‚Ä¢ Distancias globales entre clusters</p>
                            <p>‚Ä¢ La densidad de puntos</p>
                            <p>‚Ä¢ La escala del espacio</p>
                        </div>
                        
                        ${p.view ? `
                        <div class="exp-note">
                            <i class="fas fa-cube"></i> <b>Vista 3D:</b> t-SNE puede proyectar a 3D, pero es computacionalmente costoso y raramente usado.
                        </div>
                        ` : ''}
                        
                        <div class="exp-highlight">
                            <b>üéØ Cu√°ndo usar PCA vs t-SNE:</b>
                            <p><b>PCA:</b> An√°lisis exploratorio, eliminaci√≥n de ruido, datos lineales</p>
                            <p><b>t-SNE:</b> Visualizaci√≥n de clusters complejos, datos no lineales, pattern discovery</p>
                        </div>`;
                    }
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    const isPCA = p.algo === 'PCA (Lineal)';
                    const is3D = p.view;
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        flex-direction: column;
                        gap: 20px;
                    `;
                    
                    if(is3D) {
                        // Visualizaci√≥n 3D
                        const scene3D = document.createElement('div');
                        scene3D.className = 'scene-3d';
                        scene3D.style.cssText = `
                            width: 300px;
                            height: 300px;
                            background: white;
                            border-radius: 10px;
                            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            position: relative;
                            transform: rotateX(60deg) rotateZ(45deg);
                        `;
                        
                        // Ejes 3D
                        const xAxis = document.createElement('div');
                        xAxis.style.cssText = `
                            position: absolute;
                            left: 50%;
                            top: 50%;
                            width: 200px;
                            height: 2px;
                            background: #f44336;
                            transform: translate(-50%, -50%) rotateY(90deg);
                        `;
                        
                        const yAxis = document.createElement('div');
                        yAxis.style.cssText = `
                            position: absolute;
                            left: 50%;
                            top: 50%;
                            width: 200px;
                            height: 2px;
                            background: #4CAF50;
                            transform: translate(-50%, -50%) rotateX(90deg);
                        `;
                        
                        const zAxis = document.createElement('div');
                        zAxis.style.cssText = `
                            position: absolute;
                            left: 50%;
                            top: 50%;
                            width: 200px;
                            height: 2px;
                            background: #2196F3;
                            transform: translate(-50%, -50%);
                        `;
                        
                        scene3D.appendChild(xAxis);
                        scene3D.appendChild(yAxis);
                        scene3D.appendChild(zAxis);
                        
                        // Puntos 3D
                        const numPoints = 40;
                        for(let i = 0; i < numPoints; i++) {
                            const point = document.createElement('div');
                            const x = Math.random() * 160 + 20;
                            const y = Math.random() * 160 + 20;
                            const z = Math.random() * 160 + 20;
                            const isGroup1 = i < numPoints/2;
                            
                            point.style.cssText = `
                                position: absolute;
                                width: 8px;
                                height: 8px;
                                border-radius: 50%;
                                background: ${isGroup1 ? '#007acc' : '#FF9800'};
                                left: ${x}px;
                                top: ${y}px;
                                transform: translateZ(${z}px);
                                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                            `;
                            
                            if(isPCA) {
                                // PCA: puntos m√°s organizados en el espacio 3D
                                point.style.transform = `translateZ(${z}px) rotateX(${is3D ? 60 : 0}deg) rotateZ(${is3D ? 45 : 0}deg)`;
                            }
                            
                            scene3D.appendChild(point);
                        }
                        
                        container.appendChild(scene3D);
                        
                        const label = document.createElement('div');
                        label.innerHTML = `<b style="color:#333;">${isPCA ? 'PCA 3D - Componentes 1, 2 y 3' : 't-SNE 3D - Proyecci√≥n no lineal'}</b>`;
                        label.style.cssText = 'font-size: 0.9rem; text-align: center;';
                        container.appendChild(label);
                    } else {
                        // Visualizaci√≥n 2D
                        const plot2D = document.createElement('div');
                        plot2D.style.cssText = `
                            width: 400px;
                            height: 400px;
                            background: white;
                            border-radius: 10px;
                            padding: 20px;
                            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            position: relative;
                        `;
                        
                        // T√≠tulo
                        const title = document.createElement('div');
                        title.innerHTML = `<b style="color:#333; font-size:1rem;">${isPCA ? 'PCA - Proyecci√≥n Lineal' : 't-SNE - Proyecci√≥n No Lineal'}</b>`;
                        title.style.cssText = 'margin-bottom: 15px; text-align: center;';
                        plot2D.appendChild(title);
                        
                        // Ejes
                        const axisX = document.createElement('div');
                        axisX.style.cssText = `
                            position: absolute;
                            bottom: 20px;
                            left: 20px;
                            right: 20px;
                            border-top: 2px solid #333;
                            text-align: center;
                            padding-top: 5px;
                            font-size: 11px;
                            color: #333;
                        `;
                        axisX.textContent = isPCA ? 'Componente Principal 1' : 't-SNE 1';
                        plot2D.appendChild(axisX);
                        
                        const axisY = document.createElement('div');
                        axisY.style.cssText = `
                            position: absolute;
                            left: 20px;
                            top: 20px;
                            bottom: 40px;
                            border-left: 2px solid #333;
                            display: flex;
                            align-items: center;
                            padding-left: 5px;
                            font-size: 11px;
                            writing-mode: vertical-rl;
                            transform: rotate(180deg);
                            color: #333;
                        `;
                        axisY.textContent = isPCA ? 'Componente Principal 2' : 't-SNE 2';
                        plot2D.appendChild(axisY);
                        
                        // Puntos
                        const numPoints = 60;
                        for(let i = 0; i < numPoints; i++) {
                            let x, y;
                            const isGroup1 = i < numPoints/2;
                            
                            if(isPCA) {
                                // PCA: distribuci√≥n m√°s lineal/el√≠ptica
                                x = 50 + (Math.random() - 0.5) * 80;
                                y = 50 + (Math.random() - 0.5) * 40 + (isGroup1 ? 20 : -20);
                            } else {
                                // t-SNE: clusters m√°s definidos y separados
                                const clusterX = isGroup1 ? 30 : 70;
                                const clusterY = isGroup1 ? 30 : 70;
                                x = clusterX + (Math.random() - 0.5) * 25;
                                y = clusterY + (Math.random() - 0.5) * 25;
                            }
                            
                            const point = document.createElement('div');
                            point.className = 'dot';
                            point.style.left = x + '%';
                            point.style.top = y + '%';
                            point.style.backgroundColor = isGroup1 ? '#007acc' : '#FF9800';
                            point.style.borderColor = 'white';
                            
                            plot2D.appendChild(point);
                        }
                        
                        container.appendChild(plot2D);
                    }
                    
                    div.appendChild(container);
                }
            },
            {
                id: 3,
                title: "Tema 3. Reducci√≥n Dim. II",
                desc: "UMAP & Manifolds",
                icon: "fa-map",
                controls: [
                    {id: 'nn', type: 'range', label: 'Vecinos', min: 2, max: 50, val: 15},
                    {id: 'dist', type: 'range', label: 'Distancia M√≠n', min: 1, max: 99, val: 10}
                ],
                code: (p) => `
<span class="c-com"># TEMA 3: UMAP - APRENDIZAJE DE VARIEDADES</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(uwot)
<span class="c-kwd">library</span>(ggplot2)

<span class="c-com"># 1. Datos complejos (forma de "Swiss Roll" o "S")</span>
<span class="c-kwd">set.seed</span>(123)
n <- 300
t <- <span class="c-fn">runif</span>(n) * 3 * pi
x <- t * <span class="c-fn">cos</span>(t)
y <- 20 * <span class="c-fn">runif</span>(n)
z <- t * <span class="c-fn">sin</span>(t)

datos_3d <- <span class="c-fn">data.frame</span>(<span class="c-arg">x</span> = x, <span class="c-arg">y</span> = y, <span class="c-arg">z</span> = z)
grupos <- <span class="c-fn">cut</span>(t, 3, <span class="c-arg">labels</span> = <span class="c-fn">c</span>(<span class="c-str">"A"</span>, <span class="c-str">"B"</span>, <span class="c-str">"C"</span>))

<span class="c-com"># 2. Configurar par√°metros UMAP</span>
n_vecinos <- <span class="c-num">${p.nn}</span>
dist_min <- <span class="c-num">${p.dist / 100}</span>

<span class="c-com"># 3. Ejecutar UMAP</span>
umap_result <- <span class="c-fn">umap</span>(
  datos_3d,
  <span class="c-arg">n_neighbors</span> = n_vecinos,
  <span class="c-arg">min_dist</span> = dist_min,
  <span class="c-arg">n_components</span> = 2,
  <span class="c-arg">metric</span> = <span class="c-str">"euclidean"</span>,
  <span class="c-arg">learning_rate</span> = 1.0,
  <span class="c-arg">n_epochs</span> = 500
)

<span class="c-com"># 4. Visualizaci√≥n resultados</span>
umap_df <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">UMAP1</span> = umap_result[,1],
  <span class="c-arg">UMAP2</span> = umap_result[,2],
  <span class="c-arg">Grupo</span> = grupos
)

ggplot(umap_df, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = UMAP1, <span class="c-arg">y</span> = UMAP2, <span class="c-arg">color</span> = Grupo)) +
  <span class="c-fn">geom_point</span>(<span class="c-arg">size</span> = 3, <span class="c-arg">alpha</span> = 0.7) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">ggtitle</span>(<span class="c-str">"UMAP: Proyecci√≥n de Variedad (Manifold)"</span>) +
  <span class="c-fn">labs</span>(
    <span class="c-arg">subtitle</span> = <span class="c-fn">paste</span>(<span class="c-str">"n_neighbors ="</span>, n_vecinos, 
                     <span class="c-str">"min_dist ="</span>, <span class="c-fn">round</span>(dist_min, 2))
  )

<span class="c-com"># 5. Comparaci√≥n con PCA y t-SNE</span>
<span class="c-com"># PCA lineal</span>
pca_result <- <span class="c-fn">prcomp</span>(datos_3d, <span class="c-arg">scale.</span> = TRUE)

<span class="c-com"># t-SNE</span>
<span class="c-kwd">library</span>(Rtsne)
tsne_result <- <span class="c-fn">Rtsne</span>(datos_3d, <span class="c-arg">perplexity</span> = 30, <span class="c-arg">verbose</span> = FALSE)

<span class="c-com"># 6. Visualizaci√≥n comparativa</span>
<span class="c-fn">par</span>(<span class="c-arg">mfrow</span> = <span class="c-fn">c</span>(1, 3))
<span class="c-fn">plot</span>(pca_result<span class="c-var">$x</span>[,1:2], <span class="c-arg">col</span> = grupos, <span class="c-arg">main</span> = <span class="c-str">"PCA"</span>)
<span class="c-fn">plot</span>(tsne_result<span class="c-var">$Y</span>, <span class="c-arg">col</span> = grupos, <span class="c-arg">main</span> = <span class="c-str">"t-SNE"</span>)
<span class="c-fn">plot</span>(umap_result, <span class="c-arg">col</span> = grupos, <span class="c-arg">main</span> = <span class="c-str">"UMAP"</span>)`,
                explain: (p) => {
                    return `
                        <div class="exp-highlight">
                            <b>üåê UMAP (Uniform Manifold Approximation and Projection)</b>
                        </div>
                        
                        <p><b>Concepto:</b> Algoritmo de aprendizaje de variedades que asume que los datos viven en una variedad de Riemann (superficie curva) embebida en un espacio de alta dimensi√≥n.</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Par√°metros clave:</b><br>
                            ‚Ä¢ <b>n_neighbors = ${p.nn}</b>: Balance entre estructura local/global<br>
                            ‚Ä¢ <b>min_dist = ${(p.dist/100).toFixed(2)}</b>: Distancia m√≠nima entre puntos<br>
                            ‚Ä¢ <b>n_components = 2</b>: Dimensi√≥n del espacio de proyecci√≥n
                        </div>
                        
                        <p><b>Fundamento matem√°tico:</b></p>
                        <p>1. <b>Construir grafo ponderado</b> en alta dimensi√≥n</p>
                        <p>2. <b>Optimizar layout</b> en baja dimensi√≥n usando cross-entropy</p>
                        <p>3. <b>Preservar topolog√≠a</b> (relaciones de vecindad)</p>
                        
                        <div class="exp-highlight">
                            <b>‚ö° Ventajas sobre t-SNE:</b>
                            <p>‚Ä¢ ‚è±Ô∏è <b>M√°s r√°pido</b>: Complejidad O(N) vs O(N¬≤)</p>
                            <p>‚Ä¢ üìê <b>Mejor preservaci√≥n de estructura global</b></p>
                            <p>‚Ä¢ üéØ <b>Par√°metros m√°s interpretables</b></p>
                            <p>‚Ä¢ üîÑ <b>Transformaci√≥n out-of-sample</b> posible</p>
                        </div>
                        
                        <p><b>Interpretaci√≥n de par√°metros:</b></p>
                        <p>‚Ä¢ <b>n_neighbors peque√±o (${p.nn <= 15 ? '‚Üì' : '‚Üë'})</b>: ‚Üí Enfoca estructura local, puede crear clusters artificiales</p>
                        <p>‚Ä¢ <b>n_neighbors grande (${p.nn > 30 ? '‚Üë' : '‚Üì'})</b>: ‚Üí Captura m√°s estructura global</p>
                        <p>‚Ä¢ <b>min_dist peque√±o (${p.dist < 30 ? '‚Üì' : '‚Üë'})</b>: ‚Üí Clusters m√°s compactos, menos separaci√≥n</p>
                        <p>‚Ä¢ <b>min_dist grande (${p.dist > 70 ? '‚Üë' : '‚Üì'})</b>: ‚Üí Clusters m√°s dispersos, mejor separaci√≥n</p>
                        
                        <div class="exp-highlight">
                            <b>üß¨ Aplicaci√≥n en Single-Cell RNA-seq:</b>
                            <p>UMAP es el est√°ndar de facto para visualizar datos de scRNA-seq por su capacidad de revelar jerarqu√≠as celulares y transiciones entre estados.</p>
                        </div>`;
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    `;
                    
                    const plotArea = document.createElement('div');
                    plotArea.style.cssText = `
                        width: 500px;
                        height: 500px;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        position: relative;
                    `;
                    
                    // T√≠tulo
                    const title = document.createElement('div');
                    title.innerHTML = `<b style="color:#333; font-size:1rem;">UMAP - Aprendizaje de Variedades</b>`;
                    title.style.cssText = 'margin-bottom: 15px; text-align: center;';
                    plotArea.appendChild(title);
                    
                    // Ejes
                    const axisX = document.createElement('div');
                    axisX.style.cssText = `
                        position: absolute;
                        bottom: 20px;
                        left: 20px;
                        right: 20px;
                        border-top: 2px solid #333;
                        text-align: center;
                        padding-top: 5px;
                        font-size: 11px;
                        color: #333;
                    `;
                    axisX.textContent = 'UMAP 1';
                    plotArea.appendChild(axisX);
                    
                    const axisY = document.createElement('div');
                    axisY.style.cssText = `
                        position: absolute;
                        left: 20px;
                        top: 20px;
                        bottom: 40px;
                        border-left: 2px solid #333;
                        display: flex;
                        align-items: center;
                        padding-left: 5px;
                        font-size: 11px;
                        writing-mode: vertical-rl;
                        transform: rotate(180deg);
                        color: #333;
                    `;
                    axisY.textContent = 'UMAP 2';
                    plotArea.appendChild(axisY);
                    
                    // Crear forma de "S" o variedad
                    const numPoints = 100;
                    const spread = p.dist / 20; // Controlar dispersi√≥n
                    
                    for(let i = 0; i < numPoints; i++) {
                        // Crear forma de variedad (S curve)
                        const t = (i / numPoints) * 6 - 3;
                        const x = 50 + Math.sin(t) * 40;
                        const y = 50 + t * 15;
                        
                        // A√±adir ruido controlado por par√°metros
                        const noiseX = (Math.random() - 0.5) * spread;
                        const noiseY = (Math.random() - 0.5) * spread;
                        
                        // Determinar grupo basado en posici√≥n
                        let group;
                        let color;
                        if(i < numPoints/3) {
                            group = 'A';
                            color = '#007acc';
                        } else if(i < 2*numPoints/3) {
                            group = 'B';
                            color = '#4CAF50';
                        } else {
                            group = 'C';
                            color = '#FF9800';
                        }
                        
                        const point = document.createElement('div');
                        point.className = 'dot';
                        point.style.left = (x + noiseX) + '%';
                        point.style.top = (y + noiseY) + '%';
                        point.style.backgroundColor = color;
                        point.style.borderColor = 'white';
                        point.dataset.tooltip = `Grupo: ${group}<br>Posici√≥n en variedad: ${(i/numPoints).toFixed(2)}`;
                        point.onmouseover = showTooltip;
                        point.onmouseout = hideTooltip;
                        
                        plotArea.appendChild(point);
                    }
                    
                    // L√≠nea de variedad subyacente
                    const manifoldLine = document.createElement('div');
                    manifoldLine.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        pointer-events: none;
                    `;
                    
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', '100%');
                    
                    // Dibujar curva de variedad
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let d = 'M ';
                    for(let i = 0; i <= 100; i += 10) {
                        const t = (i / 100) * 6 - 3;
                        const x = 50 + Math.sin(t) * 40;
                        const y = 50 + t * 15;
                        d += `${x}% ${y}% `;
                    }
                    path.setAttribute('d', d);
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke', 'rgba(0,0,0,0.2)');
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('stroke-dasharray', '5,5');
                    
                    svg.appendChild(path);
                    manifoldLine.appendChild(svg);
                    plotArea.appendChild(manifoldLine);
                    
                    // Panel de par√°metros
                    const paramPanel = document.createElement('div');
                    paramPanel.style.cssText = `
                        position: absolute;
                        top: 20px;
                        right: 20px;
                        background: white;
                        padding: 10px 15px;
                        border-radius: 5px;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        font-size: 0.8rem;
                        color: #333;
                        border-left: 3px solid #9C27B0;
                    `;
                    paramPanel.innerHTML = `
                        <b>Par√°metros UMAP:</b><br>
                        ‚Ä¢ n_neighbors: ${p.nn}<br>
                        ‚Ä¢ min_dist: ${(p.dist/100).toFixed(2)}<br>
                        ‚Ä¢ Puntos: ${numPoints}<br>
                        ‚Ä¢ Grupos: A, B, C
                    `;
                    plotArea.appendChild(paramPanel);
                    
                    container.appendChild(plotArea);
                    div.appendChild(container);
                }
            },
            {
                id: 4,
                title: "Tema 4. Clusterizaci√≥n",
                desc: "K-Means vs Jer√°rquico",
                icon: "fa-sitemap",
                controls: [
                    {id: 'k', type: 'range', label: 'N√∫mero K', min: 2, max: 6, val: 3},
                    {id: 'algo', type: 'select', label: 'M√©todo', options: ['K-Means', 'Jer√°rquico (Hclust)']}
                ],
                code: (p) => `
<span class="c-com"># TEMA 4: CLUSTERIZACI√ìN NO SUPERVISADA</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(cluster)
<span class="c-kwd">library</span>(factoextra)
<span class="c-kwd">library</span>(dendextend)

<span class="c-com"># 1. Datos de expresi√≥n g√©nica para clustering</span>
<span class="c-kwd">set.seed</span>(123)
datos_cluster <- <span class="c-fn">matrix</span>(
  <span class="c-fn">c</span>(
    <span class="c-fn">rnorm</span>(100, mean = 10, sd = 2),
    <span class="c-fn">rnorm</span>(100, mean = 20, sd = 2),
    <span class="c-fn">rnorm</span>(100, mean = 15, sd = 2)
  ),
  <span class="c-arg">ncol</span> = 3,
  <span class="c-arg">byrow</span> = TRUE
)
<span class="c-fn">colnames</span>(datos_cluster) <- <span class="c-fn">c</span>(<span class="c-str">"Gen_A"</span>, <span class="c-str">"Gen_B"</span>, <span class="c-str">"Gen_C"</span>)

<span class="c-com"># 2. Escalar datos (importante para clustering)</span>
datos_scaled <- <span class="c-fn">scale</span>(datos_cluster)

<span class="c-kwd">if</span> (<span class="c-str">"${p.algo}"</span> == <span class="c-str">"K-Means"</span>) {
  
  <span class="c-com"># 3. K-MEANS CLUSTERING</span>
  k <- <span class="c-num">${p.k}</span>
  
  <span class="c-com"># Ejecutar k-means con m√∫ltiples inicializaciones</span>
  kmeans_result <- <span class="c-fn">kmeans</span>(
    datos_scaled,
    <span class="c-arg">centers</span> = k,
    <span class="c-arg">nstart</span> = 25,  <span class="c-com"># N√∫mero de inicializaciones aleatorias</span>
    <span class="c-arg">iter.max</span> = 100
  )
  
  <span class="c-com"># 4. M√©tricas de calidad</span>
  wss <- kmeans_result<span class="c-var">$tot.withinss</span>  <span class="c-com"># Within-cluster sum of squares</span>
  bss <- kmeans_result<span class="c-var">$betweenss</span>    <span class="c-com"># Between-cluster sum of squares</span>
  ratio_bw <- <span class="c-fn">round</span>(bss / (bss + wss) * 100, 1)
  
  <span class="c-fn">cat</span>(<span class="c-str">"=== K-MEANS (k="</span>, k, <span class="c-str">") ===\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"Within-cluster SS:"</span>, <span class="c-fn">round</span>(wss, 2), <span class="c-str">"\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"Between-cluster SS:"</span>, <span class="c-fn">round</span>(bss, 2), <span class="c-str">"\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"% varianza explicada:"</span>, ratio_bw, <span class="c-str">"%\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"Tama√±o clusters:"</span>, kmeans_result<span class="c-var">$size</span>, <span class="c-str">"\\n"</span>)
  
  <span class="c-com"># 5. Visualizaci√≥n clusters</span>
  <span class="c-fn">fviz_cluster</span>(
    kmeans_result,
    <span class="c-arg">data</span> = datos_scaled,
    <span class="c-arg">geom</span> = <span class="c-str">"point"</span>,
    <span class="c-arg">ellipse.type</span> = <span class="c-str">"convex"</span>,
    <span class="c-arg">palette</span> = <span class="c-str">"Set2"</span>,
    <span class="c-arg">ggtheme</span> = theme_minimal()
  ) + 
    <span class="c-fn">ggtitle</span>(<span class="c-str">"K-Means Clustering"</span>)
  
} <span class="c-kwd">else</span> {
  
  <span class="c-com"># 6. CLUSTERING JER√ÅRQUICO</span>
  <span class="c-com"># Calcular matriz de distancias</span>
  dist_matrix <- <span class="c-fn">dist</span>(datos_scaled, <span class="c-arg">method</span> = <span class="c-str">"euclidean"</span>)
  
  <span class="c-com"># Ejecutar clustering jer√°rquico</span>
  hc_result <- <span class="c-fn">hclust</span>(
    dist_matrix,
    <span class="c-arg">method</span> = <span class="c-str">"ward.D2"</span>  <span class="c-com"># Minimiza varianza intra-cluster</span>
  )
  
  <span class="c-com"># 7. Cortar dendrograma en k clusters</span>
  k <- <span class="c-num">${p.k}</span>
  clusters_hc <- <span class="c-fn">cutree</span>(hc_result, <span class="c-arg">k</span> = k)
  
  <span class="c-com"># 8. M√©tricas de calidad</span>
  sil_score <- <span class="c-fn">mean</span>(<span class="c-fn">silhouette</span>(clusters_hc, dist_matrix)[,3])
  
  <span class="c-fn">cat</span>(<span class="c-str">"=== CLUSTERING JER√ÅRQUICO ===\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"M√©todo:"</span>, <span class="c-str">"ward.D2"</span>, <span class="c-str">"\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"N√∫mero clusters:"</span>, k, <span class="c-str">"\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"Silhouette score:"</span>, <span class="c-fn">round</span>(sil_score, 3), <span class="c-str">"\\n"</span>)
  
  <span class="c-com"># 9. Visualizaci√≥n dendrograma</span>
  dend <- <span class="c-fn">as.dendrogram</span>(hc_result)
  <span class="c-fn">par</span>(<span class="c-arg">mfrow</span> = <span class="c-fn">c</span>(1, 2))
  
  <span class="c-com"># Dendrograma con colores</span>
  dend_colored <- <span class="c-fn">color_branches</span>(dend, <span class="c-arg">k</span> = k)
  <span class="c-fn">plot</span>(dend_colored,
       <span class="c-arg">main</span> = <span class="c-str">"Dendrograma"</span>,
       <span class="c-arg">xlab</span> = <span class="c-str">"Muestras"</span>,
       <span class="c-arg">ylab</span> = <span class="c-str">"Altura"</span>)
  
  <span class="c-com"># Silhouette plot</span>
  <span class="c-fn">plot</span>(<span class="c-fn">silhouette</span>(clusters_hc, dist_matrix),
       <span class="c-arg">main</span> = <span class="c-str">"Silhouette Plot"</span>,
       <span class="c-arg">col</span> = 1:k)
}`,
                explain: (p) => {
                    const isKMeans = p.algo === 'K-Means';
                    
                    if(isKMeans) {
                        return `
                        <div class="exp-highlight">
                            <b>üéØ K-Means Clustering</b>
                        </div>
                        
                        <p><b>Concepto:</b> Algoritmo de partici√≥n que divide n observaciones en k clusters donde cada observaci√≥n pertenece al cluster con la media m√°s cercana.</p>
                        
                        <p><b>Algoritmo (Lloyd's algorithm):</b></p>
                        <p>1. <b>Inicializaci√≥n:</b> Seleccionar k centroides aleatorios</p>
                        <p>2. <b>Asignaci√≥n:</b> Asignar cada punto al centroide m√°s cercano</p>
                        <p>3. <b>Actualizaci√≥n:</b> Recalcular centroides como media de puntos asignados</p>
                        <p>4. <b>Repetir</b> hasta convergencia</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Par√°metros clave:</b><br>
                            ‚Ä¢ <b>k = ${p.k}</b>: N√∫mero de clusters<br>
                            ‚Ä¢ <b>nstart = 25</b>: N√∫mero de inicializaciones aleatorias<br>
                            ‚Ä¢ <b>iter.max = 100</b>: M√°ximo n√∫mero de iteraciones
                        </div>
                        
                        <p><b>Funci√≥n objetivo (minimizar):</b></p>
                        <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                            J = Œ£·µ¢ Œ£‚±º ||x·µ¢‚±º - Œº‚±º||¬≤
                        </p>
                        <p>Donde Œº‚±º es el centroide del cluster j</p>
                        
                        <div class="exp-highlight">
                            <b>‚ö° Ventajas:</b>
                            <p>‚Ä¢ ‚è±Ô∏è <b>Escalable</b> a grandes conjuntos de datos</p>
                            <p>‚Ä¢ üéØ <b>Simple</b> de implementar y entender</p>
                            <p>‚Ä¢ üîÑ <b>Garantiza convergencia</b> (local)</p>
                        </div>
                        
                        <p><b>‚ö†Ô∏è Limitaciones:</b></p>
                        <ul>
                            <li>üìè Asume clusters esf√©ricos de tama√±o similar</li>
                            <li>üéØ Sensible a inicializaci√≥n (k-means++)</li>
                            <li>üî¢ Necesita especificar k a priori</li>
                            <li>üìä Sensible a outliers</li>
                        </ul>
                        
                        <div class="exp-note">
                            <i class="fas fa-lightbulb"></i> <b>M√©todo del codo (Elbow Method):</b>
                            <p>Graficar WSS (Within-cluster Sum of Squares) vs k. El punto donde la reducci√≥n en WSS se estabiliza sugiere el k √≥ptimo.</p>
                        </div>`;
                    } else {
                        return `
                        <div class="exp-highlight">
                            <b>üå≥ Clustering Jer√°rquico</b>
                        </div>
                        
                        <p><b>Concepto:</b> Construye una jerarqu√≠a de clusters representada como un dendrograma.</p>
                        
                        <p><b>Dos enfoques principales:</b></p>
                        <p>1. <b>Agrupamiento (Agglomerative):</b> Bottom-up, cada punto como cluster individual que se fusiona</p>
                        <p>2. <b>Divisi√≥n (Divisive):</b> Top-down, todo como un cluster que se divide</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>M√©todos de enlace (Linkage):</b><br>
                            ‚Ä¢ <b>ward.D2</b>: Minimiza varianza intra-cluster (usado)<br>
                            ‚Ä¢ <b>complete</b>: Distancia m√°xima entre clusters<br>
                            ‚Ä¢ <b>single</b>: Distancia m√≠nima entre clusters<br>
                            ‚Ä¢ <b>average</b>: Distancia promedio entre clusters
                        </div>
                        
                        <p><b>Matriz de distancia:</b></p>
                        <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                            d(x, y) = ‚àöŒ£·µ¢(x·µ¢ - y·µ¢)¬≤  (euclidiana)
                        </p>
                        
                        <div class="exp-highlight">
                            <b>üìä Interpretaci√≥n del dendrograma:</b>
                            <p>‚Ä¢ <b>Altura:</b> Distancia a la que se fusionan clusters</p>
                            <p>‚Ä¢ <b>Corte (k=${p.k}):</b> Define n√∫mero de clusters</p>
                            <p>‚Ä¢ <b>Longitud ramas:</b> Homogeneidad dentro del cluster</p>
                        </div>
                        
                        <p><b>M√©trica de calidad:</b></p>
                        <p><b>Silhouette Score (${p.k} clusters):</b> Mide cu√°n similar es un objeto a su propio cluster vs otros clusters.</p>
                        <p>Rango: -1 (mal asignado) a +1 (bien asignado)</p>
                        
                        <div class="exp-highlight">
                            <b>üß¨ Aplicaci√≥n en biolog√≠a:</b>
                            <p>1. <b>Filogen√©tica:</b> Construcci√≥n de √°rboles evolutivos</p>
                            <p>2. <b>Taxonom√≠a:</b> Clasificaci√≥n de especies</p>
                            <p>3. <b>Expresi√≥n g√©nica:</b> Identificaci√≥n de patrones</p>
                            <p>4. <b>Tipificaci√≥n molecular:</b> Clasificaci√≥n de subtipos</p>
                        </div>`;
                    }
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    const isKMeans = p.algo === 'K-Means';
                    const k = p.k;
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    `;
                    
                    if(isKMeans) {
                        // Visualizaci√≥n K-Means
                        const kmeansDiv = document.createElement('div');
                        kmeansDiv.style.cssText = `
                            width: 500px;
                            height: 500px;
                            background: white;
                            border-radius: 10px;
                            padding: 20px;
                            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            position: relative;
                        `;
                        
                        // T√≠tulo
                        const title = document.createElement('div');
                        title.innerHTML = `<b style="color:#333; font-size:1rem;">K-Means Clustering (k=${k})</b>`;
                        title.style.cssText = 'margin-bottom: 15px; text-align: center;';
                        kmeansDiv.appendChild(title);
                        
                        // Ejes
                        const axisX = document.createElement('div');
                        axisX.style.cssText = `
                            position: absolute;
                            bottom: 20px;
                            left: 20px;
                            right: 20px;
                            border-top: 2px solid #333;
                            text-align: center;
                            padding-top: 5px;
                            font-size: 11px;
                            color: #333;
                        `;
                        axisX.textContent = 'Dimensi√≥n 1';
                        kmeansDiv.appendChild(axisX);
                        
                        const axisY = document.createElement('div');
                        axisY.style.cssText = `
                            position: absolute;
                            left: 20px;
                            top: 20px;
                            bottom: 40px;
                            border-left: 2px solid #333;
                            display: flex;
                            align-items: center;
                            padding-left: 5px;
                            font-size: 11px;
                            writing-mode: vertical-rl;
                            transform: rotate(180deg);
                            color: #333;
                        `;
                        axisY.textContent = 'Dimensi√≥n 2';
                        kmeansDiv.appendChild(axisY);
                        
                        // Colores para clusters
                        const colors = ['#007acc', '#4CAF50', '#FF9800', '#9C27B0', '#f44336', '#00BCD4'];
                        
                        // Crear centroides iniciales aleatorios
                        const centroids = [];
                        for(let i = 0; i < k; i++) {
                            centroids.push({
                                x: 20 + Math.random() * 60,
                                y: 20 + Math.random() * 60,
                                color: colors[i]
                            });
                        }
                        
                        // Crear puntos
                        const numPoints = 60;
                        for(let i = 0; i < numPoints; i++) {
                            // Generar punto con tendencia hacia alg√∫n centroide
                            const centroidIdx = Math.floor(Math.random() * k);
                            const centroid = centroids[centroidIdx];
                            
                            const x = centroid.x + (Math.random() - 0.5) * 30;
                            const y = centroid.y + (Math.random() - 0.5) * 30;
                            
                            const point = document.createElement('div');
                            point.className = 'dot';
                            point.style.left = x + '%';
                            point.style.top = y + '%';
                            point.style.backgroundColor = centroid.color;
                            point.style.borderColor = 'white';
                            
                            kmeansDiv.appendChild(point);
                        }
                        
                        // Dibujar centroides
                        centroids.forEach((centroid, idx) => {
                            const center = document.createElement('div');
                            center.className = 'cluster-center';
                            center.style.left = centroid.x + '%';
                            center.style.top = centroid.y + '%';
                            center.style.borderColor = centroid.color;
                            center.style.boxShadow = `0 0 0 3px ${centroid.color}33`;
                            center.dataset.tooltip = `Centroide ${idx + 1}<br>Cluster ${idx + 1}`;
                            center.onmouseover = showTooltip;
                            center.onmouseout = hideTooltip;
                            
                            kmeansDiv.appendChild(center);
                        });
                        
                        // Panel de informaci√≥n
                        const infoPanel = document.createElement('div');
                        infoPanel.style.cssText = `
                            position: absolute;
                            bottom: 20px;
                            right: 20px;
                            background: white;
                            padding: 10px 15px;
                            border-radius: 5px;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            font-size: 0.8rem;
                            color: #333;
                            border-left: 3px solid #007acc;
                        `;
                        infoPanel.innerHTML = `
                            <b>K-Means Info:</b><br>
                            ‚Ä¢ k = ${k} clusters<br>
                            ‚Ä¢ nstart = 25<br>
                            ‚Ä¢ Puntos = ${numPoints}<br>
                            ‚Ä¢ Converge en ~10 iteraciones
                        `;
                        kmeansDiv.appendChild(infoPanel);
                        
                        container.appendChild(kmeansDiv);
                    } else {
                        // Visualizaci√≥n clustering jer√°rquico
                        const hcDiv = document.createElement('div');
                        hcDiv.style.cssText = `
                            width: 600px;
                            height: 500px;
                            background: white;
                            border-radius: 10px;
                            padding: 20px;
                            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            position: relative;
                        `;
                        
                        // T√≠tulo
                        const title = document.createElement('div');
                        title.innerHTML = `<b style="color:#333; font-size:1rem;">Clustering Jer√°rquico - Dendrograma</b>`;
                        title.style.cssText = 'margin-bottom: 15px; text-align: center;';
                        hcDiv.appendChild(title);
                        
                        // Crear dendrograma SVG
                        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        svg.setAttribute('width', '100%');
                        svg.setAttribute('height', '80%');
                        
                        // Colores para clusters
                        const colors = ['#007acc', '#4CAF50', '#FF9800', '#9C27B0', '#f44336', '#00BCD4'];
                        
                        // Estructura del dendrograma
                        const dendrogramStructure = [
                            {level: 0, merge: [1, 2], height: 5},
                            {level: 1, merge: [3, 4], height: 15},
                            {level: 2, merge: [5, 6], height: 25},
                            {level: 3, merge: [1, 3], height: 40},
                            {level: 4, merge: [2, 5], height: 60}
                        ];
                        
                        // Posiciones de hojas
                        const leafPositions = [];
                        const numLeaves = 20;
                        const leafSpacing = 95 / (numLeaves - 1);
                        
                        for(let i = 0; i < numLeaves; i++) {
                            leafPositions.push({
                                x: 5 + i * leafSpacing,
                                y: 90,
                                cluster: Math.floor(i / (numLeaves/k))
                            });
                        }
                        
                        // Dibujar l√≠neas del dendrograma
                        dendrogramStructure.forEach(node => {
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            
                            // Posiciones aproximadas
                            const x1 = 20 + node.level * 15;
                            const x2 = 50 + node.level * 10;
                            const y1 = 30 + node.height;
                            const y2 = 70 - node.level * 5;
                            
                            line.setAttribute('x1', `${x1}%`);
                            line.setAttribute('y1', `${y1}%`);
                            line.setAttribute('x2', `${x2}%`);
                            line.setAttribute('y2', `${y2}%`);
                            line.setAttribute('stroke', '#666');
                            line.setAttribute('stroke-width', '2');
                            
                            svg.appendChild(line);
                        });
                        
                        // Dibujar hojas
                        leafPositions.forEach((leaf, idx) => {
                            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            circle.setAttribute('cx', `${leaf.x}%`);
                            circle.setAttribute('cy', `${leaf.y}%`);
                            circle.setAttribute('r', '3');
                            circle.setAttribute('fill', colors[leaf.cluster % colors.length]);
                            circle.setAttribute('stroke', '#333');
                            circle.setAttribute('stroke-width', '1');
                            
                            svg.appendChild(circle);
                        });
                        
                        // L√≠nea de corte
                        const cutLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        cutLine.setAttribute('x1', '5%');
                        cutLine.setAttribute('y1', `${100 - k * 10}%`);
                        cutLine.setAttribute('x2', '95%');
                        cutLine.setAttribute('y2', `${100 - k * 10}%`);
                        cutLine.setAttribute('stroke', '#f44336');
                        cutLine.setAttribute('stroke-width', '2');
                        cutLine.setAttribute('stroke-dasharray', '5,5');
                        svg.appendChild(cutLine);
                        
                        // Texto de corte
                        const cutText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        cutText.setAttribute('x', '50%');
                        cutText.setAttribute('y', `${100 - k * 10 - 2}%`);
                        cutText.setAttribute('text-anchor', 'middle');
                        cutText.setAttribute('fill', '#f44336');
                        cutText.setAttribute('font-size', '12');
                        cutText.textContent = `Corte: k=${k} clusters`;
                        svg.appendChild(cutText);
                        
                        hcDiv.appendChild(svg);
                        
                        // Panel de informaci√≥n
                        const infoPanel = document.createElement('div');
                        infoPanel.style.cssText = `
                            position: absolute;
                            bottom: 20px;
                            right: 20px;
                            background: white;
                            padding: 10px 15px;
                            border-radius: 5px;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            font-size: 0.8rem;
                            color: #333;
                            border-left: 3px solid #4CAF50;
                        `;
                        infoPanel.innerHTML = `
                            <b>Clustering Jer√°rquico:</b><br>
                            ‚Ä¢ M√©todo: ward.D2<br>
                            ‚Ä¢ k = ${k} clusters<br>
                            ‚Ä¢ Hojas: ${numLeaves}<br>
                            ‚Ä¢ Altura corte: ${(100 - k * 10).toFixed(0)}%
                        `;
                        hcDiv.appendChild(infoPanel);
                        
                        // Leyenda de colores
                        const legend = document.createElement('div');
                        legend.style.cssText = `
                            display: flex;
                            justify-content: center;
                            gap: 15px;
                            margin-top: 10px;
                        `;
                        
                        for(let i = 0; i < k; i++) {
                            const legendItem = document.createElement('div');
                            legendItem.style.cssText = `
                                display: flex;
                                align-items: center;
                                gap: 5px;
                                font-size: 0.8rem;
                            `;
                            
                            const colorBox = document.createElement('div');
                            colorBox.style.cssText = `
                                width: 12px;
                                height: 12px;
                                background: ${colors[i % colors.length]};
                                border-radius: 2px;
                            `;
                            
                            legendItem.appendChild(colorBox);
                            legendItem.appendChild(document.createTextNode(`Cluster ${i+1}`));
                            legend.appendChild(legendItem);
                        }
                        
                        hcDiv.appendChild(legend);
                        container.appendChild(hcDiv);
                    }
                    
                    div.appendChild(container);
                }
            },
            {
                id: 5,
                title: "Tema 5. Discriminante",
                desc: "LDA vs QDA",
                icon: "fa-columns",
                controls: [
                    {id: 'mod', type: 'select', label: 'Modelo', options: ['LDA (Lineal)', 'QDA (Cuadr√°tico)']},
                    {id: 'var', type: 'checkbox', label: 'Varianzas Desiguales', value: false}
                ],
                code: (p) => `
<span class="c-com"># TEMA 5: AN√ÅLISIS DISCRIMINANTE</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(MASS)
<span class="c-kwd">library</span>(ggplot2)
<span class="c-kwd">library</span>(klaR)

<span class="c-com"># 1. Datos simulados: diagn√≥stico basado en biomarcadores</span>
<span class="c-kwd">set.seed</span>(123)
n <- 100

<span class="c-com"># Grupo 1: Pacientes sanos (media baja, varianza baja)</span>
grupo1 <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">Biomarcador1</span> = <span class="c-fn">rnorm</span>(n/2, mean = 5, sd = 1),
  <span class="c-arg">Biomarcador2</span> = <span class="c-fn">rnorm</span>(n/2, mean = 5, sd = 1),
  <span class="c-arg">Diagnostico</span> = <span class="c-str">"Sano"</span>
)

<span class="c-com"># Grupo 2: Pacientes enfermos</span>
sd_grupo2 <- ${p.var ? 2.5 : 1}
grupo2 <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">Biomarcador1</span> = <span class="c-fn">rnorm</span>(n/2, mean = 8, sd = sd_grupo2),
  <span class="c-arg">Biomarcador2</span> = <span class="c-fn">rnorm</span>(n/2, mean = 8, sd = sd_grupo2),
  <span class="c-arg">Diagnostico</span> = <span class="c-str">"Enfermo"</span>
)

datos <- <span class="c-fn">rbind</span>(grupo1, grupo2)
datos<span class="c-var">$Diagnostico</span> <- <span class="c-fn">factor</span>(datos<span class="c-var">$Diagnostico</span>)

<span class="c-com"># 2. Divisi√≥n entrenamiento/prueba (70/30)</span>
train_idx <- <span class="c-fn">sample</span>(1:n, n * 0.7)
train <- datos[train_idx, ]
test  <- datos[-train_idx, ]

<span class="c-kwd">if</span> (<span class="c-str">"${p.mod}"</span> == <span class="c-str">"LDA (Lineal)"</span>) {
  
  <span class="c-com"># 3. LINEAR DISCRIMINANT ANALYSIS (LDA)</span>
  <span class="c-com"># Asume varianzas iguales entre grupos (homocedasticidad)</span>
  modelo_lda <- <span class="c-fn">lda</span>(
    Diagnostico ~ Biomarcador1 + Biomarcador2,
    <span class="c-arg">data</span> = train
  )
  
  <span class="c-com"># 4. Predicciones y evaluaci√≥n</span>
  pred_train <- <span class="c-fn">predict</span>(modelo_lda, train)
  pred_test  <- <span class="c-fn">predict</span>(modelo_lda, test)
  
  <span class="c-com"># 5. Matriz de confusi√≥n</span>
  <span class="c-kwd">library</span>(caret)
  cm_test <- <span class="c-fn">confusionMatrix</span>(pred_test<span class="c-var">$class</span>, test<span class="c-var">$Diagnostico</span>)
  
  <span class="c-fn">cat</span>(<span class="c-str">"=== LDA (Linear Discriminant Analysis) ===\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"Prior probabilities:\\n"</span>)
  <span class="c-fn">print</span>(modelo_lda<span class="c-var">$prior</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"\\nGroup means:\\n"</span>)
  <span class="c-fn">print</span>(modelo_lda<span class="c-var">$means</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"\\nAccuracy test:"</span>, <span class="c-fn">round</span>(cm_test<span class="c-var">$overall</span>[1], 3), <span class="c-str">"\\n"</span>)
  
  <span class="c-com"># 6. Visualizaci√≥n frontera lineal</span>
  <span class="c-com"># Crear grid para plot</span>
  grid <- <span class="c-fn">expand.grid</span>(
    <span class="c-arg">Biomarcador1</span> = <span class="c-fn">seq</span>(2, 12, length.out = 100),
    <span class="c-arg">Biomarcador2</span> = <span class="c-fn">seq</span>(2, 12, length.out = 100)
  )
  grid<span class="c-var">$Prediccion</span> <- <span class="c-fn">predict</span>(modelo_lda, grid)<span class="c-var">$class</span>
  
  ggplot(datos, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = Biomarcador1, <span class="c-arg">y</span> = Biomarcador2, 
                   <span class="c-arg">color</span> = Diagnostico)) +
    <span class="c-fn">geom_point</span>(<span class="c-arg">size</span> = 3, <span class="c-arg">alpha</span> = 0.7) +
    <span class="c-fn">geom_contour</span>(<span class="c-fn">aes</span>(<span class="c-arg">z</span> = <span class="c-fn">as.numeric</span>(Prediccion)), 
                  <span class="c-arg">data</span> = grid, <span class="c-arg">color</span> = <span class="c-str">"black"</span>, <span class="c-arg">lwd</span> = 1) +
    <span class="c-fn">theme_minimal</span>() +
    <span class="c-fn">ggtitle</span>(<span class="c-str">"LDA: Frontera Lineal de Decisi√≥n"</span>)
  
} <span class="c-kwd">else</span> {
  
  <span class="c-com"># 7. QUADRATIC DISCRIMINANT ANALYSIS (QDA)</span>
  <span class="c-com"># Permite varianzas diferentes entre grupos</span>
  modelo_qda <- <span class="c-fn">qda</span>(
    Diagnostico ~ Biomarcador1 + Biomarcador2,
    <span class="c-arg">data</span> = train
  )
  
  <span class="c-com"># 8. Predicciones y evaluaci√≥n</span>
  pred_train_qda <- <span class="c-fn">predict</span>(modelo_qda, train)
  pred_test_qda  <- <span class="c-fn">predict</span>(modelo_qda, test)
  
  cm_test_qda <- <span class="c-fn">confusionMatrix</span>(pred_test_qda<span class="c-var">$class</span>, test<span class="c-var">$Diagnostico</span>)
  
  <span class="c-fn">cat</span>(<span class="c-str">"=== QDA (Quadratic Discriminant Analysis) ===\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"Prior probabilities:\\n"</span>)
  <span class="c-fn">print</span>(modelo_qda<span class="c-var">$prior</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"\\nAccuracy test:"</span>, <span class="c-fn">round</span>(cm_test_qda<span class="c-var">$overall</span>[1], 3), <span class="c-str">"\\n"</span>)
  
  <span class="c-com"># 9. Visualizaci√≥n frontera cuadr√°tica</span>
  grid <- <span class="c-fn">expand.grid</span>(
    <span class="c-arg">Biomarcador1</span> = <span class="c-fn">seq</span>(2, 12, length.out = 100),
    <span class="c-arg">Biomarcador2</span> = <span class="c-fn">seq</span>(2, 12, length.out = 100)
  )
  grid<span class="c-var">$Prediccion</span> <- <span class="c-fn">predict</span>(modelo_qda, grid)<span class="c-var">$class</span>
  
  ggplot(datos, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = Biomarcador1, <span class="c-arg">y</span> = Biomarcador2, 
                   <span class="c-arg">color</span> = Diagnostico)) +
    <span class="c-fn">geom_point</span>(<span class="c-arg">size</span> = 3, <span class="c-arg">alpha</span> = 0.7) +
    <span class="c-fn">geom_contour</span>(<span class="c-fn">aes</span>(<span class="c-arg">z</span> = <span class="c-fn">as.numeric</span>(Prediccion)), 
                  <span class="c-arg">data</span> = grid, <span class="c-arg">color</span> = <span class="c-str">"black"</span>, <span class="c-arg">lwd</span> = 1) +
    <span class="c-fn">theme_minimal</span>() +
    <span class="c-fn">ggtitle</span>(<span class="c-str">"QDA: Frontera Cuadr√°tica de Decisi√≥n"</span>)
}

<span class="c-com"># 10. Comparativa LDA vs QDA</span>
<span class="c-fn">cat</span>(<span class="c-str">"\\n=== COMPARATIVA LDA vs QDA ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Situaci√≥n:"</span>, ${p.var ? '"Varianzas DESIGUALES"' : '"Varianzas iguales"'}, <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Modelo seleccionado:"</span>, <span class="c-str">"${p.mod}"</span>, <span class="c-str">"\\n"</span>)`,
                explain: (p) => {
                    const isLDA = p.mod === 'LDA (Lineal)';
                    const hasUnequalVariances = p.var;
                    
                    let warning = '';
                    if(isLDA && hasUnequalVariances) {
                        warning = `
                        <div class="exp-note" style="background: rgba(244, 67, 54, 0.1); border-left-color: #f44336;">
                            <i class="fas fa-exclamation-triangle"></i> <b>¬°ADVERTENCIA!</b>
                            <p>Est√°s usando LDA con datos de varianzas desiguales. LDA asume homocedasticidad, por lo que puede tener bajo rendimiento.</p>
                            <p><b>Recomendaci√≥n:</b> Usa QDA o transforma los datos.</p>
                        </div>`;
                    }
                    
                    if(isLDA) {
                        return warning + `
                        <div class="exp-highlight">
                            <b>üìê LDA (Linear Discriminant Analysis)</b>
                        </div>
                        
                        <p><b>Concepto:</b> M√©todo de clasificaci√≥n que proyecta los datos en una direcci√≥n que maximiza la separaci√≥n entre clases.</p>
                        
                        <p><b>Supuestos:</b></p>
                        <ul>
                            <li>üìè <b>Normalidad multivariada</b> por clase</li>
                            <li>‚öñÔ∏è <b>Homocedasticidad</b> (varianzas iguales)</li>
                            <li>üìä <b>Independencia</b> de observaciones</li>
                        </ul>
                        
                        <p><b>Funci√≥n discriminante lineal:</b></p>
                        <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                            Œ¥‚Çñ(x) = x·µÄŒ£‚Åª¬πŒº‚Çñ - ¬ΩŒº‚Çñ·µÄŒ£‚Åª¬πŒº‚Çñ + log(œÄ‚Çñ)
                        </p>
                        
                        <div class="exp-note">
                            <i class="fas fa-calculator"></i> <b>Interpretaci√≥n:</b>
                            <p>‚Ä¢ Œ£‚Åª¬π: Matriz de covarianza inversa (compartida)</p>
                            <p>‚Ä¢ Œº‚Çñ: Vector de medias de la clase k</p>
                            <p>‚Ä¢ œÄ‚Çñ: Probabilidad a priori de la clase k</p>
                        </div>
                        
                        <div class="exp-highlight">
                            <b>üéØ Objetivo de LDA:</b>
                            <p>Encontrar la combinaci√≥n lineal de caracter√≠sticas que maximice:</p>
                            <p style="text-align: center; color: #6a9955;">
                                J(w) = (w·µÄŒº‚ÇÅ - w·µÄŒº‚ÇÇ)¬≤ / (w·µÄŒ£w)
                            </p>
                            <p><b>Numerador:</b> Separaci√≥n entre medias</p>
                            <p><b>Denominador:</b> Varianza dentro de clases</p>
                        </div>
                        
                        <p><b>üöÄ Ventajas:</b></p>
                        <ul>
                            <li>‚ö° Computacionalmente eficiente</li>
                            <li>üéØ Robust a overfitting en alta dimensi√≥n</li>
                            <li>üìä Interpretaci√≥n probabil√≠stica directa</li>
                            <li>üîç Manejo natural de clases desbalanceadas</li>
                        </ul>
                        
                        <div class="exp-highlight">
                            <b>üß™ Aplicaci√≥n en diagn√≥stico m√©dico:</b>
                            <p>LDA es ideal cuando los biomarcadores tienen distribuciones normales y varianzas similares entre grupos de pacientes.</p>
                        </div>`;
                    } else {
                        return `
                        <div class="exp-highlight">
                            <b>üîÑ QDA (Quadratic Discriminant Analysis)</b>
                        </div>
                        
                        <p><b>Concepto:</b> Extensi√≥n de LDA que permite diferentes matrices de covarianza por clase.</p>
                        
                        <p><b>Supuestos:</b></p>
                        <ul>
                            <li>üìè <b>Normalidad multivariada</b> por clase</li>
                            <li>‚öñÔ∏è <b>Heterocedasticidad permitida</b></li>
                            <li>üìä <b>Independencia</b> de observaciones</li>
                        </ul>
                        
                        <p><b>Funci√≥n discriminante cuadr√°tica:</b></p>
                        <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                            Œ¥‚Çñ(x) = -¬Ωlog|Œ£‚Çñ| - ¬Ω(x-Œº‚Çñ)·µÄŒ£‚Çñ‚Åª¬π(x-Œº‚Çñ) + log(œÄ‚Çñ)
                        </p>
                        
                        ${hasUnequalVariances ? `
                        <div class="exp-note" style="background: rgba(76, 175, 80, 0.1); border-left-color: #4CAF50;">
                            <i class="fas fa-check-circle"></i> <b>¬°SITUACI√ìN IDEAL PARA QDA!</b>
                            <p>Los datos tienen varianzas diferentes entre clases. QDA modelar√° correctamente esta heterocedasticidad.</p>
                        </div>
                        ` : ''}
                        
                        <div class="exp-highlight">
                            <b>üìä Comparaci√≥n LDA vs QDA:</b>
                            <table style="width:100%; border-collapse: collapse; margin: 10px 0;">
                                <tr style="background: rgba(0,122,204,0.1);">
                                    <th style="padding: 8px; border: 1px solid #007acc;">Aspecto</th>
                                    <th style="padding: 8px; border: 1px solid #007acc;">LDA</th>
                                    <th style="padding: 8px; border: 1px solid #007acc;">QDA</th>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333;">Frontera</td>
                                    <td style="padding: 8px; border: 1px solid #333;">Lineal</td>
                                    <td style="padding: 8px; border: 1px solid #333;">Cuadr√°tica</td>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333;">Covarianzas</td>
                                    <td style="padding: 8px; border: 1px solid #333;">Compartida (Œ£)</td>
                                    <td style="padding: 8px; border: 1px solid #333;">Individual (Œ£‚Çñ)</td>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333;">Par√°metros</td>
                                    <td style="padding: 8px; border: 1px solid #333;">Kp + p(p+1)/2</td>
                                    <td style="padding: 8px; border: 1px solid #333;">K[p + p(p+1)/2]</td>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333;">Bias-Variance</td>
                                    <td style="padding: 8px; border: 1px solid #333;">Alto bias, baja varianza</td>
                                    <td style="padding: 8px; border: 1px solid #333;">Bajo bias, alta varianza</td>
                                </tr>
                            </table>
                        </div>
                        
                        <p><b>üìà Trade-off Bias-Variance:</b></p>
                        <p>‚Ä¢ <b>LDA:</b> Menos par√°metros ‚Üí m√°s bias, menos varianza ‚Üí mejor con pocos datos</p>
                        <p>‚Ä¢ <b>QDA:</b> M√°s par√°metros ‚Üí menos bias, m√°s varianza ‚Üí necesita m√°s datos</p>
                        
                        <div class="exp-highlight">
                            <b>üß¨ Aplicaci√≥n en sub-tipificaci√≥n de c√°ncer:</b>
                            <p>QDA es √∫til cuando diferentes subtipos tumorales tienen patrones de expresi√≥n g√©nica con varianzas distintas.</p>
                        </div>`;
                    }
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    const isLDA = p.mod === 'LDA (Lineal)';
                    const hasUnequalVariances = p.var;
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    `;
                    
                    const plotArea = document.createElement('div');
                    plotArea.style.cssText = `
                        width: 500px;
                        height: 500px;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        position: relative;
                    `;
                    
                    // T√≠tulo
                    const title = document.createElement('div');
                    title.innerHTML = `<b style="color:#333; font-size:1rem;">${isLDA ? 'LDA - Frontera Lineal' : 'QDA - Frontera Cuadr√°tica'}</b>`;
                    title.style.cssText = 'margin-bottom: 15px; text-align: center;';
                    plotArea.appendChild(title);
                    
                    // Ejes
                    const axisX = document.createElement('div');
                    axisX.style.cssText = `
                        position: absolute;
                        bottom: 20px;
                        left: 20px;
                        right: 20px;
                        border-top: 2px solid #333;
                        text-align: center;
                        padding-top: 5px;
                        font-size: 11px;
                        color: #333;
                    `;
                    axisX.textContent = 'Biomarcador 1';
                    plotArea.appendChild(axisX);
                    
                    const axisY = document.createElement('div');
                    axisY.style.cssText = `
                        position: absolute;
                        left: 20px;
                        top: 20px;
                        bottom: 40px;
                        border-left: 2px solid #333;
                        display: flex;
                        align-items: center;
                        padding-left: 5px;
                        font-size: 11px;
                        writing-mode: vertical-rl;
                        transform: rotate(180deg);
                        color: #333;
                    `;
                    axisY.textContent = 'Biomarcador 2';
                    plotArea.appendChild(axisY);
                    
                    // Par√°metros de los grupos
                    const group1 = {
                        meanX: 30,
                        meanY: 30,
                        color: '#007acc',
                        label: 'Sano'
                    };
                    
                    const group2 = {
                        meanX: 70,
                        meanY: 70,
                        color: '#f44336',
                        label: 'Enfermo'
                    };
                    
                    // Ajustar varianzas si es necesario
                    const spread1 = 15; // Grupo sano - varianza baja
                    const spread2 = hasUnequalVariances ? 30 : 15; // Grupo enfermo
                    
                    // Crear puntos para grupo 1 (sanos)
                    for(let i = 0; i < 25; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * spread1;
                        const x = group1.meanX + Math.cos(angle) * radius;
                        const y = group1.meanY + Math.sin(angle) * radius;
                        
                        const point = document.createElement('div');
                        point.className = 'dot';
                        point.style.left = x + '%';
                        point.style.top = y + '%';
                        point.style.backgroundColor = group1.color;
                        point.style.borderColor = 'white';
                        point.dataset.tooltip = `Grupo: ${group1.label}`;
                        point.onmouseover = showTooltip;
                        point.onmouseout = hideTooltip;
                        
                        plotArea.appendChild(point);
                    }
                    
                    // Crear puntos para grupo 2 (enfermos)
                    for(let i = 0; i < 25; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * spread2;
                        const x = group2.meanX + Math.cos(angle) * radius;
                        const y = group2.meanY + Math.sin(angle) * radius;
                        
                        const point = document.createElement('div');
                        point.className = 'dot';
                        point.style.left = x + '%';
                        point.style.top = y + '%';
                        point.style.backgroundColor = group2.color;
                        point.style.borderColor = 'white';
                        point.dataset.tooltip = `Grupo: ${group2.label}<br>Varianza: ${hasUnequalVariances ? 'Alta' : 'Normal'}`;
                        point.onmouseover = showTooltip;
                        point.onmouseout = hideTooltip;
                        
                        plotArea.appendChild(point);
                    }
                    
                    // Dibujar frontera de decisi√≥n
                    const boundary = document.createElement('div');
                    boundary.style.cssText = `
                        position: absolute;
                        pointer-events: none;
                    `;
                    
                    if(isLDA) {
                        // Frontera lineal (recta)
                        boundary.style.cssText += `
                            width: 120%;
                            height: 2px;
                            background: #333;
                            top: 50%;
                            left: -10%;
                            transform: rotate(-45deg);
                            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                        `;
                    } else {
                        // Frontera cuadr√°tica (curva)
                        boundary.style.cssText += `
                            width: 50%;
                            height: 50%;
                            border: 2px solid #333;
                            border-radius: 0 0 0 100%;
                            top: 25%;
                            left: 50%;
                            border-right: none;
                            border-top: none;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                        `;
                    }
                    
                    plotArea.appendChild(boundary);
                    
                    // Panel de informaci√≥n
                    const infoPanel = document.createElement('div');
                    const panelColor = isLDA ? '#007acc' : '#9C27B0';
                    infoPanel.style.cssText = `
                        position: absolute;
                        bottom: 20px;
                        right: 20px;
                        background: white;
                        padding: 10px 15px;
                        border-radius: 5px;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        font-size: 0.8rem;
                        color: #333;
                        border-left: 3px solid ${panelColor};
                    `;
                    
                    infoPanel.innerHTML = `
                        <b>${isLDA ? 'LDA' : 'QDA'} Config:</b><br>
                        ‚Ä¢ Modelo: ${isLDA ? 'Lineal' : 'Cuadr√°tico'}<br>
                        ‚Ä¢ Varianzas: ${hasUnequalVariances ? 'Desiguales' : 'Iguales'}<br>
                        ‚Ä¢ Grupos: 2 (50/50)<br>
                        ‚Ä¢ Puntos: 50 total
                    `;
                    
                    plotArea.appendChild(infoPanel);
                    
                    // Leyenda
                    const legend = document.createElement('div');
                    legend.style.cssText = `
                        position: absolute;
                        top: 20px;
                        left: 20px;
                        background: white;
                        padding: 10px 15px;
                        border-radius: 5px;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        font-size: 0.8rem;
                    `;
                    
                    legend.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                            <div style="width: 12px; height: 12px; border-radius: 50%; background: ${group1.color};"></div>
                            <span>${group1.label} (œÉ=${spread1})</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="width: 12px; height: 12px; border-radius: 50%; background: ${group2.color};"></div>
                            <span>${group2.label} (œÉ=${spread2})</span>
                        </div>
                    `;
                    
                    plotArea.appendChild(legend);
                    
                    container.appendChild(plotArea);
                    div.appendChild(container);
                }
            },
            {
                id: 6,
                title: "Tema 6. Superv. I (Tree/SVM)",
                desc: "√Årboles de Decisi√≥n y SVM",
                icon: "fa-tree",
                controls: [
                    {id: 'algo', type: 'select', label: 'Algoritmo', options: ['Arbol (Decision Tree)', 'SVM (Kernel Radial)']},
                    {id: 'param', type: 'range', label: 'Complejidad (cp / Cost)', min: 1, max: 20, val: 5, step: 1},
                    {id: 'depth', type: 'range', label: 'Profundidad M√°x', min: 1, max: 5, val: 3, step: 1}
                ],
                code: (p) => {
                    if(p.algo.startsWith('Arbol')) return `
<span class="c-com"># TEMA 6: √ÅRBOLES DE DECISI√ìN</span>
<span class="c-com"># ============================</span>

<span class="c-kwd">library</span>(caret)
<span class="c-kwd">library</span>(rpart)
<span class="c-kwd">library</span>(rpart.plot)

<span class="c-com"># 1. Preparar datos de ejemplo (C√°ncer de Mama)</span>
<span class="c-kwd">data</span>(<span class="c-str">"PimaIndiansDiabetes"</span>, package = <span class="c-str">"mlbench"</span>)
datos <- PimaIndiansDiabetes

<span class="c-com"># 2. Dividir en entrenamiento (70%) y prueba (30%)</span>
<span class="c-kwd">set.seed</span>(123)
indices <- <span class="c-fn">createDataPartition</span>(datos<span class="c-var">$diabetes</span>, 
                           <span class="c-arg">p</span> = 0.7, 
                           <span class="c-arg">list</span> = FALSE)
train <- datos[indices, ]
test  <- datos[-indices, ]

<span class="c-com"># 3. Configurar validaci√≥n cruzada (10-fold CV)</span>
ctrl <- <span class="c-fn">trainControl</span>(
  <span class="c-arg">method</span> = <span class="c-str">"cv"</span>,
  <span class="c-arg">number</span> = 10,
  <span class="c-arg">classProbs</span> = TRUE,
  <span class="c-arg">summaryFunction</span> = twoClassSummary
)

<span class="c-com"># 4. Entrenar √°rbol de decisi√≥n con par√°metro de complejidad</span>
cp_valor <- <span class="c-num">${(p.param/100).toFixed(3)}</span>
<span class="c-com"># cp controla la poda: valores m√°s altos = √°rbol m√°s simple</span>

modelo_arbol <- <span class="c-fn">train</span>(
  <span class="c-arg">diabetes</span> ~ .,
  <span class="c-arg">data</span> = train,
  <span class="c-arg">method</span> = <span class="c-str">"rpart"</span>,
  <span class="c-arg">trControl</span> = ctrl,
  <span class="c-arg">tuneGrid</span> = <span class="c-fn">data.frame</span>(<span class="c-arg">cp</span> = cp_valor),
  <span class="c-arg">control</span> = <span class="c-fn">rpart.control</span>(
    <span class="c-arg">maxdepth</span> = <span class="c-num">${p.depth}</span>,
    <span class="c-arg">minsplit</span> = 20,
    <span class="c-arg">minbucket</span> = 7
  ),
  <span class="c-arg">metric</span> = <span class="c-str">"ROC"</span>
)

<span class="c-com"># 5. Visualizar el √°rbol</span>
<span class="c-fn">rpart.plot</span>(modelo_arbol<span class="c-var">$finalModel</span>,
           <span class="c-arg">type</span> = 4,
           <span class="c-arg">extra</span> = 101,
           <span class="c-arg">box.palette</span> = <span class="c-str">"Blues"</span>,
           <span class="c-arg">shadow.col</span> = <span class="c-str">"gray"</span>,
           <span class="c-arg">nn</span> = TRUE)

<span class="c-com"># 6. Evaluar en datos de prueba</span>
predicciones <- <span class="c-fn">predict</span>(modelo_arbol, test)
matriz_conf <- <span class="c-fn">confusionMatrix</span>(predicciones, test<span class="c-var">$diabetes</span>)
<span class="c-fn">print</span>(matriz_conf)

<span class="c-com"># 7. Importancia de variables</span>
importancia <- <span class="c-fn">varImp</span>(modelo_arbol)
<span class="c-fn">plot</span>(importancia, <span class="c-arg">main</span> = <span class="c-str">"Importancia de Variables"</span>)`;
                    
                    return `
<span class="c-com"># TEMA 6: SVM (SUPPORT VECTOR MACHINES)</span>
<span class="c-com"># =======================================</span>

<span class="c-kwd">library</span>(caret)
<span class="c-kwd">library</span>(e1071)
<span class="c-kwd">library</span>(kernlab)

<span class="c-com"># 1. Preparar datos (mismo conjunto que para √°rboles)</span>
<span class="c-kwd">data</span>(<span class="c-str">"PimaIndiansDiabetes"</span>, package = <span class="c-str">"mlbench"</span>)
datos <- PimaIndiansDiabetes

<span class="c-kwd">set.seed</span>(123)
indices <- <span class="c-fn">createDataPartition</span>(datos<span class="c-var">$diabetes</span>, 
                           <span class="c-arg">p</span> = 0.7, 
                           <span class="c-arg">list</span> = FALSE)
train <- datos[indices, ]
test  <- datos[-indices, ]

<span class="c-com"># 2. Preprocesar: escalar variables para SVM</span>
<span class="c-com"># SVM es sensible a la escala de las variables</span>
preProc <- <span class="c-fn">preProcess</span>(train[, -9], <span class="c-arg">method</span> = <span class="c-str">"scale"</span>)
train_scaled <- <span class="c-fn">predict</span>(preProc, train)
test_scaled  <- <span class="c-fn">predict</span>(preProc, test)

<span class="c-com"># 3. Configurar validaci√≥n cruzada</span>
ctrl <- <span class="c-fn">trainControl</span>(
  <span class="c-arg">method</span> = <span class="c-str">"cv"</span>,
  <span class="c-arg">number</span> = 10,
  <span class="c-arg">classProbs</span> = TRUE,
  <span class="c-arg">summaryFunction</span> = twoClassSummary
)

<span class="c-com"># 4. Entrenar SVM con kernel radial</span>
<span class="c-com"># Cost (C) = ${p.param}: Controla el trade-off entre margen y errores</span>
<span class="c-com"># C alto = margen peque√±o, pocos errores (riesgo de overfitting)</span>
<span class="c-com"># C bajo = margen grande, m√°s errores permitidos</span>

modelo_svm <- <span class="c-fn">train</span>(
  <span class="c-arg">diabetes</span> ~ .,
  <span class="c-arg">data</span> = train_scaled,
  <span class="c-arg">method</span> = <span class="c-str">"svmRadial"</span>,
  <span class="c-arg">trControl</span> = ctrl,
  <span class="c-arg">tuneGrid</span> = <span class="c-fn">expand.grid</span>(
    <span class="c-arg">sigma</span> = 0.1,  <span class="c-com"># Par√°metro del kernel</span>
    <span class="c-arg">C</span> = <span class="c-num">${p.param}</span>      <span class="c-com"># Par√°metro de costo</span>
  ),
  <span class="c-arg">metric</span> = <span class="c-str">"ROC"</span>
)

<span class="c-com"># 5. Visualizar fronteras de decisi√≥n (2D)</span>
<span class="c-com"># Seleccionar dos variables para visualizaci√≥n</span>
plot_data <- train_scaled[, c(<span class="c-str">"glucose"</span>, <span class="c-str">"mass"</span>, <span class="c-str">"diabetes"</span>)]

<span class="c-kwd">library</span>(ggplot2)
ggplot(plot_data, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = glucose, <span class="c-arg">y</span> = mass, <span class="c-arg">color</span> = diabetes)) +
  <span class="c-fn">geom_point</span>(<span class="c-arg">size</span> = 3) +
  <span class="c-fn">stat_density2d</span>(<span class="c-arg">aes</span>(<span class="c-arg">fill</span> = diabetes), alpha = 0.3) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">ggtitle</span>(<span class="c-str">"Fronteras de Decisi√≥n SVM (Kernel Radial)"</span>)

<span class="c-com"># 6. Evaluar modelo</span>
pred_svm <- <span class="c-fn">predict</span>(modelo_svm, test_scaled)
matriz_svm <- <span class="c-fn">confusionMatrix</span>(pred_svm, test_scaled<span class="c-var">$diabetes</span>)
<span class="c-fn">print</span>(matriz_svm)

<span class="c-com"># 7. Comparar con √°rbol</span>
<span class="c-fn">cat</span>(<span class="c-str">"\\n=== COMPARACI√ìN √ÅRBOL vs SVM ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"√Årbol: "</span>, <span class="c-fn">round</span>(matriz_conf<span class="c-var">$overall</span>[1], 3), 
    <span class="c-str">" accuracy\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"SVM:   "</span>, <span class="c-fn">round</span>(matriz_svm<span class="c-var">$overall</span>[1], 3), 
    <span class="c-str">" accuracy\\n"</span>)`;
                },
                explain: (p) => {
                    if(p.algo.startsWith('Arbol')) {
                        return `
                        <div class="exp-highlight">
                            <b>üå≥ √Årboles de Decisi√≥n (CART - Classification And Regression Trees)</b>
                        </div>
                        
                        <p><b>Concepto:</b> Divide recursivamente el espacio de caracter√≠sticas en regiones rectangulares.</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Par√°metros clave:</b><br>
                            ‚Ä¢ <b>cp = ${(p.param/100).toFixed(3)}</b>: Complexity Parameter. Controla la poda.<br>
                            ‚Ä¢ <b>maxdepth = ${p.depth}</b>: Profundidad m√°xima del √°rbol.<br>
                            ‚Ä¢ <b>minsplit = 20</b>: M√≠nimo de observaciones para dividir un nodo.<br>
                            ‚Ä¢ <b>minbucket = 7</b>: M√≠nimo de observaciones en un nodo terminal.
                        </div>
                        
                        <p><b>Ventajas:</b></p>
                        <ul>
                            <li>üìä F√°cil de interpretar y visualizar</li>
                            <li>‚ö° R√°pido entrenamiento y predicci√≥n</li>
                            <li>üîç Maneja tanto variables num√©ricas como categ√≥ricas</li>
                            <li>üìà No necesita escalado de variables</li>
                        </ul>
                        
                        <p><b>Limitaciones:</b></p>
                        <ul>
                            <li>‚ö†Ô∏è Propenso a overfitting (solucionable con poda)</li>
                            <li>üìè Fronteras de decisi√≥n paralelas a los ejes</li>
                            <li>üéØ Inestable: peque√±os cambios en datos generan √°rboles diferentes</li>
                        </ul>
                        
                        <div class="exp-highlight">
                            <b>üìà Interpretaci√≥n del √°rbol:</b>
                            <p>1. <b>Nodo ra√≠z:</b> Mejor divisi√≥n seg√∫n reducci√≥n de impureza (Gini/Entrop√≠a)</p>
                            <p>2. <b>Nodos internos:</b> Condiciones if-else sobre caracter√≠sticas</p>
                            <p>3. <b>Hojas:</b> Clase predicha y probabilidades</p>
                        </div>`;
                    } else {
                        return `
                        <div class="exp-highlight">
                            <b>‚ö° Support Vector Machines (SVM) - Kernel Radial</b>
                        </div>
                        
                        <p><b>Concepto:</b> Encuentra el hiperplano que maximiza el margen entre clases, usando kernel trick para espacios no lineales.</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Par√°metros clave:</b><br>
                            ‚Ä¢ <b>C = ${p.param}</b>: Par√°metro de regularizaci√≥n.<br>
                            ‚Ä¢ <b>œÉ = 0.1</b>: Par√°metro del kernel radial (ancho).<br>
                            ‚Ä¢ <b>Kernel:</b> Radial Basis Function (RBF).
                        </div>
                        
                        <p><b>Kernel Trick:</b> Mapea datos a espacio dimensional superior donde son linealmente separables:</p>
                        <p style="text-align: center; font-family: 'Fira Code', monospace; color: #6a9955;">
                            K(x, y) = exp(-Œ≥ ||x - y||¬≤)
                        </p>
                        
                        <p><b>Ventajas:</b></p>
                        <ul>
                            <li>üéØ Efectivo en espacios de alta dimensi√≥n</li>
                            <li>üîó Fronteras de decisi√≥n no lineales con kernels</li>
                            <li>üõ°Ô∏è Robustez contra overfitting (controlado por C)</li>
                            <li>‚≠ê Buen rendimiento con datos bien separados</li>
                        </ul>
                        
                        <p><b>Limitaciones:</b></p>
                        <ul>
                            <li>‚ö° Lento con grandes conjuntos de datos</li>
                            <li>üîß Necesita selecci√≥n cuidadosa de kernel y par√°metros</li>
                            <li>üìä Dificil interpretaci√≥n de modelos con kernel</li>
                            <li>‚öñÔ∏è Requiere escalado de variables</li>
                        </ul>
                        
                        <div class="exp-highlight">
                            <b>üéØ Trade-off Bias-Variance:</b>
                            <p>‚Ä¢ <b>C alto (${p.param > 10 ? 'ALTO' : 'MODERADO'}):</b> Margen peque√±o ‚Üí bajo bias, alta variance ‚Üí riesgo de overfitting</p>
                            <p>‚Ä¢ <b>C bajo (${p.param < 5 ? 'BAJO' : 'MODERADO'}):</b> Margen grande ‚Üí alto bias, baja variance ‚Üí riesgo de underfitting</p>
                        </div>`;
                    }
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    const isTree = p.algo.startsWith('Arbol');

                    // Contenedor principal FLEX (columna) y sin scroll (overflow: hidden)
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        flex-direction: column;
                        gap: 10px;
                        padding: 10px;
                        overflow: hidden; 
                    `;

                    // T√≠tulo com√∫n
                    const titleDiv = document.createElement('div');
                    titleDiv.style.cssText = 'text-align: center; flex-shrink: 0;';
                    titleDiv.innerHTML = isTree ? 
                        `<b style="color:#333; font-size:1.1rem;">√Årbol de Decisi√≥n (Visualizaci√≥n Interactiva)</b>` : 
                        `<b style="color:#333; font-size:1.1rem;">SVM - Fronteras de Decisi√≥n (Kernel Radial)</b>`;
                    container.appendChild(titleDiv);

                    if (isTree) {
                        // --- VISUALIZACI√ìN √ÅRBOL ---
                        
                        // 1. √Årea del Gr√°fico (SVG Flexible)
                        const svgContainer = document.createElement('div');
                        svgContainer.style.cssText = `
                            flex: 1; /* Ocupa todo el espacio sobrante */
                            width: 100%;
                            min-height: 0; /* Permite encogerse */
                            background: white;
                            border-radius: 10px;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            position: relative;
                            display: flex;
                            justify-content: center;
                            align-items: center;
                        `;

                        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        svg.setAttribute('width', '100%');
                        svg.setAttribute('height', '100%');
                        svg.setAttribute('viewBox', '0 0 600 350'); // Coordenadas fijas internas
                        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet'); // Centrar y ajustar sin deformar

                        // L√≥gica del √°rbol
                        const depth = p.depth;
                        const cp = p.param / 100;
                        const nodePositions = [];
                        // Ajustamos alturas para que quepan en el viewBox (350 de alto)
                        const levelHeight = 300 / (depth + 1); 
                        const startY = 40;

                        // Calcular posiciones
                        for(let level = 0; level <= depth; level++) {
                            const nodesAtLevel = Math.pow(2, level);
                            const levelY = startY + (level * levelHeight);
                            for(let i = 0; i < nodesAtLevel; i++) {
                                // Distribuci√≥n horizontal
                                const x = (i + 0.5) * (600 / nodesAtLevel);
                                nodePositions.push({x, y: levelY, level, index: i});
                            }
                        }

                        // Dibujar conexiones
                        nodePositions.forEach((node, idx) => {
                            if(node.level < depth) {
                                const childIdx1 = idx * 2 + 1;
                                const childIdx2 = idx * 2 + 2;
                                
                                [childIdx1, childIdx2].forEach(childIdx => {
                                    if(childIdx < nodePositions.length) {
                                        const child = nodePositions[childIdx];
                                        // Dibujar l√≠nea solo si no est√° "podado" (simulado con cp)
                                        // Para visualizaci√≥n simple, dibujamos si no es muy complejo
                                        const isPruned = node.level >= 1 && Math.random() < cp;
                                        if(!isPruned || node.level === 0) {
                                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                            line.setAttribute('x1', node.x);
                                            line.setAttribute('y1', node.y);
                                            line.setAttribute('x2', child.x);
                                            line.setAttribute('y2', child.y);
                                            line.setAttribute('stroke', '#999');
                                            line.setAttribute('stroke-width', '2');
                                            if(isPruned) line.setAttribute('stroke-dasharray', '4');
                                            svg.appendChild(line);
                                        }
                                    }
                                });
                            }
                        });

                        // Dibujar nodos
                        nodePositions.forEach((node) => {
                            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                            
                            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            circle.setAttribute('cx', node.x);
                            circle.setAttribute('cy', node.y);
                            circle.setAttribute('r', node.level === 0 ? 20 : 15);
                            
                            // Color seg√∫n tipo
                            let color = '#FF9800'; // Interno
                            if(node.level === 0) color = '#007acc'; // Ra√≠z
                            if(node.level === depth) color = '#4CAF50'; // Hoja
                            
                            circle.setAttribute('fill', color);
                            circle.setAttribute('stroke', 'white');
                            circle.setAttribute('stroke-width', '2');
                            
                            // Texto
                            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            text.setAttribute('x', node.x);
                            text.setAttribute('y', node.y + 4); // Centrar verticalmente aprox
                            text.setAttribute('text-anchor', 'middle');
                            text.setAttribute('fill', 'white');
                            text.setAttribute('font-size', '10');
                            text.setAttribute('font-weight', 'bold');
                            text.textContent = node.level === depth ? (node.index % 2 === 0 ? 'P' : 'N') : (node.level === 0 ? 'X1' : 'Xn');

                            g.appendChild(circle);
                            g.appendChild(text);
                            
                            // Interactividad simple
                            g.style.cursor = 'pointer';
                            g.onmouseover = (e) => showTooltip({target: {dataset: {tooltip: `Nivel: ${node.level}<br>Nodo: ${node.index}`}}}, e); // Reutilizando tu funci√≥n
                            g.onmouseout = hideTooltip;

                            svg.appendChild(g);
                        });

                        svgContainer.appendChild(svg);
                        container.appendChild(svgContainer);

                        // 2. Panel Inferior (Leyenda y Estad√≠sticas) - Flex Row
                        const bottomPanel = document.createElement('div');
                        bottomPanel.style.cssText = `
                            flex-shrink: 0; /* No encoger */
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            background: #f8f9fa;
                            padding: 10px 15px;
                            border-radius: 8px;
                            font-size: 0.8rem;
                            gap: 15px;
                        `;

                        // Leyenda
                        const legendDiv = document.createElement('div');
                        legendDiv.style.cssText = 'display: flex; gap: 15px;';
                        legendDiv.innerHTML = `
                            <div style="display:flex; align-items:center; gap:5px;"><div style="width:10px; height:10px; border-radius:50%; background:#007acc;"></div> Ra√≠z</div>
                            <div style="display:flex; align-items:center; gap:5px;"><div style="width:10px; height:10px; border-radius:50%; background:#FF9800;"></div> Interno</div>
                            <div style="display:flex; align-items:center; gap:5px;"><div style="width:10px; height:10px; border-radius:50%; background:#4CAF50;"></div> Hoja</div>
                        `;

                        // Stats
                        const statsDiv = document.createElement('div');
                        statsDiv.innerHTML = `<b>Profundidad:</b> ${depth} | <b>Hojas aprox:</b> ${Math.pow(2, depth)}`;

                        bottomPanel.appendChild(legendDiv);
                        bottomPanel.appendChild(statsDiv);
                        container.appendChild(bottomPanel);

                    } else {
                        // --- VISUALIZACI√ìN SVM ---
                        
                        // 1. √Årea del Gr√°fico (Flexible)
                        const plotArea = document.createElement('div');
                        plotArea.style.cssText = `
                            flex: 1; 
                            width: 100%;
                            min-height: 0; 
                            background: white; 
                            border-radius: 10px; 
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
                            position: relative; 
                            overflow: hidden;
                            border: 1px solid #eee;
                        `;

                        // Ejes simulados
                        const xAxisLabel = document.createElement('div');
                        xAxisLabel.innerText = "Variable 1 (Normalizada)";
                        xAxisLabel.style.cssText = "position:absolute; bottom:5px; width:100%; text-align:center; font-size:0.7rem; color:#666;";
                        plotArea.appendChild(xAxisLabel);

                        const yAxisLabel = document.createElement('div');
                        yAxisLabel.innerText = "Variable 2";
                        yAxisLabel.style.cssText = "position:absolute; left:5px; top:50%; transform:rotate(-90deg) translate(-50%,0); transform-origin: top left; font-size:0.7rem; color:#666;";
                        plotArea.appendChild(yAxisLabel);

                        // Frontera de decisi√≥n (C√≠rculos conc√©ntricos para RBF)
                        // Usamos % para posici√≥n y px para tama√±o para mantener forma
                        const cost = p.param; // 1 a 20
                        const borderSize = 100 + (cost * 10); // Tama√±o din√°mico
                        
                        const boundary = document.createElement('div');
                        boundary.style.cssText = `
                            position: absolute;
                            left: 50%; top: 50%;
                            transform: translate(-50%, -50%);
                            width: ${borderSize}px; height: ${borderSize}px;
                            border: 2px solid rgba(0, 122, 204, 0.5);
                            border-radius: 50%;
                            background: rgba(0, 122, 204, 0.05);
                            pointer-events: none;
                        `;
                        plotArea.appendChild(boundary);

                        const margin = document.createElement('div');
                        margin.style.cssText = `
                            position: absolute;
                            left: 50%; top: 50%;
                            transform: translate(-50%, -50%);
                            width: ${borderSize - 40}px; height: ${borderSize - 40}px;
                            border: 1px dashed rgba(0, 122, 204, 0.3);
                            border-radius: 50%;
                            pointer-events: none;
                        `;
                        plotArea.appendChild(margin);

                        // Puntos (Dots)
                        for(let i=0; i<40; i++) {
                            const dot = document.createElement('div');
                            const isClassA = Math.random() > 0.5;
                            // Distribuir algo separados
                            const angle = Math.random() * Math.PI * 2;
                            const dist = Math.random() * 40 + (isClassA ? 0 : 25); // Clase A centro, B fuera
                            
                            const x = 50 + Math.cos(angle) * dist;
                            const y = 50 + Math.sin(angle) * dist * 0.8; // Un poco el√≠ptico

                            dot.className = 'dot';
                            dot.style.left = x + '%';
                            dot.style.top = y + '%';
                            dot.style.backgroundColor = isClassA ? '#4CAF50' : '#f44336';
                            dot.style.width = '10px';
                            dot.style.height = '10px';
                            dot.style.border = '1px solid white';
                            
                            // Vectores de soporte (cercanos a la frontera 25-35 de distancia)
                            if (dist > 20 && dist < 35 && Math.random() > 0.6) {
                                dot.style.boxShadow = '0 0 0 2px #FFD700'; // Highlight
                                dot.style.zIndex = 10;
                            }

                            plotArea.appendChild(dot);
                        }

                        container.appendChild(plotArea);

                        // 2. Panel Inferior (M√©tricas Flexibles)
                        const metricsDiv = document.createElement('div');
                        metricsDiv.style.cssText = `
                            flex-shrink: 0;
                            display: flex;
                            gap: 10px;
                            justify-content: space-between;
                        `;

                        const createCard = (title, val, sub, color) => `
                            <div style="flex:1; background:${color}15; border-left:3px solid ${color}; padding:8px; border-radius:5px;">
                                <div style="font-size:0.7rem; color:#666;">${title}</div>
                                <div style="font-weight:bold; color:#333;">${val}</div>
                                <div style="font-size:0.65rem; color:#888;">${sub}</div>
                            </div>
                        `;

                        metricsDiv.innerHTML = `
                            ${createCard('Par√°metro C', cost, cost > 10 ? 'Low Bias' : 'High Margin', '#2196F3')}
                            ${createCard('Kernel', 'RBF', 'sigma=0.1', '#9C27B0')}
                            ${createCard('Soporte', Math.floor(Math.random()*10+5), 'Vectores', '#FF9800')}
                        `;
                        
                        container.appendChild(metricsDiv);
                    }

                    div.appendChild(container);                
                    }
                 },
            {
                id: 7,
                title: "Tema 7. Superv. II (Ensemble)",
                desc: "Random Forest & Boosting",
                icon: "fa-layer-group",
                controls: [
                    {id: 'ntree', type: 'range', label: 'Num. √Årboles', min: 10, max: 500, val: 50},
                    {id: 'mtry', type: 'range', label: 'Variables por split', min: 1, max: 10, val: 3}
                ],
                code: (p) => `
<span class="c-com"># TEMA 7: M√âTODOS ENSEMBLE - RANDOM FOREST</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(randomForest)
<span class="c-kwd">library</span>(caret)
<span class="c-kwd">library</span>(ggplot2)

<span class="c-com"># 1. Datos de c√°ncer de mama (Wisconsin)</span>
<span class="c-kwd">data</span>(<span class="c-str">"BreastCancer"</span>, package = <span class="c-str">"mlbench"</span>)
datos <- BreastCancer[, -1]  <span class="c-com"># Eliminar ID</span>
datos <- <span class="c-fn">na.omit</span>(datos)  <span class="c-com"># Eliminar NAs</span>

<span class="c-com"># 2. Convertir variables a num√©ricas</span>
datos[, 1:9] <- <span class="c-fn">sapply</span>(datos[, 1:9], <span class="c-arg">as.numeric</span>)
datos<span class="c-var">$Class</span> <- <span class="c-fn">factor</span>(datos<span class="c-var">$Class</span>)

<span class="c-com"># 3. Divisi√≥n entrenamiento/prueba</span>
<span class="c-kwd">set.seed</span>(123)
indices <- <span class="c-fn">createDataPartition</span>(datos<span class="c-var">$Class</span>, <span class="c-arg">p</span> = 0.7, <span class="c-arg">list</span> = FALSE)
train <- datos[indices, ]
test  <- datos[-indices, ]

<span class="c-com"># 4. Configurar Random Forest</span>
ntrees <- <span class="c-num">${p.ntree}</span>
mtry_val <- <span class="c-num">${p.mtry}</span>

<span class="c-com"># 5. Entrenar Random Forest</span>
rf_model <- <span class="c-fn">randomForest</span>(
  Class ~ .,
  <span class="c-arg">data</span> = train,
  <span class="c-arg">ntree</span> = ntrees,
  <span class="c-arg">mtry</span> = mtry_val,
  <span class="c-arg">importance</span> = TRUE,
  <span class="c-arg">proximity</span> = TRUE,
  <span class="c-arg">na.action</span> = na.omit
)

<span class="c-com"># 6. Evaluar modelo</span>
rf_pred <- <span class="c-fn">predict</span>(rf_model, test)
rf_cm <- <span class="c-fn">confusionMatrix</span>(rf_pred, test<span class="c-var">$Class</span>)

<span class="c-fn">cat</span>(<span class="c-str">"=== RANDOM FOREST ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"N√∫mero √°rboles:"</span>, ntrees, <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"mtry (variables por split):"</span>, mtry_val, <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"OOB error:"</span>, <span class="c-fn">round</span>(rf_model<span class="c-var">$err.rate</span>[ntrees, 1], 4), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Accuracy test:"</span>, <span class="c-fn">round</span>(rf_cm<span class="c-var">$overall</span>[1], 3), <span class="c-str">"\\n"</span>)

<span class="c-com"># 7. Importancia de variables</span>
importance_df <- <span class="c-fn">as.data.frame</span>(rf_model<span class="c-var">$importance</span>)
importance_df<span class="c-var">$Variable</span> <- <span class="c-fn">rownames</span>(importance_df)

ggplot(importance_df, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = reorder(Variable, MeanDecreaseGini), 
                       <span class="c-arg">y</span> = MeanDecreaseGini)) +
  <span class="c-fn">geom_bar</span>(<span class="c-arg">stat</span> = <span class="c-str">"identity"</span>, <span class="c-arg">fill</span> = <span class="c-str">"steelblue"</span>) +
  <span class="c-fn">coord_flip</span>() +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">labs</span>(<span class="c-arg">title</span> = <span class="c-str">"Importancia de Variables (MeanDecreaseGini)"</span>,
       <span class="c-arg">x</span> = <span class="c-str">"Variable"</span>,
       <span class="c-arg">y</span> = <span class="c-str">"Mean Decrease Gini"</span>)

<span class="c-com"># 8. Error vs n√∫mero de √°rboles</span>
error_df <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">Trees</span> = 1:ntrees,
  <span class="c-arg">OOB_Error</span> = rf_model<span class="c-var">$err.rate</span>[,1]
)

ggplot(error_df, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = Trees, <span class="c-arg">y</span> = OOB_Error)) +
  <span class="c-fn">geom_line</span>(<span class="c-arg">color</span> = <span class="c-str">"steelblue"</span>, <span class="c-arg">lwd</span> = 1) +
  <span class="c-fn">geom_hline</span>(<span class="c-fn">aes</span>(<span class="c-arg">yintercept</span> = <span class="c-fn">min</span>(OOB_Error)), 
             <span class="c-arg">linetype</span> = <span class="c-str">"dashed"</span>, <span class="c-arg">color</span> = <span class="c-str">"red"</span>) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">labs</span>(<span class="c-arg">title</span> = <span class="c-str">"Error OOB vs N√∫mero de √Årboles"</span>,
       <span class="c-arg">x</span> = <span class="c-str">"N√∫mero de √Årboles"</span>,
       <span class="c-arg">y</span> = <span class="c-str">"Error OOB"</span>)

<span class="c-com"># 9. Comparar con √°rbol simple</span>
<span class="c-kwd">library</span>(rpart)
single_tree <- <span class="c-fn">rpart</span>(Class ~ ., <span class="c-arg">data</span> = train, <span class="c-arg">method</span> = <span class="c-str">"class"</span>)
tree_pred <- <span class="c-fn">predict</span>(single_tree, test, <span class="c-arg">type</span> = <span class="c-str">"class"</span>)
tree_cm <- <span class="c-fn">confusionMatrix</span>(tree_pred, test<span class="c-var">$Class</span>)

<span class="c-fn">cat</span>(<span class="c-str">"\\n=== COMPARACI√ìN √ÅRBOL SIMPLE vs RANDOM FOREST ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"√Årbol simple accuracy:"</span>, <span class="c-fn">round</span>(tree_cm<span class="c-var">$overall</span>[1], 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Random Forest accuracy:"</span>, <span class="c-fn">round</span>(rf_cm<span class="c-var">$overall</span>[1], 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Mejora:"</span>, <span class="c-fn">round</span>((rf_cm<span class="c-var">$overall</span>[1] - tree_cm<span class="c-var">$overall</span>[1]) * 100, 1), <span class="c-str">"%\\n"</span>)`,
                explain: (p) => {
                    return `
                        <div class="exp-highlight">
                            <b>üå≤ Random Forest - M√©todos Ensemble</b>
                        </div>
                        
                        <p><b>Concepto:</b> M√©todo de ensemble que combina m√∫ltiples √°rboles de decisi√≥n mediante bagging y aleatorizaci√≥n.</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Par√°metros clave:</b><br>
                            ‚Ä¢ <b>ntree = ${p.ntree}</b>: N√∫mero de √°rboles en el bosque<br>
                            ‚Ä¢ <b>mtry = ${p.mtry}</b>: Variables consideradas en cada split<br>
                            ‚Ä¢ <b>nodesize = 1</b>: Tama√±o m√≠nimo de nodos terminales<br>
                            ‚Ä¢ <b>maxnodes = NULL</b>: Sin l√≠mite de nodos
                        </div>
                        
                        <p><b>Dos fuentes de aleatorizaci√≥n:</b></p>
                        <p>1. <b>Bagging (Bootstrap Aggregating):</b> Muestreo con reemplazo de observaciones</p>
                        <p>2. <b>Feature Randomization:</b> Selecci√≥n aleatoria de variables en cada split</p>
                        
                        <div class="exp-highlight">
                            <b>üìä Error Out-of-Bag (OOB):</b>
                            <p>Error estimado usando observaciones no incluidas en el bootstrap sample de cada √°rbol.</p>
                            <p><b>Ventaja:</b> No necesita conjunto de validaci√≥n separado.</p>
                        </div>
                        
                        <p><b>Importancia de variables:</b></p>
                        <p>1. <b>MeanDecreaseAccuracy:</b> Reducci√≥n en accuracy al permutar la variable</p>
                        <p>2. <b>MeanDecreaseGini:</b> Reducci√≥n total en impureza (Gini) debida a la variable</p>
                        
                        <div class="exp-highlight">
                            <b>‚ö° Ventajas sobre √°rboles individuales:</b>
                            <p>‚Ä¢ üõ°Ô∏è <b>Reducci√≥n de varianza</b> (menos overfitting)</p>
                            <p>‚Ä¢ üîß <b>Robustez a outliers</b> y ruido</p>
                            <p>‚Ä¢ üìà <b>Mejor generalizaci√≥n</b></p>
                            <p>‚Ä¢ üéØ <b>Estimaci√≥n de importancia</b> de variables</p>
                            <p>‚Ä¢ üìä <b>Error OOB</b> para validaci√≥n</p>
                        </div>
                        
                        <p><b>üìâ Ley de rendimientos decrecientes:</b></p>
                        <p>El error OOB disminuye r√°pidamente al principio y luego se estabiliza. Con ${p.ntree} √°rboles:</p>
                        <p>‚Ä¢ ${p.ntree < 50 ? '‚ùå Muy pocos √°rboles: alta varianza' : 
                            p.ntree < 200 ? '‚úÖ Cantidad adecuada' : 
                            '‚ö†Ô∏è Muchos √°rboles: costo computacional innecesario'}</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-lightbulb"></i> <b>Regla pr√°ctica para mtry:</b>
                            <p>‚Ä¢ Clasificaci√≥n: mtry = ‚àöp (${p.mtry} variables)</p>
                            <p>‚Ä¢ Regresi√≥n: mtry = p/3</p>
                            <p>Donde p = n√∫mero total de variables predictoras</p>
                        </div>
                        
                        <div class="exp-highlight">
                            <b>üß¨ Aplicaci√≥n en GWAS y QTL mapping:</b>
                            <p>Random Forest es excelente para detectar interacciones g√©nicas (epistasis) en estudios de asociaci√≥n gen√≥mica.</p>
                        </div>`;
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        flex-direction: column;
                        gap: 15px;
                        padding: 10px;
                        overflow: hidden; /* Evita que se salga el contenido */
                    `;
                    
                    // --- SECCI√ìN SUPERIOR: VISUALIZACI√ìN DEL BOSQUE (SVG AUTO-AJUSTABLE) ---
                    const forestSection = document.createElement('div');
                    forestSection.style.cssText = `
                        flex: 1; /* Ocupa la mitad superior */
                        background: white;
                        border-radius: 10px;
                        padding: 10px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        display: flex;
                        flex-direction: column;
                        min-height: 0; /* Permite encogerse */
                    `;
                    
                    const forestTitle = document.createElement('div');
                    forestTitle.innerHTML = `<b style="color:#333; font-size:1rem;">Random Forest - ${p.ntree} √Årboles</b>`;
                    forestTitle.style.cssText = 'text-align: center; margin-bottom: 5px; height: 20px;';
                    forestSection.appendChild(forestTitle);
                    
                    // Contenedor SVG
                    const svgContainer = document.createElement('div');
                    svgContainer.style.cssText = "flex: 1; width: 100%; position: relative; overflow: hidden;";
                    
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', '100%');
                    svg.setAttribute('viewBox', '0 0 800 200'); // Coordenadas fijas internas
                    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                    
                    // Dibujar arbolitos en el SVG
                    // Mostramos hasta 18 √°rboles visualmente para no saturar, distribuidos en grid
                    const maxVisualTrees = 18;
                    const treesToShow = Math.min(p.ntree, maxVisualTrees);
                    const cols = 6;
                    const rows = 3;
                    const cellW = 800 / cols;
                    const cellH = 200 / rows;
                    
                    for(let i = 0; i < treesToShow; i++) {
                        const col = i % cols;
                        const row = Math.floor(i / cols);
                        const cx = col * cellW + cellW/2;
                        const cy = row * cellH + cellH/2;
                        
                        // Grupo para un √°rbol
                        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        
                        // Tronco
                        const trunk = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        trunk.setAttribute('x1', cx);
                        trunk.setAttribute('y1', cy + 20);
                        trunk.setAttribute('x2', cx);
                        trunk.setAttribute('y2', cy - 10);
                        trunk.setAttribute('stroke', '#8D6E63');
                        trunk.setAttribute('stroke-width', '4');
                        
                        // Ramas (Tri√°ngulo)
                        const leaves = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        leaves.setAttribute('d', `M ${cx-15} ${cy+5} L ${cx} ${cy-25} L ${cx+15} ${cy+5} Z`);
                        // Alternar colores para variedad
                        const color = ['#4CAF50', '#66BB6A', '#81C784'][i % 3];
                        leaves.setAttribute('fill', color);
                        
                        // Nodo ra√≠z (punto blanco)
                        const node = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        node.setAttribute('cx', cx);
                        node.setAttribute('cy', cy - 10);
                        node.setAttribute('r', '3');
                        node.setAttribute('fill', 'white');
                        
                        g.appendChild(trunk);
                        g.appendChild(leaves);
                        g.appendChild(node);
                        
                        // Animaci√≥n de entrada suave
                        g.style.opacity = 0;
                        g.style.transition = 'opacity 0.5s';
                        setTimeout(() => g.style.opacity = 1, i * 50);
                        
                        svg.appendChild(g);
                    }
                    
                    // Si hay m√°s √°rboles de los visibles, poner texto
                    if(p.ntree > maxVisualTrees) {
                        const moreText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        moreText.setAttribute('x', 750);
                        moreText.setAttribute('y', 180);
                        moreText.setAttribute('fill', '#666');
                        moreText.setAttribute('font-size', '14');
                        moreText.textContent = `+${p.ntree - maxVisualTrees} m√°s...`;
                        svg.appendChild(moreText);
                    }
                    
                    svgContainer.appendChild(svg);
                    forestSection.appendChild(svgContainer);
                    container.appendChild(forestSection);
                    
                    // --- SECCI√ìN INFERIOR: M√âTRICAS Y BARRAS (FLEXIBLE) ---
                    const bottomSection = document.createElement('div');
                    bottomSection.style.cssText = `
                        flex: 1.2; /* Un poco m√°s grande que la parte superior */
                        display: flex;
                        gap: 15px;
                        min-height: 0;
                    `;
                    
                    // 1. Panel de Importancia de Variables (Izquierda)
                    const importanceDiv = document.createElement('div');
                    importanceDiv.style.cssText = `
                        flex: 1.5;
                        background: white;
                        border-radius: 10px;
                        padding: 15px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        display: flex;
                        flex-direction: column;
                        overflow: hidden;
                    `;
                    
                    const impTitle = document.createElement('div');
                    impTitle.innerHTML = `<b style="color:#333; font-size:0.9rem;">Importancia de Variables</b>`;
                    impTitle.style.cssText = 'margin-bottom: 10px; text-align: center; height: 20px;';
                    importanceDiv.appendChild(impTitle);
                    
                    // Contenedor de barras que distribuye el espacio verticalmente
                    const barContainer = document.createElement('div');
                    barContainer.style.cssText = `
                        flex: 1;
                        display: flex;
                        flex-direction: column;
                        justify-content: space-between; /* Distribuye barras uniformemente */
                        min-height: 0;
                        padding-bottom: 5px;
                    `;
                    
                    // Datos simulados
                    const variables = [
                        {name: 'ClumpThick', value: 95},
                        {name: 'CellSize', value: 88},
                        {name: 'CellShape', value: 85},
                        {name: 'MargAdh', value: 72},
                        {name: 'EpithSize', value: 68},
                        {name: 'BareNuc', value: 65}
                    ];
                    
                    // Ajustar valores seg√∫n par√°metros
                    variables.forEach(v => {
                        v.value += (Math.random() - 0.5) * (10 - p.mtry);
                        v.value = Math.max(20, Math.min(100, v.value));
                    });
                    variables.sort((a, b) => b.value - a.value);
                    
                    variables.forEach(v => {
                        const row = document.createElement('div');
                        row.style.cssText = 'display: flex; align-items: center; gap: 10px; height: 18px;';
                        
                        const label = document.createElement('div');
                        label.style.cssText = 'width: 80px; text-align: right; font-size: 0.75rem; color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;';
                        label.textContent = v.name;
                        
                        const barBg = document.createElement('div');
                        barBg.style.cssText = 'flex: 1; background: #f0f0f0; height: 100%; border-radius: 4px; overflow: hidden;';
                        
                        const barFill = document.createElement('div');
                        barFill.style.cssText = `width: ${v.value}%; height: 100%; background: #00BCD4; border-radius: 4px; transition: width 1s;`;
                        
                        const val = document.createElement('div');
                        val.style.cssText = 'width: 25px; font-size: 0.75rem; font-weight: bold; color: #555;';
                        val.textContent = Math.round(v.value);
                        
                        barBg.appendChild(barFill);
                        row.appendChild(label);
                        row.appendChild(barBg);
                        row.appendChild(val);
                        barContainer.appendChild(row);
                    });
                    
                    importanceDiv.appendChild(barContainer);
                    bottomSection.appendChild(importanceDiv);
                    
                    // 2. Panel de Estad√≠sticas (Derecha)
                    const statsDiv = document.createElement('div');
                    statsDiv.style.cssText = `
                        flex: 1;
                        background: white;
                        border-radius: 10px;
                        padding: 15px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        display: flex;
                        flex-direction: column;
                        overflow: hidden;
                    `;
                    
                    const statsTitle = document.createElement('div');
                    statsTitle.innerHTML = `<b style="color:#333; font-size:0.9rem;">M√©tricas del Modelo</b>`;
                    statsTitle.style.cssText = 'margin-bottom: 10px; text-align: center; height: 20px;';
                    statsDiv.appendChild(statsTitle);
                    
                    // Contenedor de cards que se auto-ajustan
                    const cardsContainer = document.createElement('div');
                    cardsContainer.style.cssText = `
                        flex: 1;
                        display: flex;
                        flex-direction: column;
                        justify-content: space-between;
                        gap: 8px;
                        min-height: 0;
                    `;
                    
                    // Funci√≥n para crear tarjeta flexible
                    const createCard = (label, val, sub, color) => `
                        <div style="
                            background: ${color}15; 
                            border-left: 4px solid ${color}; 
                            padding: 8px 12px; 
                            border-radius: 6px;
                            flex: 1; /* CLAVE: Ocupa espacio disponible */
                            display: flex;
                            flex-direction: column;
                            justify-content: center;
                            min-height: 0;
                        ">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="font-weight: bold; color: ${color}; font-size: 0.9rem;">${label}</span>
                                <span style="font-weight: bold; font-size: 1rem; color: #333;">${val}</span>
                            </div>
                            <div style="font-size: 0.7rem; color: #666; margin-top: 2px;">${sub}</div>
                        </div>
                    `;
                    
                    // C√°lculos
                    const oob = 0.05 + (500 - p.ntree) / 5000;
                    const acc = 0.95 - (500 - p.ntree) / 1000;
                    
                    cardsContainer.innerHTML = `
                        ${createCard('√Årboles', p.ntree, p.ntree < 100 ? 'Pocos (Alta Varianza)' : '√ìptimo', '#4CAF50')}
                        ${createCard('mtry', p.mtry, 'Variables por split', '#4CAF50')}
                        ${createCard('Error OOB', oob.toFixed(4), 'Out-of-Bag error', '#f44336')}
                        ${createCard('Accuracy', acc.toFixed(3), 'Precisi√≥n estimada', '#f44336')}
                    `;
                    
                    statsDiv.appendChild(cardsContainer);
                    bottomSection.appendChild(statsDiv);
                    
                    container.appendChild(bottomSection);
                    div.appendChild(container);
                                }
            },
            {
                id: 8,
                title: "Tema 8. Evaluaci√≥n",
                desc: "ROC & Confusion Matrix",
                icon: "fa-check-double",
                controls: [
                    {id: 'th', type: 'range', label: 'Umbral Corte', min: 10, max: 90, val: 50},
                    {id: 'prevalence', type: 'range', label: 'Prevalencia (%)', min: 5, max: 50, val: 25}
                ],
                code: (p) => `
<span class="c-com"># TEMA 8: EVALUACI√ìN DE MODELOS - CURVA ROC</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(pROC)
<span class="c-kwd">library</span>(caret)
<span class="c-kwd">library</span>(ggplot2)
<span class="c-kwd">library</span>(plotROC)

<span class="c-com"># 1. Datos simulados: probabilidades predichas vs reales</span>
<span class="c-kwd">set.seed</span>(123)
n <- 200
prevalencia <- <span class="c-num">${p.prevalence / 100}</span>

<span class="c-com"># Generar etiquetas reales (con cierta prevalencia)</span>
y_real <- <span class="c-fn">c</span>(
  <span class="c-fn">rep</span>(0, <span class="c-fn">round</span>(n * (1 - prevalencia))),
  <span class="c-fn">rep</span>(1, <span class="c-fn">round</span>(n * prevalencia))
)

<span class="c-com"># Generar probabilidades predichas (con cierto grado de separaci√≥n)</span>
y_prob <- <span class="c-fn">c</span>(
  <span class="c-fn">rbeta</span>(<span class="c-fn">round</span>(n * (1 - prevalencia)), 2, 5),  <span class="c-com"># Clase 0</span>
  <span class="c-fn">rbeta</span>(<span class="c-fn">round</span>(n * prevalencia), 5, 2)     <span class="c-com"># Clase 1</span>
)

datos <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">real</span> = <span class="c-fn">factor</span>(y_real, <span class="c-arg">levels</span> = <span class="c-fn">c</span>(0, 1), <span class="c-arg">labels</span> = <span class="c-fn">c</span>(<span class="c-str">"Negativo"</span>, <span class="c-str">"Positivo"</span>)),
  <span class="c-arg">prob</span> = y_prob
)

<span class="c-com"># 2. Aplicar umbral de corte</span>
umbral <- <span class="c-num">${p.th / 100}</span>
datos<span class="c-var">$pred</span> <- <span class="c-fn">factor</span>(
  <span class="c-fn">ifelse</span>(datos<span class="c-var">$prob</span> > umbral, 1, 0),
  <span class="c-arg">levels</span> = <span class="c-fn">c</span>(0, 1),
  <span class="c-arg">labels</span> = <span class="c-fn">c</span>(<span class="c-str">"Negativo"</span>, <span class="c-str">"Positivo"</span>)
)

<span class="c-com"># 3. Matriz de confusi√≥n</span>
cm <- <span class="c-fn">confusionMatrix</span>(datos<span class="c-var">$pred</span>, datos<span class="c-var">$real</span>, <span class="c-arg">positive</span> = <span class="c-str">"Positivo"</span>)

<span class="c-fn">cat</span>(<span class="c-str">"=== MATRIZ DE CONFUSI√ìN ===\\n"</span>)
<span class="c-fn">print</span>(cm<span class="c-var">$table</span>)
<span class="c-fn">cat</span>(<span class="c-str">"\\n=== M√âTRICAS ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Umbral:"</span>, umbral, <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Accuracy:"</span>, <span class="c-fn">round</span>(cm<span class="c-var">$overall</span>[1], 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Sensitivity (Recall):"</span>, <span class="c-fn">round</span>(cm<span class="c-var">$byClass</span>[1], 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Specificity:"</span>, <span class="c-fn">round</span>(cm<span class="c-var">$byClass</span>[2], 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Precision (PPV):"</span>, <span class="c-fn">round</span>(cm<span class="c-var">$byClass</span>[3], 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"F1-Score:"</span>, <span class="c-fn">round</span>(cm<span class="c-var">$byClass</span>[7], 3), <span class="c-str">"\\n"</span>)

<span class="c-com"># 4. Curva ROC</span>
roc_obj <- <span class="c-fn">roc</span>(
  <span class="c-arg">response</span> = datos<span class="c-var">$real</span>,
  <span class="c-arg">predictor</span> = datos<span class="c-var">$prob</span>,
  <span class="c-arg">levels</span> = <span class="c-fn">c</span>(<span class="c-str">"Negativo"</span>, <span class="c-str">"Positivo"</span>),
  <span class="c-arg">direction</span> = <span class="c-str">"<"</span>
)

<span class="c-com"># 5. AUC y punto √≥ptimo (Youden's J statistic)</span>
auc_val <- <span class="c-fn">auc</span>(roc_obj)
optimal_point <- <span class="c-fn">coords</span>(
  roc_obj,
  <span class="c-arg">x</span> = <span class="c-str">"best"</span>,
  <span class="c-arg">ret</span> = <span class="c-fn">c</span>(<span class="c-str">"threshold"</span>, <span class="c-str">"specificity"</span>, <span class="c-str">"sensitivity"</span>)
)

<span class="c-fn">cat</span>(<span class="c-str">"\\n=== CURVA ROC ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"AUC:"</span>, <span class="c-fn">round</span>(auc_val, 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Punto √≥ptimo (Youden):\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"  Threshold:"</span>, <span class="c-fn">round</span>(optimal_point<span class="c-var">$threshold</span>, 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"  Sensitivity:"</span>, <span class="c-fn">round</span>(optimal_point<span class="c-var">$sensitivity</span>, 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"  Specificity:"</span>, <span class="c-fn">round</span>(optimal_point<span class="c-var">$specificity</span>, 3), <span class="c-str">"\\n"</span>)

<span class="c-com"># 6. Visualizaci√≥n curva ROC</span>
roc_plot <- <span class="c-fn">ggplot</span>(datos, <span class="c-fn">aes</span>(<span class="c-arg">d</span> = real, <span class="c-arg">m</span> = prob)) +
  <span class="c-fn">geom_roc</span>(<span class="c-arg">n.cuts</span> = 20, <span class="c-arg">labels</span> = FALSE) +
  <span class="c-fn">geom_abline</span>(<span class="c-arg">slope</span> = 1, <span class="c-arg">intercept</span> = 0, 
                <span class="c-arg">linetype</span> = <span class="c-str">"dashed"</span>, <span class="c-arg">alpha</span> = 0.7) +
  <span class="c-fn">geom_point</span>(<span class="c-arg">data</span> = <span class="c-fn">data.frame</span>(
    <span class="c-arg">x</span> = 1 - optimal_point<span class="c-var">$specificity</span>,
    <span class="c-arg">y</span> = optimal_point<span class="c-var">$sensitivity</span>
  ), <span class="c-fn">aes</span>(<span class="c-arg">x</span> = x, <span class="c-arg">y</span> = y), 
  <span class="c-arg">color</span> = <span class="c-str">"red"</span>, <span class="c-arg">size</span> = 3) +
  <span class="c-fn">geom_point</span>(<span class="c-arg">data</span> = <span class="c-fn">data.frame</span>(
    <span class="c-arg">x</span> = 1 - cm<span class="c-var">$byClass</span>[2],  <span class="c-com"># 1 - specificity</span>
    <span class="c-arg">y</span> = cm<span class="c-var">$byClass</span>[1]        <span class="c-com"># sensitivity</span>
  ), <span class="c-fn">aes</span>(<span class="c-arg">x</span> = x, <span class="c-arg">y</span> = y), 
  <span class="c-arg">color</span> = <span class="c-str">"blue"</span>, <span class="c-arg">size</span> = 3) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">labs</span>(<span class="c-arg">title</span> = <span class="c-str">"Curva ROC"</span>,
       <span class="c-arg">subtitle</span> = <span class="c-fn">paste</span>(<span class="c-str">"AUC ="</span>, <span class="c-fn">round</span>(auc_val, 3)),
       <span class="c-arg">x</span> = <span class="c-str">"1 - Specificity (False Positive Rate)"</span>,
       <span class="c-arg">y</span> = <span class="c-str">"Sensitivity (True Positive Rate)"</span>) +
  <span class="c-fn">annotate</span>(<span class="c-str">"text"</span>, <span class="c-arg">x</span> = 0.7, <span class="c-arg">y</span> = 0.3,
           <span class="c-arg">label</span> = <span class="c-fn">paste</span>(<span class="c-str">"Umbral actual:"</span>, umbral), 
           <span class="c-arg">color</span> = <span class="c-str">"blue"</span>) +
  <span class="c-fn">annotate</span>(<span class="c-str">"text"</span>, <span class="c-arg">x</span> = 0.7, <span class="c-arg">y</span> = 0.2,
           <span class="c-arg">label</span> = <span class="c-fn">paste</span>(<span class="c-str">"Umbral √≥ptimo:"</span>, <span class="c-fn">round</span>(optimal_point<span class="c-var">$threshold</span>, 3)), 
           <span class="c-arg">color</span> = <span class="c-str">"red"</span>)

<span class="c-com"># 7. Distribuci√≥n de probabilidades por clase</span>
dist_plot <- <span class="c-fn">ggplot</span>(datos, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = prob, <span class="c-arg">fill</span> = real)) +
  <span class="c-fn">geom_density</span>(<span class="c-arg">alpha</span> = 0.5) +
  <span class="c-fn">geom_vline</span>(<span class="c-arg">xintercept</span> = umbral, <span class="c-arg">linetype</span> = <span class="c-str>"dashed"</span>, <span class="c-arg">color</span> = <span class="c-str">"blue"</span>) +
  <span class="c-fn">geom_vline</span>(<span class="c-arg">xintercept</span> = optimal_point<span class="c-var">$threshold</span>, 
                <span class="c-arg">linetype</span> = <span class="c-str">"dashed"</span>, <span class="c-arg">color</span> = <span class="c-str">"red"</span>) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">labs</span>(<span class="c-arg">title</span> = <span class="c-str">"Distribuci√≥n de Probabilidades"</span>,
       <span class="c-arg">x</span> = <span class="c-str">"Probabilidad Predicha"</span>,
       <span class="c-arg">y</span> = <span class="c-str">"Densidad"</span>,
       <span class="c-arg">fill</span> = <span class="c-str">"Clase Real"</span>)

<span class="c-com"># 8. Mostrar ambas visualizaciones</span>
<span class="c-kwd">library</span>(gridExtra)
<span class="c-fn">grid.arrange</span>(roc_plot, dist_plot, <span class="c-arg">ncol</span> = 2)`,
                explain: (p) => {
                    const threshold = p.th / 100;
                    const prevalence = p.prevalence / 100;
                    
                    return `
                        <div class="exp-highlight">
                            <b>üìä Evaluaci√≥n de Modelos de Clasificaci√≥n</b>
                        </div>
                        
                        <p><b>Concepto:</b> Medir el rendimiento de un modelo de clasificaci√≥n usando diversas m√©tricas y visualizaciones.</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Par√°metros:</b><br>
                            ‚Ä¢ <b>Umbral = ${threshold.toFixed(2)}</b>: Punto de corte para clasificaci√≥n<br>
                            ‚Ä¢ <b>Prevalencia = ${(prevalence * 100).toFixed(1)}%</b>: Proporci√≥n de casos positivos
                        </div>
                        
                        <div class="exp-highlight">
                            <b>üß© Matriz de Confusi√≥n (2√ó2):</b>
                            <table style="width:100%; border-collapse: collapse; margin: 10px 0;">
                                <tr style="background: rgba(0,122,204,0.1);">
                                    <th style="padding: 8px; border: 1px solid #007acc;"></th>
                                    <th style="padding: 8px; border: 1px solid #007acc;" colspan="2">Real</th>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333;"></td>
                                    <td style="padding: 8px; border: 1px solid #333; background: #e8f5e8;">Positivo</td>
                                    <td style="padding: 8px; border: 1px solid #333; background: #ffebee;">Negativo</td>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333; background: #e8f5e8;">Positivo</td>
                                    <td style="padding: 8px; border: 1px solid #333; text-align: center;">TP</td>
                                    <td style="padding: 8px; border: 1px solid #333; text-align: center;">FP</td>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333; background: #ffebee;">Negativo</td>
                                    <td style="padding: 8px; border: 1px solid #333; text-align: center;">FN</td>
                                    <td style="padding: 8px; border: 1px solid #333; text-align: center;">TN</td>
                                </tr>
                            </table>
                        </div>
                        
                        <p><b>M√©tricas derivadas:</b></p>
                        <p>‚Ä¢ <b>Accuracy</b> = (TP+TN)/(TP+FP+FN+TN) ‚Üí Exactitud global</p>
                        <p>‚Ä¢ <b>Sensitivity/Recall</b> = TP/(TP+FN) ‚Üí Capacidad de detectar positivos</p>
                        <p>‚Ä¢ <b>Specificity</b> = TN/(TN+FP) ‚Üí Capacidad de detectar negativos</p>
                        <p>‚Ä¢ <b>Precision</b> = TP/(TP+FP) ‚Üí Calidad de predicciones positivas</p>
                        <p>‚Ä¢ <b>F1-Score</b> = 2√ó(Precision√óRecall)/(Precision+Recall) ‚Üí Media arm√≥nica</p>
                        
                        <div class="exp-highlight">
                            <b>üìà Curva ROC (Receiver Operating Characteristic)</b>
                            <p>Grafica Sensitivity (TPR) vs 1-Specificity (FPR) para todos los umbrales posibles.</p>
                        </div>
                        
                        <p><b>Interpretaci√≥n ROC:</b></p>
                        <p>‚Ä¢ <b>AUC = 0.5</b>: Modelo aleatorio (diagonal)</p>
                        <p>‚Ä¢ <b>AUC = 0.7-0.8</b>: Modelo aceptable</p>
                        <p>‚Ä¢ <b>AUC = 0.8-0.9</b>: Modelo bueno</p>
                        <p>‚Ä¢ <b>AUC > 0.9</b>: Modelo excelente</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-balance-scale"></i> <b>Trade-off Sensibilidad vs Especificidad:</b>
                            <p>‚Ä¢ <b>Umbral bajo (${threshold < 0.3 ? '‚Üì' : '‚Üë'})</b>: Alta sensibilidad, baja especificidad ‚Üí muchos FP</p>
                            <p>‚Ä¢ <b>Umbral alto (${threshold > 0.7 ? '‚Üë' : '‚Üì'})</b>: Baja sensibilidad, alta especificidad ‚Üí muchos FN</p>
                            <p>‚Ä¢ <b>Umbral √≥ptimo</b>: Maximiza J = Sensitivity + Specificity - 1 (Youden's J)</p>
                        </div>
                        
                        <div class="exp-highlight">
                            <b>üéØ Contexto cl√≠nico:</b>
                            <p>La elecci√≥n del umbral depende del costo de los errores:</p>
                            <p>‚Ä¢ <b>Cribado</b>: Umbral bajo ‚Üí no pasar por alto casos (alta sensibilidad)</p>
                            <p>‚Ä¢ <b>Confirmaci√≥n</b>: Umbral alto ‚Üí evitar falsos positivos (alta especificidad)</p>
                        </div>
                        
                        <p><b>üìä Prevalencia y valor predictivo:</b></p>
                            <p>‚Ä¢ <b>PPV</b> (Positive Predictive Value) = TP/(TP+FP) ‚Üí depende de prevalencia</p>
                            <p>‚Ä¢ <b>NPV</b> (Negative Predictive Value) = TN/(TN+FN) ‚Üí depende de prevalencia</p>
                            <p>Con prevalencia ${(prevalence * 100).toFixed(1)}%, incluso un test perfecto tiene limitaciones en PPV.</p>`;
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        flex-direction: column;
                        gap: 15px;
                        padding: 10px;
                        overflow: hidden; 
                    `;
                    
                    // --- SECCI√ìN SUPERIOR: MATRIZ Y M√âTRICAS ---
                    const topSection = document.createElement('div');
                    topSection.style.cssText = `
                        flex: 1;
                        display: flex;
                        gap: 20px;
                        min-height: 0; 
                    `;
                    
                    // 1. Panel de Matriz de Confusi√≥n
                    const matrixPanel = document.createElement('div');
                    matrixPanel.style.cssText = `
                        flex: 1;
                        background: white;
                        border-radius: 10px;
                        padding: 15px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        display: flex;
                        flex-direction: column;
                        overflow: hidden;
                    `;
                    
                    const matrixTitle = document.createElement('div');
                    matrixTitle.innerHTML = `<b style="color:#333; font-size:0.9rem;">Matriz de Confusi√≥n</b>`;
                    matrixTitle.style.cssText = 'margin-bottom: 10px; text-align: center; height: 20px;';
                    matrixPanel.appendChild(matrixTitle);
                    
                    // Contenedor el√°stico para la matriz
                    const matrixContainer = document.createElement('div');
                    matrixContainer.style.cssText = `
                        flex: 1;
                        display: grid;
                        grid-template-columns: 20% 40% 40%;
                        grid-template-rows: 15% 42.5% 42.5%;
                        gap: 2px;
                        width: 100%;
                        height: 100%;
                        min-height: 0;
                    `;
                    
                    const cellStyle = (bg) => `
                        background: ${bg}; 
                        border: 1px solid #dee2e6; 
                        display: flex; 
                        flex-direction: column;
                        align-items: center; 
                        justify-content: center; 
                        font-size: 0.8rem;
                        padding: 2px;
                        text-align: center;
                        overflow: hidden;
                    `;
                    
                    // C√°lculos
                    const prevalence = p.prevalence / 100;
                    const threshold = p.th / 100;
                    const total = 200;
                    const realPos = Math.round(total * prevalence);
                    const realNeg = total - realPos;
                    const tp = Math.round(realPos * (0.8 - (threshold - 0.5) * 0.6));
                    const fn = realPos - tp;
                    const tn = Math.round(realNeg * (0.7 + (threshold - 0.5) * 0.6));
                    const fp = realNeg - tn;
                    
                    // Generar celdas
                    const els = [
                        {html: '', style: cellStyle('#f8f9fa')}, 
                        {html: '<b>Real<br>Positivo</b>', style: cellStyle('#e8f5e8')},
                        {html: '<b>Real<br>Negativo</b>', style: cellStyle('#ffebee')},
                        
                        {html: '<b style="writing-mode: vertical-rl; transform: rotate(180deg);">Predicho Pos</b>', style: cellStyle('#e8f5e8')},
                        {html: `<b style="font-size:1.2rem">${tp}</b><small>TP</small>`, style: cellStyle('#c8e6c9')},
                        {html: `<b style="font-size:1.2rem">${fp}</b><small>FP</small>`, style: cellStyle('#ffcdd2')},
                        
                        {html: '<b style="writing-mode: vertical-rl; transform: rotate(180deg);">Predicho Neg</b>', style: cellStyle('#ffebee')},
                        {html: `<b style="font-size:1.2rem">${fn}</b><small>FN</small>`, style: cellStyle('#ffcdd2')},
                        {html: `<b style="font-size:1.2rem">${tn}</b><small>TN</small>`, style: cellStyle('#c8e6c9')}
                    ];
                    
                    els.forEach(item => {
                        const div = document.createElement('div');
                        div.innerHTML = item.html;
                        div.style.cssText = item.style;
                        matrixContainer.appendChild(div);
                    });
                    
                    matrixPanel.appendChild(matrixContainer);
                    topSection.appendChild(matrixPanel);
                    
                    // 2. Panel de M√©tricas (SOLUCI√ìN AQU√ç)
                    const metricsPanel = document.createElement('div');
                    metricsPanel.style.cssText = `
                        flex: 0.6;
                        background: white;
                        border-radius: 10px;
                        padding: 10px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        display: flex;
                        flex-direction: column;
                        justify-content: space-between; /* Distribuye espacio verticalmente */
                        gap: 8px;
                        overflow: hidden; /* Elimina scroll */
                    `;
                    
                    // C√°lculos m√©tricas
                    const acc = (tp + tn) / total;
                    const sens = tp / (realPos || 1);
                    const spec = tn / (realNeg || 1);
                    const prec = tp / ((tp + fp) || 1);
                    
                    // Funci√≥n auxiliar con flex: 1 para que las cajas crezcan/encoja
                    const createMetric = (label, val, color) => `
                        <div style="
                            background:${color}15; 
                            border-left:4px solid ${color}; 
                            padding: 5px 10px; 
                            border-radius:4px;
                            flex: 1; /* CLAVE: Ocupa espacio disponible */
                            display: flex;
                            flex-direction: column;
                            justify-content: center;
                        ">
                            <div style="font-size:0.75rem; color:#666;">${label}</div>
                            <div style="font-size:1.1rem; font-weight:bold; color:${color};">${val.toFixed(3)}</div>
                        </div>
                    `;
                    
                    // Eliminamos t√≠tulo interno para ganar espacio, o lo hacemos muy peque√±o
                    metricsPanel.innerHTML = `
                        ${createMetric('Accuracy', acc, '#4CAF50')}
                        ${createMetric('Sensitivity (Recall)', sens, '#2196F3')}
                        ${createMetric('Specificity', spec, '#FF9800')}
                        ${createMetric('Precision', prec, '#9C27B0')}
                    `;
                    
                    topSection.appendChild(metricsPanel);
                    container.appendChild(topSection);
                    
                    // --- SECCI√ìN INFERIOR: CURVA ROC ---
                    const rocSection = document.createElement('div');
                    rocSection.style.cssText = `
                        flex: 1;
                        background: white;
                        border-radius: 10px;
                        padding: 10px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        position: relative;
                        min-height: 0;
                        display: flex;
                        flex-direction: column;
                    `;
                    
                    const rocTitle = document.createElement('div');
                    rocTitle.innerHTML = `<b style="color:#333; font-size:0.9rem;">Curva ROC (Umbral: ${threshold.toFixed(2)})</b>`;
                    rocTitle.style.cssText = 'margin-bottom: 5px; text-align: center; height: 20px;';
                    rocSection.appendChild(rocTitle);
                    
                    // Contenedor SVG
                    const svgContainer = document.createElement('div');
                    svgContainer.style.cssText = "flex: 1; width: 100%; position: relative; overflow: hidden;";
                    
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', '100%');
                    svg.setAttribute('viewBox', '0 0 100 100'); 
                    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                    
                    // Ejes
                    const axisGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    axisGroup.innerHTML = `
                        <line x1="10" y1="90" x2="95" y2="90" stroke="#333" stroke-width="0.5" />
                        <line x1="10" y1="10" x2="10" y2="90" stroke="#333" stroke-width="0.5" />
                        <line x1="10" y1="90" x2="95" y2="5" stroke="#999" stroke-width="0.5" stroke-dasharray="2,2" />
                        <text x="50" y="98" font-size="3" text-anchor="middle" fill="#666">1 - Specificity (FPR)</text>
                        <text x="5" y="50" font-size="3" text-anchor="middle" fill="#666" transform="rotate(-90 5,50)">Sensitivity (TPR)</text>
                    `;
                    svg.appendChild(axisGroup);
                    
                    // Curva ROC
                    const rocPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let pathD = 'M 10 90 '; 
                    const curvature = 0.85 + (threshold - 0.5) * 0.1;
                    for(let i=0; i<=20; i++) {
                        const x_rel = i/20;
                        const y_rel = 1 - Math.pow(1 - x_rel, 1/curvature); 
                        const plotX = 10 + (x_rel * 85);
                        const plotY = 90 - (y_rel * 85);
                        pathD += `L ${plotX.toFixed(2)} ${plotY.toFixed(2)} `;
                    }
                    
                    rocPath.setAttribute('d', pathD);
                    rocPath.setAttribute('fill', 'none');
                    rocPath.setAttribute('stroke', '#007acc');
                    rocPath.setAttribute('stroke-width', '1');
                    svg.appendChild(rocPath);
                    
                    // Punto actual
                    const currFPR = 1 - spec;
                    const currTPR = sens;
                    const ptX = 10 + (currFPR * 85);
                    const ptY = 90 - (currTPR * 85);
                    
                    const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    point.setAttribute('cx', ptX);
                    point.setAttribute('cy', ptY);
                    point.setAttribute('r', '2');
                    point.setAttribute('fill', '#f44336');
                    point.setAttribute('stroke', 'white');
                    point.setAttribute('stroke-width', '0.5');
                    svg.appendChild(point);
                    
                    // L√≠neas gu√≠a
                    const guideLines = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    guideLines.setAttribute('d', `M 10 ${ptY} L ${ptX} ${ptY} L ${ptX} 90`);
                    guideLines.setAttribute('stroke', '#f44336');
                    guideLines.setAttribute('stroke-width', '0.3');
                    guideLines.setAttribute('stroke-dasharray', '1,1');
                    guideLines.setAttribute('fill', 'none');
                    svg.appendChild(guideLines);
                    
                    svgContainer.appendChild(svg);
                    rocSection.appendChild(svgContainer);
                    container.appendChild(rocSection);
                    
                    div.appendChild(container);
                                }
            },
            {
                id: 9,
                title: "Tema 9. Deep Learning I",
                desc: "Arquitectura de Red",
                icon: "fa-network-wired",
                controls: [
                    {id: 'layers', type: 'range', label: 'Capas Ocultas', min: 0, max: 3, val: 1},
                    {id: 'act', type: 'select', label: 'Activaci√≥n', options: ['relu', 'sigmoid', 'tanh']},
                    {id: 'neurons', type: 'range', label: 'Neuronas por capa', min: 4, max: 32, val: 8}
                ],
                code: (p) => `
<span class="c-com"># TEMA 9: REDES NEURONALES - ARQUITECTURA</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(keras)
<span class="c-kwd">library</span>(tensorflow)
<span class="c-kwd">library</span>(ggplot2)

<span class="c-com"># 1. Configurar backend de TensorFlow</span>
<span class="c-fn">use_session_with_seed</span>(123)

<span class="c-com"># 2. Datos de ejemplo: MNIST (d√≠gitos manuscritos)</span>
mnist <- <span class="c-fn">dataset_mnist</span>()
x_train <- mnist<span class="c-var">$train</span><span class="c-var">$x</span>
y_train <- mnist<span class="c-var">$train</span><span class="c-var">$y</span>
x_test  <- mnist<span class="c-var">$test</span><span class="c-var">$x</span>
y_test  <- mnist<span class="c-var">$test</span><span class="c-var">$y</span>

<span class="c-com"># 3. Preprocesamiento</span>
<span class="c-com"># Redimensionar y normalizar</span>
x_train <- <span class="c-fn">array_reshape</span>(x_train, <span class="c-fn">c</span>(<span class="c-fn">nrow</span>(x_train), 784)) / 255
x_test  <- <span class="c-fn">array_reshape</span>(x_test, <span class="c-fn">c</span>(<span class="c-fn">nrow</span>(x_test), 784)) / 255

<span class="c-com"># Convertir etiquetas a one-hot encoding</span>
y_train <- <span class="c-fn">to_categorical</span>(y_train, 10)
y_test  <- <span class="c-fn">to_categorical</span>(y_test, 10)

<span class="c-com"># 4. Configurar arquitectura de la red</span>
n_layers <- <span class="c-num">${p.layers}</span>
activation <- <span class="c-str">"${p.act}"</span>
n_neurons <- <span class="c-num">${p.neurons}</span>

model <- <span class="c-fn">keras_model_sequential</span>()

<span class="c-com"># Capa de entrada</span>
model %>% 
  <span class="c-fn">layer_dense</span>(
    <span class="c-arg">units</span> = n_neurons,
    <span class="c-arg">activation</span> = activation,
    <span class="c-arg">input_shape</span> = <span class="c-fn">c</span>(784)
  )

<span class="c-com"># Capas ocultas adicionales</span>
<span class="c-kwd">if</span> (n_layers >= 1) {
  model %>% <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span> = n_neurons, <span class="c-arg">activation</span> = activation)
}

<span class="c-kwd">if</span> (n_layers >= 2) {
  model %>% <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span> = n_neurons, <span class="c-arg">activation</span> = activation)
}

<span class="c-kwd">if</span> (n_layers >= 3) {
  model %>% <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span> = n_neurons, <span class="c-arg">activation</span> = activation)
}

<span class="c-com"># Capa de salida (10 clases para d√≠gitos 0-9)</span>
model %>% 
  <span class="c-fn">layer_dense</span>(
    <span class="c-arg">units</span> = 10,
    <span class="c-arg">activation</span> = <span class="c-str">"softmax"</span>
  )

<span class="c-com"># 5. Compilar modelo</span>
model %>% <span class="c-fn">compile</span>(
  <span class="c-arg">loss</span> = <span class="c-str">"categorical_crossentropy"</span>,
  <span class="c-arg">optimizer</span> = <span class="c-fn">optimizer_adam</span>(<span class="c-arg">lr</span> = 0.001),
  <span class="c-arg">metrics</span> = <span class="c-str">"accuracy"</span>
)

<span class="c-com"># 6. Resumen de la arquitectura</span>
<span class="c-fn">summary</span>(model)

<span class="c-com"># 7. Entrenamiento (solo unas pocas √©pocas para demo)</span>
history <- model %>% <span class="c-fn">fit</span>(
  x_train, y_train,
  <span class="c-arg">epochs</span> = 5,
  <span class="c-arg">batch_size</span> = 128,
  <span class="c-arg">validation_split</span> = 0.2,
  <span class="c-arg">verbose</span> = 1
)

<span class="c-com"># 8. Evaluaci√≥n</span>
evaluation <- model %>% <span class="c-fn">evaluate</span>(x_test, y_test, <span class="c-arg">verbose</span> = 0)
<span class="c-fn">cat</span>(<span class="c-str">"\\n=== EVALUACI√ìN ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Test loss:"</span>, <span class="c-fn">round</span>(evaluation[1], 4), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Test accuracy:"</span>, <span class="c-fn">round</span>(evaluation[2], 4), <span class="c-str">"\\n"</span>)`,
                explain: (p) => {
                    return `
                        <div class="exp-highlight">
                            <b>üß† Redes Neuronales Artificiales (ANN)</b>
                        </div>
                        
                        <p><b>Concepto:</b> Modelos computacionales inspirados en el cerebro biol√≥gico, compuestos por neuronas artificiales interconectadas.</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Arquitectura configurada:</b><br>
                            ‚Ä¢ <b>Capas ocultas: ${p.layers}</b><br>
                            ‚Ä¢ <b>Activaci√≥n: ${p.act}</b><br>
                            ‚Ä¢ <b>Neuronas por capa: ${p.neurons}</b><br>
                            ‚Ä¢ <b>Capa salida: 10 neuronas (softmax)</b>
                        </div>
                        
                        <p><b>Componentes clave:</b></p>
                        <p>1. <b>Neurona artificial:</b> z = w·µÄx + b</p>
                        <p>2. <b>Funci√≥n de activaci√≥n (${p.act}):</b> Introduce no-linealidad</p>
                        <p>3. <b>Forward propagation:</b> Paso hacia adelante</p>
                        <p>4. <b>Backpropagation:</b> Ajuste de pesos mediante gradiente descendente</p>
                        
                        <div class="exp-highlight">
                            <b>‚ö° Funciones de activaci√≥n:</b>
                            <p>‚Ä¢ <b>ReLU:</b> f(x) = max(0, x) ‚Üí M√°s r√°pida, evita vanishing gradient</p>
                            <p>‚Ä¢ <b>Sigmoid:</b> f(x) = 1 / (1 + e‚ÅªÀ£) ‚Üí [0,1], para probabilidades</p>
                            <p>‚Ä¢ <b>Tanh:</b> f(x) = (eÀ£ - e‚ÅªÀ£) / (eÀ£ + e‚ÅªÀ£) ‚Üí [-1,1], centrada en cero</p>
                        </div>
                        
                        <p><b>üìä Proceso de entrenamiento:</b></p>
                        <p>1. <b>Forward pass:</b> Calcular predicci√≥n</p>
                        <p>2. <b>Calcular p√©rdida:</b> categorical_crossentropy</p>
                        <p>3. <b>Backward pass:</b> Calcular gradientes</p>
                        <p>4. <b>Actualizar pesos:</b> optimizer_adam (lr=0.001)</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-exclamation-triangle"></i> <b>Retos comunes:</b>
                            <p>‚Ä¢ <b>Overfitting:</b> Modelo muy complejo para los datos</p>
                            <p>‚Ä¢ <b>Vanishing gradient:</b> Gradientes muy peque√±os en capas profundas</p>
                            <p>‚Ä¢ <b>Selecci√≥n de hiperpar√°metros:</b> Capas, neuronas, learning rate</p>
                        </div>
                        
                        <div class="exp-highlight">
                            <b>üß¨ Aplicaci√≥n en bioinform√°tica:</b>
                            <p>1. <b>Predicci√≥n de estructura de prote√≠nas</b></p>
                            <p>2. <b>Clasificaci√≥n de secuencias gen√≥micas</b></p>
                            <p>3. <b>An√°lisis de im√°genes m√©dicas</b></p>
                            <p>4. <b>Detecci√≥n de variantes gen√©ticas</b></p>
                        </div>`;
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        gap: 15px;
                        padding: 10px;
                    `;
                    
                    // T√≠tulo y Subt√≠tulo
                    const headerDiv = document.createElement('div');
                    headerDiv.style.textAlign = 'center';
                    headerDiv.innerHTML = `
                        <b style="color:#333; font-size:1.1rem;">Arquitectura de Red Neuronal (Auto-Ajustable)</b><br>
                        <span style="color:#666; font-size:0.8rem;">${p.layers} capas ocultas, ${p.neurons} neuronas/capa, activaci√≥n: ${p.act}</span>
                    `;
                    container.appendChild(headerDiv);
                    
                    // --- VISUALIZACI√ìN SVG (SOLUCI√ìN AL SCROLL) ---
                    const svgContainer = document.createElement('div');
                    svgContainer.style.cssText = `
                        width: 100%;
                        max-width: 700px;
                        height: 350px; 
                        background: white;
                        border-radius: 10px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        padding: 10px;
                        display: flex;
                        justify-content: center;
                    `;
                    
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', '100%');
                    // El viewBox crea un sistema de coordenadas fijo (800x400) que se escala autom√°ticamente
                    svg.setAttribute('viewBox', '0 0 800 400'); 
                    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                    
                    // 1. Definir la estructura de capas
                    const layersStruct = [];
                    
                    // Capa Entrada (fija visualmente a 6 neuronas para no saturar, o din√°mica si prefieres)
                    layersStruct.push({ label: 'Entrada', color: '#4CAF50', count: 6, type: 'input' });
                    
                    // Capas Ocultas (basadas en el slider)
                    // Limitamos visualmente a 12 neuronas para que se vea bonito, aunque el par√°metro sea 32
                    const visualNeurons = Math.min(p.neurons, 12); 
                    for(let i=0; i<p.layers; i++) {
                        layersStruct.push({ label: `Oculta ${i+1}`, color: '#2196F3', count: visualNeurons, realCount: p.neurons, type: 'hidden' });
                    }
                    
                    // Capa Salida (fija en 10 para MNIST)
                    layersStruct.push({ label: 'Salida', color: '#f44336', count: 10, type: 'output' });
                    
                    // 2. Calcular coordenadas de todas las neuronas
                    const layerSpacing = 800 / (layersStruct.length); // Espacio horizontal
                    const nodePositions = []; // Guardar√° {x, y, color} de cada neurona
                    
                    layersStruct.forEach((layer, colIndex) => {
                        const x = (colIndex * layerSpacing) + (layerSpacing / 2);
                        const nodes = [];
                        
                        // Calcular espacio vertical din√°mico
                        const totalH = 320; // Altura √∫til dentro del viewBox (dejamos margen para textos)
                        const startY = 40;  // Margen superior
                        const spacingY = totalH / (layer.count + 1);
                        
                        for(let i=0; i<layer.count; i++) {
                            nodes.push({
                                x: x,
                                y: startY + (spacingY * (i + 1)),
                                color: layer.color
                            });
                        }
                        
                        // Guardar informaci√≥n de la capa para dibujar etiquetas
                        layer.x = x;
                        nodePositions.push(nodes);
                    });
                    
                    // 3. Dibujar CONEXIONES (L√≠neas) primero (para que queden al fondo)
                    for(let i=0; i < nodePositions.length - 1; i++) {
                        const currentLayer = nodePositions[i];
                        const nextLayer = nodePositions[i+1];
                        
                        currentLayer.forEach(src => {
                            nextLayer.forEach(dst => {
                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', src.x);
                                line.setAttribute('y1', src.y);
                                line.setAttribute('x2', dst.x);
                                line.setAttribute('y2', dst.y);
                                line.setAttribute('stroke', '#e0e0e0'); // Color gris suave
                                line.setAttribute('stroke-width', '1');
                                svg.appendChild(line);
                            });
                        });
                    }
                    
                    // 4. Dibujar NEURONAS (C√≠rculos) y Etiquetas
                    layersStruct.forEach((layer, colIndex) => {
                        // Etiqueta de la capa (arriba)
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', layer.x);
                        text.setAttribute('y', 25);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('fill', '#333');
                        text.setAttribute('font-size', '14');
                        text.setAttribute('font-weight', 'bold');
                        text.textContent = layer.label;
                        svg.appendChild(text);
                        
                        // Subetiqueta (abajo)
                        const subtext = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        subtext.setAttribute('x', layer.x);
                        subtext.setAttribute('y', 390);
                        subtext.setAttribute('text-anchor', 'middle');
                        subtext.setAttribute('fill', '#666');
                        subtext.setAttribute('font-size', '12');
                        subtext.textContent = layer.type === 'hidden' ? `${layer.realCount} n.` : `${layer.count} n.`;
                        svg.appendChild(subtext);

                        // C√≠rculos
                        const nodes = nodePositions[colIndex];
                        nodes.forEach(node => {
                            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            circle.setAttribute('cx', node.x);
                            circle.setAttribute('cy', node.y);
                            circle.setAttribute('r', 8); // Radio fijo
                            circle.setAttribute('fill', node.color);
                            circle.setAttribute('stroke', 'white');
                            circle.setAttribute('stroke-width', '2');
                            // Sombra simple
                            circle.setAttribute('filter', 'drop-shadow(0px 2px 2px rgba(0,0,0,0.2))');
                            svg.appendChild(circle);
                        });
                        
                        // Si hay m√°s neuronas de las que mostramos visualmente, poner "..."
                        if (layer.type === 'hidden' && layer.realCount > visualNeurons) {
                            const dots = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            dots.setAttribute('x', layer.x);
                            dots.setAttribute('y', 365); // Justo encima de la etiqueta inferior
                            dots.setAttribute('text-anchor', 'middle');
                            dots.setAttribute('fill', '#999');
                            dots.setAttribute('font-size', '20');
                            dots.textContent = '...';
                            svg.appendChild(dots);
                        }
                    });
                    
                    svgContainer.appendChild(svg);
                    container.appendChild(svgContainer);
                    
                    // Panel de Estad√≠sticas (Fijo abajo)
                    const statsPanel = document.createElement('div');
                    statsPanel.style.cssText = `
                        width: 100%;
                        max-width: 700px;
                        display: grid;
                        grid-template-columns: repeat(2, 1fr);
                        gap: 10px;
                    `;
                    
                    const createStat = (label, val, color) => {
                        return `
                            <div style="background:${color}15; border-left:4px solid ${color}; padding:8px; border-radius:4px;">
                                <div style="font-size:0.75rem; color:#666;">${label}</div>
                                <div style="font-size:1rem; font-weight:bold; color:${color};">${val}</div>
                            </div>
                        `;
                    };
                    
                    // C√°lculos aproximados de par√°metros
                    const inputs = 784;
                    const h = p.neurons;
                    const outputs = 10;
                    let params = 0;
                    
                    if (p.layers === 0) params = (inputs * outputs) + outputs;
                    else {
                        // Input -> H1
                        params += (inputs * h) + h;
                        // H -> H
                        for(let i=0; i<p.layers-1; i++) params += (h * h) + h;
                        // H -> Output
                        params += (h * outputs) + outputs;
                    }
                    
                    statsPanel.innerHTML = 
                        createStat('Capas Totales', p.layers + 2, '#4CAF50') +
                        createStat('Neuronas Totales', (p.layers * p.neurons) + 794, '#2196F3') +
                        createStat('Par√°metros Aprox.', params.toLocaleString(), '#FF9800') +
                        createStat('Funci√≥n Activaci√≥n', p.act, '#9C27B0');
                        
                    container.appendChild(statsPanel);
                    div.appendChild(container);
                                }
            },
            {
                id: 10,
                title: "Tema 10. Deep Learning II",
                desc: "CNN & Optimizaci√≥n",
                icon: "fa-filter",
                controls: [
                    {id: 'filters', type: 'range', label: 'N√∫mero de Filtros', min: 8, max: 64, val: 32},
                    {id: 'pooling', type: 'select', label: 'Tipo de Pooling', options: ['Max Pooling', 'Average Pooling']},
                    {id: 'dropout', type: 'range', label: 'Dropout Rate', min: 0, max: 50, val: 20}
                ],
                code: (p) => `
<span class="c-com"># TEMA 10: REDES NEURONALES CONVOLUCIONALES (CNN)</span>
<span class="c-com"># ================================================</span>

<span class="c-kwd">library</span>(keras)
<span class="c-kwd">library</span>(tensorflow)

<span class="c-com"># 1. Cargar datos CIFAR-10 (im√°genes 32x32 a color)</span>
cifar10 <- <span class="c-fn">dataset_cifar10</span>()
x_train <- cifar10<span class="c-var">$train</span><span class="c-var">$x</span>
y_train <- cifar10<span class="c-var">$train</span><span class="c-var">$y</span>
x_test  <- cifar10<span class="c-var">$test</span><span class="c-var">$x</span>
y_test  <- cifar10<span class="c-var">$test</span><span class="c-var">$y</span>

<span class="c-com"># 2. Normalizar im√°genes (0-1)</span>
x_train <- x_train / 255
x_test  <- x_test / 255

<span class="c-com"># 3. One-hot encoding para las etiquetas</span>
y_train <- <span class="c-fn">to_categorical</span>(y_train, 10)
y_test  <- <span class="c-fn">to_categorical</span>(y_test, 10)

<span class="c-com"># 4. Definir arquitectura CNN</span>
model <- <span class="c-fn">keras_model_sequential</span>() %>%
  
  <span class="c-com"># Capa convolucional 1</span>
  <span class="c-fn">layer_conv_2d</span>(
    <span class="c-arg">filters</span> = ${p.filters},
    <span class="c-arg">kernel_size</span> = <span class="c-fn">c</span>(3, 3),
    <span class="c-arg">activation</span> = <span class="c-str">"relu"</span>,
    <span class="c-arg">input_shape</span> = <span class="c-fn">c</span>(32, 32, 3),
    <span class="c-arg">padding</span> = <span class="c-str">"same"</span>
  ) %>%
  <span class="c-fn">layer_batch_normalization</span>() %>%
  
  <span class="c-com"># Capa de pooling</span>
  ${p.pooling === 'Max Pooling' ? 
    'layer_max_pooling_2d(pool_size = c(2, 2))' :
    'layer_average_pooling_2d(pool_size = c(2, 2))'
  } %>%
  
  <span class="c-com"># Capa convolucional 2</span>
  <span class="c-fn">layer_conv_2d</span>(
    <span class="c-arg">filters</span> = ${p.filters * 2},
    <span class="c-arg">kernel_size</span> = <span class="c-fn">c</span>(3, 3),
    <span class="c-arg">activation</span> = <span class="c-str">"relu"</span>,
    <span class="c-arg">padding</span> = <span class="c-str">"same"</span>
  ) %>%
  <span class="c-fn">layer_batch_normalization</span>() %>%
  
  <span class="c-com"># Capa de pooling</span>
  ${p.pooling === 'Max Pooling' ? 
    'layer_max_pooling_2d(pool_size = c(2, 2))' :
    'layer_average_pooling_2d(pool_size = c(2, 2))'
  } %>%
  
  <span class="c-com"># Regularizaci√≥n con Dropout</span>
  <span class="c-fn">layer_dropout</span>(<span class="c-arg">rate</span> = <span class="c-num">${p.dropout / 100}</span>) %>%
  
  <span class="c-com"># Aplanar para capas densas</span>
  <span class="c-fn">layer_flatten</span>() %>%
  
  <span class="c-com"># Capa densa completamente conectada</span>
  <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span> = 128, <span class="c-arg">activation</span> = <span class="c-str">"relu"</span>) %>%
  <span class="c-fn">layer_batch_normalization</span>() %>%
  <span class="c-fn">layer_dropout</span>(<span class="c-arg">rate</span> = <span class="c-num">${p.dropout / 100}</span>) %>%
  
  <span class="c-com"># Capa de salida</span>
  <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span> = 10, <span class="c-arg">activation</span> = <span class="c-str">"softmax"</span>)

<span class="c-com"># 5. Compilar modelo</span>
model %>% <span class="c-fn">compile</span>(
  <span class="c-arg">loss</span> = <span class="c-str">"categorical_crossentropy"</span>,
  <span class="c-arg">optimizer</span> = <span class="c-fn">optimizer_adam</span>(<span class="c-arg">lr</span> = 0.001),
  <span class="c-arg">metrics</span> = <span class="c-str">"accuracy"</span>
)

<span class="c-com"># 6. Resumen de la arquitectura</span>
<span class="c-fn">summary</span>(model)

<span class="c-com"># 7. Callbacks para mejor entrenamiento</span>
callbacks <- <span class="c-fn">list</span>(
  <span class="c-fn">callback_early_stopping</span>(
    <span class="c-arg">monitor</span> = <span class="c-str">"val_loss"</span>,
    <span class="c-arg">patience</span> = 5,
    <span class="c-arg">restore_best_weights</span> = TRUE
  ),
  <span class="c-fn">callback_reduce_lr_on_plateau</span>(
    <span class="c-arg">monitor</span> = <span class="c-str">"val_loss"</span>,
    <span class="c-arg">factor</span> = 0.5,
    <span class="c-arg">patience</span> = 3
  )
)

<span class="c-com"># 8. Entrenamiento (√©pocas reducidas para demo)</span>
history <- model %>% <span class="c-fn">fit</span>(
  x_train, y_train,
  <span class="c-arg">epochs</span> = 10,
  <span class="c-arg">batch_size</span> = 64,
  <span class="c-arg">validation_split</span> = 0.2,
  <span class="c-arg">callbacks</span> = callbacks,
  <span class="c-arg">verbose</span> = 1
)

<span class="c-com"># 9. Evaluaci√≥n</span>
evaluation <- model %>% <span class="c-fn">evaluate</span>(x_test, y_test, <span class="c-arg">verbose</span> = 0)
<span class="c-fn">cat</span>(<span class="c-str">"\\n=== EVALUACI√ìN CNN ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Test loss:"</span>, <span class="c-fn">round</span>(evaluation[1], 4), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Test accuracy:"</span>, <span class="c-fn">round</span>(evaluation[2], 4), <span class="c-str">"\\n"</span>)

<span class="c-com"># 10. Visualizar caracter√≠sticas aprendidas</span>
<span class="c-kwd">library</span>(ggplot2)
<span class="c-kwd">library</span>(tidyr)

<span class="c-com"># Extraer historia de entrenamiento</span>
history_df <- <span class="c-fn">as.data.frame</span>(history)
history_long <- <span class="c-fn">gather</span>(history_df, key = <span class="c-str">"metric"</span>, value = <span class="c-str">"value"</span>, -epoch)

ggplot(history_long, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = epoch, <span class="c-arg">y</span> = value, <span class="c-arg">color</span> = metric)) +
  <span class="c-fn">geom_line</span>(<span class="c-arg">lwd</span> = 1) +
  <span class="c-fn">facet_wrap</span>(~metric, <span class="c-arg">scales</span> = <span class="c-str">"free_y"</span>, <span class="c-arg">ncol</span> = 2) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">labs</span>(
    <span class="c-arg">title</span> = <span class="c-str">"Curvas de Aprendizaje de la CNN"</span>,
    <span class="c-arg">x</span> = <span class="c-str">"√âpoca"</span>,
    <span class="c-arg">y</span> = <span class="c-str">"Valor"</span>
  )`,
                explain: (p) => {
                    return `
                        <div class="exp-highlight">
                            <b>üîç Redes Neuronales Convolucionales (CNN)</b>
                        </div>
                        
                        <p><b>Concepto:</b> Redes especializadas en procesamiento de datos con estructura de grid (im√°genes, se√±ales, secuencias).</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Configuraci√≥n actual:</b><br>
                            ‚Ä¢ <b>Filtros: ${p.filters} ‚Üí ${p.filters * 2}</b><br>
                            ‚Ä¢ <b>Pooling: ${p.pooling}</b><br>
                            ‚Ä¢ <b>Dropout: ${p.dropout}%</b><br>
                            ‚Ä¢ <b>Kernel: 3√ó3</b>
                        </div>
                        
                        <p><b>Operaciones fundamentales:</b></p>
                        <p>1. <b>Convoluci√≥n:</b> Aplicar filtros para extraer caracter√≠sticas locales</p>
                        <p>2. <b>Pooling (${p.pooling}):</b> Reducir dimensionalidad preservando caracter√≠sticas importantes</p>
                        <p>3. <b>Dropout (${p.dropout}%):</b> Regularizaci√≥n para prevenir overfitting</p>
                        
                        <div class="exp-highlight">
                            <b>üéØ Ventajas de las CNN:</b>
                            <p>‚Ä¢ üõ°Ô∏è <b>Invarianza a traslaciones</b></p>
                            <p>‚Ä¢ üîÑ <b>Weight sharing</b> (menos par√°metros que redes densas)</p>
                            <p>‚Ä¢ üìä <b>Jerarqu√≠a de caracter√≠sticas</b> (bordes ‚Üí texturas ‚Üí objetos)</p>
                            <p>‚Ä¢ ‚ö° <b>Eficiencia computacional</b> para datos estructurados</p>
                        </div>
                        
                        <p><b>üìà T√©cnicas de optimizaci√≥n implementadas:</b></p>
                        <p>1. <b>Batch Normalization:</b> Normaliza activaciones para acelerar entrenamiento</p>
                        <p>2. <b>Early Stopping:</b> Detiene entrenamiento cuando no hay mejora en val_loss</p>
                        <p>3. <b>ReduceLROnPlateau:</b> Reduce learning rate cuando el modelo se estanca</p>
                        <p>4. <b>Dropout:</b> Apaga aleatoriamente neuronas durante entrenamiento</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-lightbulb"></i> <b>Elecci√≥n de hiperpar√°metros:</b>
                            <p>‚Ä¢ <b>Filtros (${p.filters}):</b> M√°s filtros = m√°s capacidad, riesgo de overfitting</p>
                            <p>‚Ä¢ <b>Dropout (${p.dropout}%):</b> Alto = m√°s regularizaci√≥n, bajo = riesgo de overfitting</p>
                            <p>‚Ä¢ <b>Pooling (${p.pooling}):</b> Max preserva caracter√≠sticas destacadas, Average suaviza</p>
                        </div>
                        
                        <div class="exp-highlight">
                            <b>üß¨ Aplicaciones en biomedicina:</b>
                            <p>1. <b>Diagn√≥stico por imagen:</b> Detecci√≥n de tumores en radiograf√≠as</p>
                            <p>2. <b>An√°lisis de histolog√≠a:</b> Clasificaci√≥n de tejidos</p>
                            <p>3. <b>Secuenciaci√≥n:</b> An√°lisis de secuencias de ADN/RNA</p>
                            <p>4. <b>Microscop√≠a:</b> Segmentaci√≥n de c√©lulas</p>
                        </div>`;
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        flex-direction: column;
                        gap: 15px;
                        padding: 10px;
                        overflow: hidden;
                    `;
                    
                    // T√≠tulo
                    const header = document.createElement('div');
                    header.innerHTML = `
                        <b style="color:#333; font-size:1.1rem;">Red Neuronal Convolucional (CNN)</b><br>
                        <span style="color:#666; font-size:0.8rem;">${p.filters} filtros, ${p.pooling}, Dropout: ${p.dropout}%</span>
                    `;
                    header.style.textAlign = 'center';
                    header.style.flexShrink = '0';
                    container.appendChild(header);
                    
                    // --- 1. VISUALIZACI√ìN CNN (Igual que antes, funciona bien) ---
                    const vizPanel = document.createElement('div');
                    vizPanel.style.cssText = `
                        flex: 1.2;
                        width: 100%;
                        background: white;
                        border-radius: 10px;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        padding: 10px;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        min-height: 0;
                    `;
                    
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', '100%');
                    svg.setAttribute('viewBox', '0 0 800 150'); 
                    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                    
                    const stages = [
                        { label: 'Input', sub: '32x32', color: '#4CAF50' },
                        { label: 'Conv1', sub: `${p.filters}f`, color: '#2196F3' },
                        { label: 'Pool1', sub: '2x2', color: '#FF9800' },
                        { label: 'Conv2', sub: `${p.filters*2}f`, color: '#2196F3' },
                        { label: 'Pool2', sub: '2x2', color: '#FF9800' },
                        { label: 'Drop', sub: `${p.dropout}%`, color: '#9C27B0' },
                        { label: 'Dense', sub: '128', color: '#00BCD4' },
                        { label: 'Out', sub: '10', color: '#f44336' }
                    ];
                    
                    const startX = 50;
                    const gap = 90;
                    const boxW = 60;
                    const boxH = 60;
                    const yPos = 45;
                    
                    stages.forEach((st, i) => {
                        const x = startX + i * gap;
                        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', x);
                        rect.setAttribute('y', yPos);
                        rect.setAttribute('width', boxW);
                        rect.setAttribute('height', boxH);
                        rect.setAttribute('rx', 8);
                        rect.setAttribute('fill', st.color);
                        
                        const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text1.setAttribute('x', x + boxW/2);
                        text1.setAttribute('y', yPos + boxH/2 - 5);
                        text1.setAttribute('text-anchor', 'middle');
                        text1.setAttribute('fill', 'white');
                        text1.setAttribute('font-size', '12');
                        text1.setAttribute('font-weight', 'bold');
                        text1.textContent = st.label;
                        
                        const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text2.setAttribute('x', x + boxW/2);
                        text2.setAttribute('y', yPos + boxH/2 + 12);
                        text2.setAttribute('text-anchor', 'middle');
                        text2.setAttribute('fill', 'rgba(255,255,255,0.9)');
                        text2.setAttribute('font-size', '10');
                        text2.textContent = st.sub;
                        
                        g.appendChild(rect);
                        g.appendChild(text1);
                        g.appendChild(text2);
                        svg.appendChild(g);
                        
                        if (i < stages.length - 1) {
                            const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            const ax = x + boxW + 5;
                            const ay = yPos + boxH/2;
                            arrow.setAttribute('d', `M ${ax} ${ay} L ${ax + gap - boxW - 10} ${ay}`);
                            arrow.setAttribute('stroke', '#bbb');
                            arrow.setAttribute('stroke-width', '2');
                            
                            const tri = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                            const tx = ax + gap - boxW - 10;
                            tri.setAttribute('points', `${tx},${ay-4} ${tx},${ay+4} ${tx+5},${ay}`);
                            tri.setAttribute('fill', '#bbb');
                            
                            svg.appendChild(arrow);
                            svg.appendChild(tri);
                        }
                    });
                    
                    vizPanel.appendChild(svg);
                    container.appendChild(vizPanel);
                    
                    // --- 2. PANEL INFERIOR ---
                    const bottomPanel = document.createElement('div');
                    bottomPanel.style.cssText = `
                        flex: 1;
                        width: 100%;
                        display: flex;
                        gap: 15px;
                        min-height: 0;
                    `;
                    
                    // Panel Izquierdo: Filtros
                    const filtersDiv = document.createElement('div');
                    filtersDiv.style.cssText = `
                        flex: 1;
                        background: white;
                        border-radius: 10px;
                        padding: 10px;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                    `;
                    filtersDiv.innerHTML = `<b style="font-size:0.8rem; margin-bottom:5px; color:#333;">Filtros (${p.filters})</b>`;
                    
                    const filtersGrid = document.createElement('div');
                    filtersGrid.style.cssText = 'display: flex; gap: 5px; flex-wrap: wrap; justify-content: center;';
                    for(let i=0; i<8; i++) {
                        const f = document.createElement('div');
                        f.style.cssText = `
                            width: 30px; height: 30px; 
                            background: linear-gradient(${Math.random()*360}deg, #2196F3, #0D47A1);
                            border-radius: 4px;
                        `;
                        filtersGrid.appendChild(f);
                    }
                    filtersDiv.appendChild(filtersGrid);
                    filtersDiv.innerHTML += `<div style="font-size:0.7rem; color:#666; margin-top:5px; text-align:center;">Detectan bordes y texturas</div>`;
                    
                    // --- AQU√ç EST√Å LA MEJORA VISUAL ---
                    // Panel Derecho: Gr√°fica de Aprendizaje COMPLETA
                    const graphDiv = document.createElement('div');
                    graphDiv.style.cssText = `
                        flex: 2;
                        background: #f8f9fa;
                        border-radius: 10px;
                        padding: 10px;
                        position: relative;
                        display: flex;
                        flex-direction: column;
                    `;
                    graphDiv.innerHTML = `<b style="font-size:0.8rem; text-align:center; margin-bottom:5px;">Curva de Aprendizaje (Accuracy)</b>`;
                    
                    const graphSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    graphSvg.setAttribute('width', '100%');
                    graphSvg.setAttribute('height', '100%');
                    graphSvg.setAttribute('viewBox', '0 0 200 100'); // M√°s resoluci√≥n
                    graphSvg.setAttribute('preserveAspectRatio', 'none');
                    
                    // Ejes y Grid
                    const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    gridGroup.innerHTML = `
                        <line x1="20" y1="20" x2="190" y2="20" stroke="#e0e0e0" stroke-width="1" />
                        <line x1="20" y1="50" x2="190" y2="50" stroke="#e0e0e0" stroke-width="1" />
                        <line x1="20" y1="80" x2="190" y2="80" stroke="#333" stroke-width="1" /> <line x1="20" y1="10" x2="20" y2="80" stroke="#333" stroke-width="1" /> <text x="10" y="85" font-size="8" fill="#666">0</text>
                        <text x="10" y="20" font-size="8" fill="#666">1</text>
                        <text x="190" y="95" font-size="8" fill="#666" text-anchor="end">√âpocas</text>
                    `;
                    graphSvg.appendChild(gridGroup);
                    
                    // 1. Curva de Entrenamiento (Verde - Suave y alta)
                    let dTrain = 'M 20 80 ';
                    for(let i=0; i<=170; i+=10) {
                        // Logar√≠tmica inversa para simular aprendizaje r√°pido al inicio
                        const progress = i / 170;
                        const y = 80 - (Math.sqrt(progress) * 60) - (Math.random() * 2);
                        dTrain += `L ${20 + i} ${y} `;
                    }
                    const pathTrain = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathTrain.setAttribute('d', dTrain);
                    pathTrain.setAttribute('fill', 'none');
                    pathTrain.setAttribute('stroke', '#4CAF50');
                    pathTrain.setAttribute('stroke-width', '2');
                    graphSvg.appendChild(pathTrain);

                    // 2. Curva de Validaci√≥n (Azul - Un poco m√°s baja y ruidosa)
                    let dVal = 'M 20 80 ';
                    for(let i=0; i<=170; i+=10) {
                        const progress = i / 170;
                        // Sube menos y tiene m√°s ruido (simula overfitting leve si dropout es bajo)
                        const gap = (50 - p.dropout) / 10; // Si dropout es bajo, hay m√°s gap (overfitting)
                        const y = 80 - (Math.sqrt(progress) * (55 - gap)) + (Math.random() * 3);
                        dVal += `L ${20 + i} ${y} `;
                    }
                    const pathVal = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathVal.setAttribute('d', dVal);
                    pathVal.setAttribute('fill', 'none');
                    pathVal.setAttribute('stroke', '#2196F3');
                    pathVal.setAttribute('stroke-width', '2');
                    pathVal.setAttribute('stroke-dasharray', '4,2'); // L√≠nea punteada para distinguir
                    graphSvg.appendChild(pathVal);
                    
                    graphDiv.appendChild(graphSvg);
                    
                    // Leyenda de la Gr√°fica
                    const legendDiv = document.createElement('div');
                    legendDiv.style.cssText = `
                        display: flex; 
                        justify-content: center; 
                        gap: 15px; 
                        font-size: 0.7rem; 
                        margin-top: -5px;
                    `;
                    legendDiv.innerHTML = `
                        <div style="display:flex; align-items:center; gap:4px;">
                            <div style="width:10px; height:2px; background:#4CAF50;"></div> Train
                        </div>
                        <div style="display:flex; align-items:center; gap:4px;">
                            <div style="width:10px; height:2px; background:#2196F3; border-top: 1px dashed white;"></div> Val
                        </div>
                    `;
                    graphDiv.appendChild(legendDiv);
                    
                    bottomPanel.appendChild(filtersDiv);
                    bottomPanel.appendChild(graphDiv);
                    container.appendChild(bottomPanel);
                    
                    div.appendChild(container);
                         }
            }
        ];

       // ==========================================
        //      L√ìGICA DEL SISTEMA (CORREGIDA)
        // ==========================================

        // Variable global para guardar el estado de los controles de cada lecci√≥n
        // Formato: { 1: {method: 'raw', outlier: false}, 2: {algo: 'PCA'...} }
        const appState = {}; 
        let currentLessonId = 1;

        function initApp() {
            renderMenu();
            loadLesson(1); // Cargar tema 1 al inicio
        }

        function renderMenu() {
            const menuDiv = document.getElementById('menuList');
            menuDiv.innerHTML = '';
            lessons.forEach(lesson => {
                const item = document.createElement('a');
                item.className = `menu-item ${lesson.id === currentLessonId ? 'active' : ''}`;
                item.href = 'javascript:void(0)';
                item.innerHTML = `
                    <div class="menu-icon"><i class="fas ${lesson.icon}"></i></div>
                    <div class="menu-text">
                        <h4>${lesson.title}</h4>
                        <p>${lesson.desc}</p>
                    </div>
                `;
                item.onclick = () => loadLesson(lesson.id);
                menuDiv.appendChild(item);
            });
        }

        function loadLesson(id) {
            currentLessonId = id;
            const lesson = lessons.find(l => l.id === id);
            
            // 1. Inicializar el estado de este tema si es la primera vez que entramos
            if (!appState[id]) {
                appState[id] = {};
                lesson.controls.forEach(c => {
                    // Guardar valores por defecto en el estado global
                    if (c.type === 'select') appState[id][c.id] = c.value || c.options[0];
                    else if (c.type === 'checkbox') appState[id][c.id] = c.value || false;
                    else appState[id][c.id] = c.val || c.value || 0;
                });
            }

            // 2. Actualizar men√∫ visualmente
            renderMenu();

            // 3. Construir los controles en el DOM (Solo se hace al cambiar de tema)
            renderControls(lesson);

            // 4. Pintar el contenido (Gr√°fica, C√≥digo, Texto)
            updateContent(lesson);
        }

        function renderControls(lesson) {
            const controlsDiv = document.getElementById('controlsArea');
            controlsDiv.innerHTML = ''; // Limpiar controles del tema anterior

            lesson.controls.forEach(ctrl => {
                const group = document.createElement('div');
                group.className = 'control-group';

                const label = document.createElement('span');
                label.className = 'control-label';
                label.textContent = ctrl.label;
                group.appendChild(label);

                let input;
                // Obtener valor actual del estado global
                const currentValue = appState[lesson.id][ctrl.id];

                if (ctrl.type === 'select') {
                    input = document.createElement('select');
                    ctrl.options.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt;
                        option.textContent = opt;
                        input.appendChild(option);
                    });
                    input.value = currentValue;
                    
                    input.onchange = (e) => {
                        appState[lesson.id][ctrl.id] = e.target.value;
                        updateContent(lesson);
                    };

                } else if (ctrl.type === 'range') {
                    input = document.createElement('input');
                    input.type = 'range';
                    input.min = ctrl.min;
                    input.max = ctrl.max;
                    input.step = ctrl.step || 1;
                    input.value = currentValue;

                    const valDisplay = document.createElement('span');
                    valDisplay.style.cssText = "font-size:0.8rem; font-weight:bold; margin-left:5px; min-width:30px;";
                    valDisplay.textContent = currentValue;

                    input.oninput = (e) => {
                        // Actualizar n√∫mero y estado
                        valDisplay.textContent = e.target.value;
                        appState[lesson.id][ctrl.id] = Number(e.target.value);
                        // Renderizar gr√°fica en tiempo real
                        updateContent(lesson);
                    };

                    group.appendChild(input);
                    group.appendChild(valDisplay);
                    controlsDiv.appendChild(group);
                    return; // Salir para no a√±adir el input dos veces

                } else if (ctrl.type === 'checkbox') {
                    input = document.createElement('input');
                    input.type = 'checkbox';
                    input.checked = currentValue;
                    
                    input.onchange = (e) => {
                        appState[lesson.id][ctrl.id] = e.target.checked;
                        updateContent(lesson);
                    };
                }

                if (input) group.appendChild(input);
                controlsDiv.appendChild(group);
            });
        }

        function updateContent(lesson) {
            // Recuperar par√°metros del estado
            const params = appState[lesson.id];

            // 1. Renderizar C√≥digo
            try {
                const codeEditor = document.getElementById('codeEditor');
                codeEditor.innerHTML = lesson.code(params);
            } catch (e) { console.error("Error generando c√≥digo:", e); }

            // 2. Renderizar Explicaci√≥n
            try {
                const explanation = document.getElementById('explanationText');
                explanation.innerHTML = lesson.explain(params);
            } catch (e) { console.error("Error generando explicaci√≥n:", e); }

            // 3. Renderizar Gr√°fica
            try {
                const plotContent = document.getElementById('plotContent');
                plotContent.innerHTML = ''; // Limpiar gr√°fica anterior
                lesson.render(params, plotContent);
            } catch (e) { 
                console.error("Error renderizando gr√°fica:", e);
                document.getElementById('plotContent').innerHTML = `<div style="color:red; padding:20px;">Error visual: ${e.message}</div>`;
            }
        }

        // --- TOOLTIPS ---
        function showTooltip(e) {
            const tooltip = document.getElementById('tooltip');
            if (e.target.dataset.tooltip) {
                tooltip.innerHTML = e.target.dataset.tooltip;
                tooltip.style.opacity = '1';
                tooltip.style.left = (e.pageX + 10) + 'px';
                tooltip.style.top = (e.pageY - 10) + 'px';
            }
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.opacity = '0';
        }

        // --- INICIALIZACI√ìN ---
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
