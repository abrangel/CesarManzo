<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algoritmos e Inteligencia Artificial</title>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        /* --- CONFIGURACI√ìN BASE --- */
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #252526;
            --text-main: #d4d4d4;
            --accent: #007acc;
            --keyword: #c586c0;
            --function: #dcdcaa;
            --string: #ce9178;
            --comment: #6a9955;
            --sidebar-w: 300px;
            --success: #4CAF50;
            --warning: #FF9800;
            --danger: #f44336;
            --info: #2196F3;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body { 
            background: var(--bg-dark); 
            font-family: 'Roboto', sans-serif; 
            color: var(--text-main); 
            height: 100vh; 
            display: flex; 
            overflow: hidden; 
        }

        /* --- SIDEBAR --- */
        .sidebar { 
            width: var(--sidebar-w); 
            background: #2d2d2d; 
            display: flex; 
            flex-direction: column; 
            border-right: 1px solid #000;
            min-width: 250px;
        }
        
        .header { 
            padding: 20px 15px; 
            background: linear-gradient(135deg, #007acc 0%, #005a9e 100%); 
            color: white; 
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .header h2 { 
            margin: 0 0 5px 0; 
            font-size: 1.1rem; 
            font-weight: 700; 
        }
        
        .header span { 
            font-size: 0.8rem; 
            opacity: 0.9; 
            display: block;
        }
        
        .menu { 
            flex: 1; 
            overflow-y: auto; 
            padding: 10px 0;
        }
        
        .menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 15px;
            color: #ccc;
            cursor: pointer;
            border-left: 4px solid transparent;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            transition: all 0.3s ease;
            text-decoration: none;
            position: relative;
            overflow: hidden;
        }
        
        .menu-item:hover { 
            background: rgba(255,255,255,0.05); 
            color: white; 
            padding-left: 18px;
        }
        
        .menu-item.active { 
            background: rgba(0, 122, 204, 0.15); 
            border-left-color: #007acc; 
            color: white; 
            font-weight: 600;
        }
        
        .menu-item.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 3px;
            background: #007acc;
            box-shadow: 0 0 10px #007acc;
        }
        
        .menu-icon {
            font-size: 1rem;
            width: 24px;
            text-align: center;
            color: #007acc;
        }
        
        .menu-item.active .menu-icon {
            color: white;
        }
        
        .menu-text h4 {
            margin: 0 0 4px 0;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .menu-text p {
            margin: 0;
            font-size: 0.75rem;
            color: #aaa;
            line-height: 1.3;
        }

        /* --- √ÅREA PRINCIPAL --- */
        .main { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            height: 100%; 
            overflow: hidden;
        }
        
        /* Contenedor Superior */
        .top-split { 
            flex: 2; 
            display: flex; 
            border-bottom: 1px solid rgba(255,255,255,0.1); 
            overflow: hidden; 
            min-height: 0;
        }
        
        /* Panel C√≥digo */
        .code-panel { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            border-right: 1px solid rgba(255,255,255,0.1); 
            background: #1e1e1e; 
            min-width: 0;
            position: relative;
        }
        
        .panel-title { 
            background: #2d2d2d; 
            padding: 10px 15px; 
            font-size: 0.8rem; 
            text-transform: uppercase; 
            font-weight: 600; 
            color: #bbb; 
            display: flex; 
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .panel-title span:last-child {
            color: var(--success);
            font-weight: 500;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7;
            }
        }
        
        .editor { 
            flex: 1; 
            padding: 20px; 
            font-family: 'Fira Code', monospace; 
            font-size: 0.9rem; 
            overflow: auto; 
            line-height: 1.6; 
            white-space: pre-wrap;
            background: #1e1e1e;
        }
        
        /* Sintaxis mejorada */
        .c-kwd { color: var(--keyword); font-weight: 500; } 
        .c-fn { color: var(--function); } 
        .c-str { color: var(--string); } 
        .c-com { color: var(--comment); font-style: italic; opacity: 0.9; }
        .c-arg { color: #9cdcfe; } 
        .c-num { color: #b5cea8; }
        .c-var { color: #569cd6; }
        .c-op { color: #d4d4d4; }

        /* Panel Gr√°fico */
        .viz-panel { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            background: #fff; 
            color: #333; 
            position: relative; 
            min-width: 0;
        }
        
        .controls { 
            background: #f8f9fa; 
            padding: 12px 15px; 
            border-bottom: 1px solid #dee2e6; 
            display: flex; 
            gap: 15px; 
            flex-wrap: wrap; 
            align-items: center; 
            min-height: 50px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .control-label {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            white-space: nowrap;
            color: #495057;
        }
        
        .canvas { 
            flex: 1; 
            position: relative; 
            overflow: auto; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            background: linear-gradient(45deg, #f8f9fa 25%, #fff 25%, #fff 50%, #f8f9fa 50%, #f8f9fa 75%, #fff 75%, #fff);
            background-size: 20px 20px;
        }
        
        /* --- PANEL EXPLICACI√ìN --- */
        .explanation-panel { 
            flex: 1; 
            background: #252526; 
            border-top: 2px solid #007acc; 
            padding: 20px; 
            overflow-y: auto; 
            font-family: 'Segoe UI', sans-serif; 
            min-height: 0;
        }
        
        .exp-title { 
            color: #007acc; 
            font-weight: 600; 
            font-size: 1.2rem; 
            margin-bottom: 15px; 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .exp-text { 
            line-height: 1.7; 
            color: #e9ecef; 
            font-size: 0.95rem; 
        }
        
        .exp-text b {
            color: #007acc;
            font-weight: 600;
        }
        
        .exp-text i {
            color: #6a9955;
            font-style: italic;
        }
        
        .exp-highlight { 
            background: rgba(0, 122, 204, 0.15); 
            padding: 8px 12px; 
            border-radius: 6px; 
            color: #e9ecef; 
            border-left: 3px solid #007acc;
            margin: 10px 0;
        }
        
        .exp-note {
            background: rgba(255, 152, 0, 0.1);
            padding: 8px 12px;
            border-radius: 6px;
            color: #ffcc80;
            border-left: 3px solid #FF9800;
            margin: 10px 0;
            font-size: 0.9rem;
        }

        /* --- CONTROLES UI MEJORADOS --- */
        select, input[type="range"] { 
            padding: 6px 10px; 
            border: 1px solid #ced4da; 
            border-radius: 4px; 
            font-size: 0.8rem; 
            background: white;
            transition: all 0.2s;
        }
        
        select:focus, input[type="range"]:focus {
            outline: none;
            border-color: #007acc;
            box-shadow: 0 0 0 3px rgba(0,122,204,0.1);
        }
        
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        /* --- GR√ÅFICOS Y ANIMACIONES --- */
        .dot { 
            position: absolute; 
            width: 12px; 
            height: 12px; 
            border-radius: 50%; 
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); 
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            border: 2px solid white;
        }
        
        .cluster-center {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 3px solid #000;
            background: #fff;
            transform: rotate(45deg);
            z-index: 10;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }
        
        .tree-node {
            position: absolute;
            background: white;
            border: 2px solid;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.8rem;
            text-align: center;
            min-width: 80px;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
            z-index: 10;
            transition: all 0.3s;
        }
        
        .tree-node:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .tree-line {
            position: absolute;
            background: #666;
            transform-origin: top left;
        }
        
        .svm-boundary {
            position: absolute;
            border: 2px dashed;
            border-radius: 50%;
            pointer-events: none;
            transition: all 0.5s;
        }
        
        /* Barras (VarImp) */
        .bar-container { 
            width: 90%; 
            display: flex; 
            flex-direction: column; 
            gap: 12px; 
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .bar-row { 
            display: flex; 
            align-items: center; 
            gap: 15px; 
        }
        
        .bar-label { 
            width: 120px; 
            text-align: right; 
            font-size: 0.8rem; 
            font-weight: 600;
            color: #333;
        }
        
        .bar-bg { 
            flex: 1; 
            background: #e9ecef; 
            height: 20px; 
            border-radius: 10px; 
            overflow: hidden; 
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .bar-fill { 
            height: 100%; 
            background: linear-gradient(90deg, #007acc, #00bcd4); 
            width: 0%; 
            transition: width 1s cubic-bezier(0.4, 0, 0.2, 1); 
            border-radius: 10px;
        }
        
        .bar-value {
            width: 40px;
            text-align: center;
            font-size: 0.8rem;
            font-weight: 600;
            color: #333;
        }

        /* PCA 3D */
        .scene-3d {
            width: 300px;
            height: 300px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 1s ease;
            perspective: 1000px;
        }
        
        .axis-3d {
            position: absolute;
            background: #333;
            transform-origin: 0 0;
        }
        
        /* Tooltip */
        .tooltip { 
            position: absolute; 
            background: rgba(0,0,0,0.9); 
            color: white; 
            padding: 8px 12px; 
            border-radius: 6px; 
            font-size: 0.8rem; 
            pointer-events: none; 
            opacity: 0; 
            z-index: 1000; 
            transition: opacity 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            max-width: 200px;
            white-space: nowrap;
        }
        
        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(0,0,0,0.9) transparent transparent transparent;
        }

        /* Scrollbar personalizado */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #2d2d2d;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #666;
        }

        /* Animaciones */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .sidebar {
                width: 250px;
            }
            
            .top-split {
                flex-direction: column;
            }
            
            .code-panel, .viz-panel {
                min-height: 300px;
            }
            
            .code-panel {
                border-right: none;
                border-bottom: 1px solid rgba(255,255,255,0.1);
            }
        }

    </style>
</head>
<body>

    <div class="sidebar">
        <div class="header">
            <h2>M√ÅSTER BIOINFORM√ÅTICA</h2>
            <span>Algoritmos e Inteligencia Artificial</span>
        </div>
        <div class="menu" id="menuList"></div>
    </div>

    <div class="main">
        
        <div class="top-split">
            <div class="code-panel">
                <div class="panel-title">
                    <span><i class="fas fa-file-code"></i> Script R</span>
                    <span><i class="fas fa-circle"></i> LIVE</span>
                </div>
                <div class="editor" id="codeEditor"></div>
            </div>

            <div class="viz-panel">
                <div class="controls" id="controlsArea"></div>
                <div class="canvas" id="canvasArea">
                    <div id="plotContent" style="width:100%; height:100%; position:relative; display:flex; justify-content:center; align-items:center;"></div>
                    <div class="tooltip" id="tooltip"></div>
                </div>
            </div>
        </div>

        <div class="explanation-panel">
            <div class="exp-title"><i class="fas fa-chalkboard-teacher"></i> Explicaci√≥n del Profesor</div>
            <div class="exp-text" id="explanationText"></div>
        </div>

    </div>

    <script>
        // --- BASE DE DATOS DE LOS 10 TEMAS COMPLETOS Y MEJORADOS ---
        const lessons = [
            {
                id: 1,
                title: "Tema 1. Intro & Preprocesamiento",
                desc: "Escalado y Normalizaci√≥n",
                icon: "fa-sliders-h",
                controls: [
                    {id: 'method', type: 'select', label: 'T√©cnica Caret', options: ['raw (Datos Crudos)', 'center (Media=0)', 'scale (SD=1)', 'range (0-1)']},
                    {id: 'outlier', type: 'checkbox', label: 'A√±adir Outliers', value: false}
                ],
                code: (p) => `
<span class="c-com"># TEMA 1: PREPROCESAMIENTO CON CARET</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(caret)
<span class="c-kwd">library</span>(ggplot2)

<span class="c-com"># 1. Cargar datos cl√≠nicos simulados</span>
<span class="c-kwd">set.seed</span>(123)
datos <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">Edad</span> = <span class="c-fn">round</span>(<span class="c-fn">runif</span>(100, 20, 80)),
  <span class="c-arg">Expresion_Genica</span> = <span class="c-fn">round</span>(<span class="c-fn">runif</span>(100, 100, 5000))
)

<span class="c-com"># 2. Configurar m√©todo de preprocesamiento</span>
metodo <- <span class="c-str">"${p.method.split(' ')[0]}"</span>
modelo_pp <- <span class="c-fn">preProcess</span>(datos, 
                    <span class="c-arg">method</span> = <span class="c-fn">c</span>(metodo))

<span class="c-com"># 3. Aplicar transformaci√≥n</span>
datos_norm <- <span class="c-fn">predict</span>(modelo_pp, datos)

<span class="c-com"># 4. Visualizaci√≥n comparativa</span>
<span class="c-fn">par</span>(<span class="c-arg">mfrow</span> = <span class="c-fn">c</span>(1, 2))
<span class="c-fn">plot</span>(datos<span class="c-var">$Edad</span>, datos<span class="c-var">$Expresion_Genica</span>,
     <span class="c-arg">main</span> = <span class="c-str">"Datos Originales"</span>,
     <span class="c-arg">xlab</span> = <span class="c-str">"Edad"</span>, <span class="c-arg">ylab</span> = <span class="c-str">"Expresi√≥n G√©nica"</span>)

<span class="c-fn">plot</span>(datos_norm<span class="c-var">$Edad</span>, datos_norm<span class="c-var">$Expresion_Genica</span>,
     <span class="c-arg">main</span> = <span class="c-str">"Datos Normalizados ("</span> + metodo + <span class="c-str">")"</span>,
     <span class="c-arg">xlab</span> = <span class="c-str">"Edad (norm)"</span>, <span class="c-arg">ylab</span> = <span class="c-str">"Expresi√≥n (norm)"</span>)

<span class="c-com"># 5. Estad√≠sticas resumen</span>
<span class="c-fn">cat</span>(<span class="c-str">"\\n=== RESUMEN ESTAD√çSTICO ===\\n"</span>)
<span class="c-fn">print</span>(<span class="c-fn">summary</span>(datos_norm))`,
                explain: (p) => {
                    let m = p.method.split(' ')[0];
                    if(m === 'raw') return `
                        <div class="exp-highlight">
                            <b>üìä Datos Crudos:</b> Observa la escala de los ejes. El eje Y (Expresi√≥n G√©nica) tiene valores entre 100-5000, mientras el eje X (Edad) est√° entre 20-80.
                        </div>
                        <p><b>Problema:</b> Los algoritmos basados en distancias (K-NN, SVM) dar√°n mucha m√°s importancia al eje Y porque los valores son m√°s grandes.</p>
                        <div class="exp-note">
                            <i class="fas fa-exclamation-triangle"></i> <b>Consecuencia:</b> Un paciente de 30 a√±os con expresi√≥n 4500 se considerar√° m√°s similar a uno de 80 a√±os con expresi√≥n 4600 que a uno de 31 a√±os con expresi√≥n 200.
                        </div>`;
                    if(m === 'center') return `
                        <div class="exp-highlight">
                            <b>üéØ Center (Centrado):</b> Restamos la media a cada variable. Ahora todas tienen media = 0.
                        </div>
                        <p><b>Ventaja:</b> Eliminamos el sesgo de ubicaci√≥n. <b>Limitaci√≥n:</b> No corregimos las diferencias de escala entre variables.</p>
                        <p><i>F√≥rmula:</i> x' = x - Œº</p>`;
                    if(m === 'scale') return `
                        <div class="exp-highlight">
                            <b>‚öñÔ∏è Scale (Estandarizaci√≥n):</b> Dividimos por la desviaci√≥n est√°ndar. Todas las variables ahora tienen media = 0 y desviaci√≥n est√°ndar = 1.
                        </div>
                        <p><b>Ventaja:</b> Variables comparables en escala. <b>Esencial para:</b> PCA, SVM, K-means, LDA.</p>
                        <p><i>F√≥rmula:</i> x' = (x - Œº) / œÉ</p>
                        <div class="exp-note">
                            <i class="fas fa-check-circle"></i> <b>Recomendado:</b> Usar scale cuando no conozcas la distribuci√≥n de tus datos.
                        </div>`;
                    return `
                        <div class="exp-highlight">
                            <b>üìà Range (Normalizaci√≥n Min-Max):</b> Escalamos todos los valores al rango [0, 1].
                        </div>
                        <p><b>Ventaja:</b> Valores acotados, √∫til para redes neuronales. <b>Limitaci√≥n:</b> Sensible a outliers.</p>
                        <p><i>F√≥rmula:</i> x' = (x - min) / (max - min)</p>
                        <div class="exp-note">
                            <i class="fas fa-lightbulb"></i> <b>Tip:</b> Usar range cuando trabajes con algoritmos sensibles a la escala como redes neuronales o K-NN.
                        </div>`;
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    const m = p.method.split(' ')[0];
                    
                    // Crear contenedor para los dos gr√°ficos
                    const container = document.createElement('div');
                    container.style.cssText = `
                        display: flex;
                        width: 100%;
                        height: 100%;
                        padding: 20px;
                        gap: 30px;
                    `;
                    
                    // Gr√°fico original
                    const originalDiv = document.createElement('div');
                    originalDiv.style.cssText = `
                        flex: 1;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        position: relative;
                    `;
                    
                    const originalTitle = document.createElement('div');
                    originalTitle.innerHTML = `<b style="color:#333;">Datos Originales</b>`;
                    originalTitle.style.cssText = 'margin-bottom: 15px; font-size: 0.9rem;';
                    originalDiv.appendChild(originalTitle);
                    
                    // Ejes originales
                    const axisX1 = document.createElement('div');
                    axisX1.style.cssText = `
                        position: absolute;
                        bottom: 20px;
                        width: calc(100% - 40px);
                        border-top: 2px solid #333;
                        text-align: center;
                        font-size: 11px;
                        color: #333;
                        padding-top: 5px;
                    `;
                    axisX1.innerText = "Edad (20-80 a√±os)";
                    originalDiv.appendChild(axisX1);
                    
                    const axisY1 = document.createElement('div');
                    axisY1.style.cssText = `
                        position: absolute;
                        left: 20px;
                        height: calc(100% - 40px);
                        border-left: 2px solid #333;
                        display: flex;
                        align-items: center;
                        font-size: 11px;
                        writing-mode: vertical-rl;
                        transform: rotate(180deg);
                        color: #333;
                        padding-left: 5px;
                    `;
                    axisY1.innerText = "Expresi√≥n G√©nica (100-5000)";
                    originalDiv.appendChild(axisY1);
                    
                    // Puntos originales
                    for(let i=0; i<40; i++) {
                        const x = Math.random() * 80 + 10;
                        const y = Math.random() * 30 + 35;
                        const dot = document.createElement('div');
                        dot.className = 'dot';
                        dot.style.left = x + '%';
                        dot.style.top = y + '%';
                        dot.style.backgroundColor = '#007acc';
                        dot.dataset.tooltip = `Edad: ${Math.round((x/100)*60+20)}, Expresi√≥n: ${Math.round((y/100)*4900+100)}`;
                        dot.onmouseover = showTooltip;
                        dot.onmouseout = hideTooltip;
                        originalDiv.appendChild(dot);
                    }
                    
                    // Gr√°fico normalizado
                    const normalizedDiv = document.createElement('div');
                    normalizedDiv.style.cssText = `
                        flex: 1;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        position: relative;
                    `;
                    
                    const normalizedTitle = document.createElement('div');
                    normalizedTitle.innerHTML = `<b style="color:#333;">Datos Normalizados (${m})</b>`;
                    normalizedTitle.style.cssText = 'margin-bottom: 15px; font-size: 0.9rem;';
                    normalizedDiv.appendChild(normalizedTitle);
                    
                    // Ejes normalizados
                    const axisX2 = document.createElement('div');
                    axisX2.style.cssText = axisX1.style.cssText;
                    axisX2.innerText = m === 'raw' ? "Edad" : "Variable X (normalizada)";
                    normalizedDiv.appendChild(axisX2);
                    
                    const axisY2 = document.createElement('div');
                    axisY2.style.cssText = axisY1.style.cssText;
                    axisY2.innerText = m === 'raw' ? "Expresi√≥n G√©nica" : "Variable Y (normalizada)";
                    normalizedDiv.appendChild(axisY2);
                    
                    // Puntos normalizados
                    for(let i=0; i<40; i++) {
                        let x = Math.random() * 80 + 10;
                        let y = Math.random() * 30 + 35;
                        
                        if(m !== 'raw') {
                            // Simular normalizaci√≥n
                            x = 50 + (Math.random() - 0.5) * (m === 'range' ? 30 : 60);
                            y = 50 + (Math.random() - 0.5) * (m === 'range' ? 30 : 60);
                        }
                        
                        const dot = document.createElement('div');
                        dot.className = 'dot';
                        dot.style.left = x + '%';
                        dot.style.top = y + '%';
                        dot.style.backgroundColor = m === 'raw' ? '#007acc' : 
                                                   m === 'center' ? '#00bcd4' : 
                                                   m === 'scale' ? '#4CAF50' : '#FF9800';
                        dot.dataset.tooltip = `X: ${(x/100).toFixed(2)}, Y: ${(y/100).toFixed(2)}`;
                        dot.onmouseover = showTooltip;
                        dot.onmouseout = hideTooltip;
                        normalizedDiv.appendChild(dot);
                    }
                    
                    // Outlier si est√° activado
                    if(p.outlier) {
                        const outlier = document.createElement('div');
                        outlier.className = 'dot';
                        outlier.style.backgroundColor = '#f44336';
                        outlier.style.width = '15px';
                        outlier.style.height = '15px';
                        outlier.style.zIndex = '100';
                        
                        if(m === 'range') {
                            outlier.style.left = '95%';
                            outlier.style.top = '95%';
                        } else if(m === 'raw') {
                            outlier.style.left = '90%';
                            outlier.style.top = '10%';
                        } else {
                            outlier.style.left = '90%';
                            outlier.style.top = '10%';
                        }
                        
                        outlier.dataset.tooltip = 'OUTLIER: Valor at√≠pico que distorsiona la normalizaci√≥n';
                        outlier.onmouseover = showTooltip;
                        outlier.onmouseout = hideTooltip;
                        normalizedDiv.appendChild(outlier);
                    }
                    
                    container.appendChild(originalDiv);
                    container.appendChild(normalizedDiv);
                    div.appendChild(container);
                }
            },
            {
                id: 2,
                title: "Tema 2. Reducci√≥n Dim. I",
                desc: "PCA vs t-SNE",
                icon: "fa-project-diagram",
                controls: [
                    {id: 'algo', type: 'select', label: 'Algoritmo', options: ['PCA (Lineal)', 't-SNE (No Lineal)']},
                    {id: 'view', type: 'checkbox', label: 'Vista 3D', value: false}
                ],
                code: (p) => `
<span class="c-com"># TEMA 2: REDUCCI√ìN DE DIMENSIONALIDAD</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(FactoMineR)
<span class="c-kwd">library</span>(Rtsne)
<span class="c-kwd">library</span>(ggplot2)

<span class="c-com"># 1. Datos de expresi√≥n g√©nica (100 genes √ó 50 muestras)</span>
<span class="c-kwd">set.seed</span>(123)
datos_expresion <- <span class="c-fn">matrix</span>(
  <span class="c-fn">rnorm</span>(100 * 50, mean = 0, sd = 1),
  <span class="c-arg">nrow</span> = 50,
  <span class="c-arg">ncol</span> = 100
)
<span class="c-fn">colnames</span>(datos_expresion) <- <span class="c-fn">paste0</span>(<span class="c-str">"Gen_"</span>, 1:100)
<span class="c-fn">rownames</span>(datos_expresion) <- <span class="c-fn">paste0</span>(<span class="c-str">"Muestra_"</span>, 1:50)

<span class="c-com"># 2. Grupos biol√≥gicos simulados (2 grupos)</span>
grupos <- <span class="c-fn">rep</span>(<span class="c-fn">c</span>(<span class="c-str">"Control"</span>, <span class="c-str">"Tratamiento"</span>), each = 25)

<span class="c-kwd">if</span> (<span class="c-str">"${p.algo}"</span> == <span class="c-str">"PCA (Lineal)"</span>) {
  
  <span class="c-com"># 3. AN√ÅLISIS DE COMPONENTES PRINCIPALES (PCA)</span>
  <span class="c-com"># Transformaci√≥n lineal que maximiza la varianza</span>
  pca_result <- <span class="c-fn">PCA</span>(datos_expresion,
                   <span class="c-arg">scale.unit</span> = TRUE,
                   <span class="c-arg">graph</span> = FALSE)
  
  <span class="c-com"># 4. Varianza explicada por cada componente</span>
  var_explicada <- <span class="c-fn">round</span>(pca_result<span class="c-var">$eig</span>[, 2], 1)
  <span class="c-fn">cat</span>(<span class="c-str">"Varianza explicada:\\n"</span>)
  <span class="c-fn">print</span>(var_explicada[1:5])
  
  <span class="c-com"># 5. Visualizaci√≥n 2D/3D</span>
  <span class="c-kwd">if</span> (${p.view}) {
    <span class="c-com"># Plot 3D de los primeros 3 componentes</span>
    <span class="c-kwd">library</span>(plotly)
    plot_ly(<span class="c-arg">x</span> = pca_result<span class="c-var">$ind</span><span class="c-var">$coord</span>[,1],
            <span class="c-arg">y</span> = pca_result<span class="c-var">$ind</span><span class="c-var">$coord</span>[,2],
            <span class="c-arg">z</span> = pca_result<span class="c-var">$ind</span><span class="c-var">$coord</span>[,3],
            <span class="c-arg">color</span> = grupos,
            <span class="c-arg">type</span> = <span class="c-str">"scatter3d"</span>,
            <span class="c-arg">mode</span> = <span class="c-str">"markers"</span>)
  } <span class="c-kwd">else</span> {
    <span class="c-com"># Plot 2D tradicional</span>
    <span class="c-fn">plot</span>(pca_result<span class="c-var">$ind</span><span class="c-var">$coord</span>[,1:2],
         <span class="c-arg">col</span> = <span class="c-fn">factor</span>(grupos),
         <span class="c-arg">pch</span> = 19,
         <span class="c-arg">main</span> = <span class="c-str">"PCA: Componentes 1 vs 2"</span>)
    <span class="c-fn">legend</span>(<span class="c-str">"topright"</span>, <span class="c-arg">legend</span> = <span class="c-fn">levels</span>(<span class="c-fn">factor</span>(grupos)),
           <span class="c-arg">col</span> = 1:2, <span class="c-arg">pch</span> = 19)
  }
  
} <span class="c-kwd">else</span> {
  
  <span class="c-com"># 6. t-SNE (t-Distributed Stochastic Neighbor Embedding)</span>
  <span class="c-com"># T√©cnica no lineal para visualizaci√≥n</span>
  tsne_result <- <span class="c-fn">Rtsne</span>(datos_expresion,
                    <span class="c-arg">perplexity</span> = 30,
                    <span class="c-arg">theta</span> = 0.5,
                    <span class="c-arg">dims</span> = ${p.view ? 3 : 2},
                    <span class="c-arg">verbose</span> = TRUE)
  
  <span class="c-com"># 7. Visualizaci√≥n t-SNE</span>
  <span class="c-kwd">if</span> (${p.view}) {
    <span class="c-kwd">library</span>(plotly)
    plot_ly(<span class="c-arg">x</span> = tsne_result<span class="c-var">$Y</span>[,1],
            <span class="c-arg">y</span> = tsne_result<span class="c-var">$Y</span>[,2],
            <span class="c-arg">z</span> = tsne_result<span class="c-var">$Y</span>[,3],
            <span class="c-arg">color</span> = grupos,
            <span class="c-arg">type</span> = <span class="c-str">"scatter3d"</span>,
            <span class="c-arg">mode</span> = <span class="c-str">"markers"</span>)
  } <span class="c-kwd">else</span> {
    <span class="c-fn">plot</span>(tsne_result<span class="c-var">$Y</span>,
         <span class="c-arg">col</span> = <span class="c-fn">factor</span>(grupos),
         <span class="c-arg">pch</span> = 19,
         <span class="c-arg">main</span> = <span class="c-str">"t-SNE: Proyecci√≥n 2D"</span>,
         <span class="c-arg">xlab</span> = <span class="c-str">"t-SNE 1"</span>,
         <span class="c-arg">ylab</span> = <span class="c-str">"t-SNE 2"</span>)
  }
}`,
                explain: (p) => {
                    if(p.algo === 'PCA (Lineal)') {
                        return `
                        <div class="exp-highlight">
                            <b>üìê PCA (An√°lisis de Componentes Principales)</b>
                        </div>
                        
                        <p><b>Concepto:</b> Transformaci√≥n lineal ortogonal que convierte datos correlacionados en componentes principales no correlacionados.</p>
                        
                        <p><b>Matem√°ticamente:</b></p>
                        <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                            PC‚ÇÅ = w‚ÇÅ‚ÇÅX‚ÇÅ + w‚ÇÅ‚ÇÇX‚ÇÇ + ... + w‚ÇÅ‚ÇöX‚Çö<br>
                            PC‚ÇÇ = w‚ÇÇ‚ÇÅX‚ÇÅ + w‚ÇÇ‚ÇÇX‚ÇÇ + ... + w‚ÇÇ‚ÇöX‚Çö
                        </p>
                        
                        <p><b>Propiedades clave:</b></p>
                        <ul>
                            <li>üìà PC‚ÇÅ explica la m√°xima varianza posible</li>
                            <li>üìâ Cada PC sucesivo explica la m√°xima varianza restante</li>
                            <li>‚öñÔ∏è Los componentes son ortogonales (no correlacionados)</li>
                            <li>üéØ La suma de varianzas se mantiene</li>
                        </ul>
                        
                        ${p.view ? `
                        <div class="exp-note">
                            <i class="fas fa-cube"></i> <b>Vista 3D:</b> Observa c√≥mo PCA rota el espacio 3D original para alinearse con las direcciones de m√°xima varianza.
                        </div>
                        ` : ''}
                        
                        <div class="exp-highlight">
                            <b>üöÄ Aplicaciones en Bioinform√°tica:</b>
                            <p>1. <b>Visualizaci√≥n de datos √≥micos</b></p>
                            <p>2. <b>Eliminaci√≥n de ruido t√©cnico</b></p>
                            <p>3. <b>Detecci√≥n de batch effects</b></p>
                            <p>4. <b>Reducci√≥n de dimensionalidad para ML</b></p>
                        </div>`;
                    } else {
                        return `
                        <div class="exp-highlight">
                            <b>üåÄ t-SNE (t-Distributed Stochastic Neighbor Embedding)</b>
                        </div>
                        
                        <p><b>Concepto:</b> T√©cnica no lineal que preserva la estructura local de los datos en alta dimensi√≥n.</p>
                        
                        <p><b>Algoritmo en dos pasos:</b></p>
                        <p>1. <b>Espacio original:</b> Calcula probabilidades de vecindad usando distribuci√≥n Gaussiana</p>
                        <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                            p‚±º‚Çó·µ¢ = exp(-||x·µ¢ - x‚±º||¬≤ / 2œÉ·µ¢¬≤) / Œ£‚Çñ‚â†·µ¢ exp(-||x·µ¢ - x‚Çñ||¬≤ / 2œÉ·µ¢¬≤)
                        </p>
                        <p>2. <b>Espacio reducido:</b> Usa distribuci√≥n t de Student para evitar el "crowding problem"</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-exclamation-triangle"></i> <b>¬°Atenci√≥n! t-SNE NO preserva:</b>
                            <p>‚Ä¢ Distancias globales entre clusters</p>
                            <p>‚Ä¢ La densidad de puntos</p>
                            <p>‚Ä¢ La escala del espacio</p>
                        </div>
                        
                        ${p.view ? `
                        <div class="exp-note">
                            <i class="fas fa-cube"></i> <b>Vista 3D:</b> t-SNE puede proyectar a 3D, pero es computacionalmente costoso y raramente usado.
                        </div>
                        ` : ''}
                        
                        <div class="exp-highlight">
                            <b>üéØ Cu√°ndo usar PCA vs t-SNE:</b>
                            <p><b>PCA:</b> An√°lisis exploratorio, eliminaci√≥n de ruido, datos lineales</p>
                            <p><b>t-SNE:</b> Visualizaci√≥n de clusters complejos, datos no lineales, pattern discovery</p>
                        </div>`;
                    }
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    const isPCA = p.algo === 'PCA (Lineal)';
                    const is3D = p.view;
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        flex-direction: column;
                        gap: 20px;
                    `;
                    
                    if(is3D) {
                        // Visualizaci√≥n 3D
                        const scene3D = document.createElement('div');
                        scene3D.className = 'scene-3d';
                        scene3D.style.cssText = `
                            width: 300px;
                            height: 300px;
                            background: white;
                            border-radius: 10px;
                            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            position: relative;
                            transform: rotateX(60deg) rotateZ(45deg);
                        `;
                        
                        // Ejes 3D
                        const xAxis = document.createElement('div');
                        xAxis.style.cssText = `
                            position: absolute;
                            left: 50%;
                            top: 50%;
                            width: 200px;
                            height: 2px;
                            background: #f44336;
                            transform: translate(-50%, -50%) rotateY(90deg);
                        `;
                        
                        const yAxis = document.createElement('div');
                        yAxis.style.cssText = `
                            position: absolute;
                            left: 50%;
                            top: 50%;
                            width: 200px;
                            height: 2px;
                            background: #4CAF50;
                            transform: translate(-50%, -50%) rotateX(90deg);
                        `;
                        
                        const zAxis = document.createElement('div');
                        zAxis.style.cssText = `
                            position: absolute;
                            left: 50%;
                            top: 50%;
                            width: 200px;
                            height: 2px;
                            background: #2196F3;
                            transform: translate(-50%, -50%);
                        `;
                        
                        scene3D.appendChild(xAxis);
                        scene3D.appendChild(yAxis);
                        scene3D.appendChild(zAxis);
                        
                        // Puntos 3D
                        const numPoints = 40;
                        for(let i = 0; i < numPoints; i++) {
                            const point = document.createElement('div');
                            const x = Math.random() * 160 + 20;
                            const y = Math.random() * 160 + 20;
                            const z = Math.random() * 160 + 20;
                            const isGroup1 = i < numPoints/2;
                            
                            point.style.cssText = `
                                position: absolute;
                                width: 8px;
                                height: 8px;
                                border-radius: 50%;
                                background: ${isGroup1 ? '#007acc' : '#FF9800'};
                                left: ${x}px;
                                top: ${y}px;
                                transform: translateZ(${z}px);
                                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                            `;
                            
                            if(isPCA) {
                                // PCA: puntos m√°s organizados en el espacio 3D
                                point.style.transform = `translateZ(${z}px) rotateX(${is3D ? 60 : 0}deg) rotateZ(${is3D ? 45 : 0}deg)`;
                            }
                            
                            scene3D.appendChild(point);
                        }
                        
                        container.appendChild(scene3D);
                        
                        const label = document.createElement('div');
                        label.innerHTML = `<b style="color:#333;">${isPCA ? 'PCA 3D - Componentes 1, 2 y 3' : 't-SNE 3D - Proyecci√≥n no lineal'}</b>`;
                        label.style.cssText = 'font-size: 0.9rem; text-align: center;';
                        container.appendChild(label);
                    } else {
                        // Visualizaci√≥n 2D
                        const plot2D = document.createElement('div');
                        plot2D.style.cssText = `
                            width: 400px;
                            height: 400px;
                            background: white;
                            border-radius: 10px;
                            padding: 20px;
                            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            position: relative;
                        `;
                        
                        // T√≠tulo
                        const title = document.createElement('div');
                        title.innerHTML = `<b style="color:#333; font-size:1rem;">${isPCA ? 'PCA - Proyecci√≥n Lineal' : 't-SNE - Proyecci√≥n No Lineal'}</b>`;
                        title.style.cssText = 'margin-bottom: 15px; text-align: center;';
                        plot2D.appendChild(title);
                        
                        // Ejes
                        const axisX = document.createElement('div');
                        axisX.style.cssText = `
                            position: absolute;
                            bottom: 20px;
                            left: 20px;
                            right: 20px;
                            border-top: 2px solid #333;
                            text-align: center;
                            padding-top: 5px;
                            font-size: 11px;
                            color: #333;
                        `;
                        axisX.textContent = isPCA ? 'Componente Principal 1' : 't-SNE 1';
                        plot2D.appendChild(axisX);
                        
                        const axisY = document.createElement('div');
                        axisY.style.cssText = `
                            position: absolute;
                            left: 20px;
                            top: 20px;
                            bottom: 40px;
                            border-left: 2px solid #333;
                            display: flex;
                            align-items: center;
                            padding-left: 5px;
                            font-size: 11px;
                            writing-mode: vertical-rl;
                            transform: rotate(180deg);
                            color: #333;
                        `;
                        axisY.textContent = isPCA ? 'Componente Principal 2' : 't-SNE 2';
                        plot2D.appendChild(axisY);
                        
                        // Puntos
                        const numPoints = 60;
                        for(let i = 0; i < numPoints; i++) {
                            let x, y;
                            const isGroup1 = i < numPoints/2;
                            
                            if(isPCA) {
                                // PCA: distribuci√≥n m√°s lineal/el√≠ptica
                                x = 50 + (Math.random() - 0.5) * 80;
                                y = 50 + (Math.random() - 0.5) * 40 + (isGroup1 ? 20 : -20);
                            } else {
                                // t-SNE: clusters m√°s definidos y separados
                                const clusterX = isGroup1 ? 30 : 70;
                                const clusterY = isGroup1 ? 30 : 70;
                                x = clusterX + (Math.random() - 0.5) * 25;
                                y = clusterY + (Math.random() - 0.5) * 25;
                            }
                            
                            const point = document.createElement('div');
                            point.className = 'dot';
                            point.style.left = x + '%';
                            point.style.top = y + '%';
                            point.style.backgroundColor = isGroup1 ? '#007acc' : '#FF9800';
                            point.style.borderColor = 'white';
                            
                            plot2D.appendChild(point);
                        }
                        
                        container.appendChild(plot2D);
                    }
                    
                    div.appendChild(container);
                }
            },
            {
                id: 3,
                title: "Tema 3. Reducci√≥n Dim. II",
                desc: "UMAP & Manifolds",
                icon: "fa-map",
                controls: [
                    {id: 'nn', type: 'range', label: 'Vecinos', min: 2, max: 50, val: 15},
                    {id: 'dist', type: 'range', label: 'Distancia M√≠n', min: 1, max: 99, val: 10}
                ],
                code: (p) => `
<span class="c-com"># TEMA 3: UMAP - APRENDIZAJE DE VARIEDADES</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(uwot)
<span class="c-kwd">library</span>(ggplot2)

<span class="c-com"># 1. Datos complejos (forma de "Swiss Roll" o "S")</span>
<span class="c-kwd">set.seed</span>(123)
n <- 300
t <- <span class="c-fn">runif</span>(n) * 3 * pi
x <- t * <span class="c-fn">cos</span>(t)
y <- 20 * <span class="c-fn">runif</span>(n)
z <- t * <span class="c-fn">sin</span>(t)

datos_3d <- <span class="c-fn">data.frame</span>(<span class="c-arg">x</span> = x, <span class="c-arg">y</span> = y, <span class="c-arg">z</span> = z)
grupos <- <span class="c-fn">cut</span>(t, 3, <span class="c-arg">labels</span> = <span class="c-fn">c</span>(<span class="c-str">"A"</span>, <span class="c-str">"B"</span>, <span class="c-str">"C"</span>))

<span class="c-com"># 2. Configurar par√°metros UMAP</span>
n_vecinos <- <span class="c-num">${p.nn}</span>
dist_min <- <span class="c-num">${p.dist / 100}</span>

<span class="c-com"># 3. Ejecutar UMAP</span>
umap_result <- <span class="c-fn">umap</span>(
  datos_3d,
  <span class="c-arg">n_neighbors</span> = n_vecinos,
  <span class="c-arg">min_dist</span> = dist_min,
  <span class="c-arg">n_components</span> = 2,
  <span class="c-arg">metric</span> = <span class="c-str">"euclidean"</span>,
  <span class="c-arg">learning_rate</span> = 1.0,
  <span class="c-arg">n_epochs</span> = 500
)

<span class="c-com"># 4. Visualizaci√≥n resultados</span>
umap_df <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">UMAP1</span> = umap_result[,1],
  <span class="c-arg">UMAP2</span> = umap_result[,2],
  <span class="c-arg">Grupo</span> = grupos
)

ggplot(umap_df, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = UMAP1, <span class="c-arg">y</span> = UMAP2, <span class="c-arg">color</span> = Grupo)) +
  <span class="c-fn">geom_point</span>(<span class="c-arg">size</span> = 3, <span class="c-arg">alpha</span> = 0.7) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">ggtitle</span>(<span class="c-str">"UMAP: Proyecci√≥n de Variedad (Manifold)"</span>) +
  <span class="c-fn">labs</span>(
    <span class="c-arg">subtitle</span> = <span class="c-fn">paste</span>(<span class="c-str">"n_neighbors ="</span>, n_vecinos, 
                     <span class="c-str">"min_dist ="</span>, <span class="c-fn">round</span>(dist_min, 2))
  )

<span class="c-com"># 5. Comparaci√≥n con PCA y t-SNE</span>
<span class="c-com"># PCA lineal</span>
pca_result <- <span class="c-fn">prcomp</span>(datos_3d, <span class="c-arg">scale.</span> = TRUE)

<span class="c-com"># t-SNE</span>
<span class="c-kwd">library</span>(Rtsne)
tsne_result <- <span class="c-fn">Rtsne</span>(datos_3d, <span class="c-arg">perplexity</span> = 30, <span class="c-arg">verbose</span> = FALSE)

<span class="c-com"># 6. Visualizaci√≥n comparativa</span>
<span class="c-fn">par</span>(<span class="c-arg">mfrow</span> = <span class="c-fn">c</span>(1, 3))
<span class="c-fn">plot</span>(pca_result<span class="c-var">$x</span>[,1:2], <span class="c-arg">col</span> = grupos, <span class="c-arg">main</span> = <span class="c-str">"PCA"</span>)
<span class="c-fn">plot</span>(tsne_result<span class="c-var">$Y</span>, <span class="c-arg">col</span> = grupos, <span class="c-arg">main</span> = <span class="c-str">"t-SNE"</span>)
<span class="c-fn">plot</span>(umap_result, <span class="c-arg">col</span> = grupos, <span class="c-arg">main</span> = <span class="c-str">"UMAP"</span>)`,
                explain: (p) => {
                    return `
                        <div class="exp-highlight">
                            <b>üåê UMAP (Uniform Manifold Approximation and Projection)</b>
                        </div>
                        
                        <p><b>Concepto:</b> Algoritmo de aprendizaje de variedades que asume que los datos viven en una variedad de Riemann (superficie curva) embebida en un espacio de alta dimensi√≥n.</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Par√°metros clave:</b><br>
                            ‚Ä¢ <b>n_neighbors = ${p.nn}</b>: Balance entre estructura local/global<br>
                            ‚Ä¢ <b>min_dist = ${(p.dist/100).toFixed(2)}</b>: Distancia m√≠nima entre puntos<br>
                            ‚Ä¢ <b>n_components = 2</b>: Dimensi√≥n del espacio de proyecci√≥n
                        </div>
                        
                        <p><b>Fundamento matem√°tico:</b></p>
                        <p>1. <b>Construir grafo ponderado</b> en alta dimensi√≥n</p>
                        <p>2. <b>Optimizar layout</b> en baja dimensi√≥n usando cross-entropy</p>
                        <p>3. <b>Preservar topolog√≠a</b> (relaciones de vecindad)</p>
                        
                        <div class="exp-highlight">
                            <b>‚ö° Ventajas sobre t-SNE:</b>
                            <p>‚Ä¢ ‚è±Ô∏è <b>M√°s r√°pido</b>: Complejidad O(N) vs O(N¬≤)</p>
                            <p>‚Ä¢ üìê <b>Mejor preservaci√≥n de estructura global</b></p>
                            <p>‚Ä¢ üéØ <b>Par√°metros m√°s interpretables</b></p>
                            <p>‚Ä¢ üîÑ <b>Transformaci√≥n out-of-sample</b> posible</p>
                        </div>
                        
                        <p><b>Interpretaci√≥n de par√°metros:</b></p>
                        <p>‚Ä¢ <b>n_neighbors peque√±o (${p.nn <= 15 ? '‚Üì' : '‚Üë'})</b>: ‚Üí Enfoca estructura local, puede crear clusters artificiales</p>
                        <p>‚Ä¢ <b>n_neighbors grande (${p.nn > 30 ? '‚Üë' : '‚Üì'})</b>: ‚Üí Captura m√°s estructura global</p>
                        <p>‚Ä¢ <b>min_dist peque√±o (${p.dist < 30 ? '‚Üì' : '‚Üë'})</b>: ‚Üí Clusters m√°s compactos, menos separaci√≥n</p>
                        <p>‚Ä¢ <b>min_dist grande (${p.dist > 70 ? '‚Üë' : '‚Üì'})</b>: ‚Üí Clusters m√°s dispersos, mejor separaci√≥n</p>
                        
                        <div class="exp-highlight">
                            <b>üß¨ Aplicaci√≥n en Single-Cell RNA-seq:</b>
                            <p>UMAP es el est√°ndar de facto para visualizar datos de scRNA-seq por su capacidad de revelar jerarqu√≠as celulares y transiciones entre estados.</p>
                        </div>`;
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    `;
                    
                    const plotArea = document.createElement('div');
                    plotArea.style.cssText = `
                        width: 500px;
                        height: 500px;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        position: relative;
                    `;
                    
                    // T√≠tulo
                    const title = document.createElement('div');
                    title.innerHTML = `<b style="color:#333; font-size:1rem;">UMAP - Aprendizaje de Variedades</b>`;
                    title.style.cssText = 'margin-bottom: 15px; text-align: center;';
                    plotArea.appendChild(title);
                    
                    // Ejes
                    const axisX = document.createElement('div');
                    axisX.style.cssText = `
                        position: absolute;
                        bottom: 20px;
                        left: 20px;
                        right: 20px;
                        border-top: 2px solid #333;
                        text-align: center;
                        padding-top: 5px;
                        font-size: 11px;
                        color: #333;
                    `;
                    axisX.textContent = 'UMAP 1';
                    plotArea.appendChild(axisX);
                    
                    const axisY = document.createElement('div');
                    axisY.style.cssText = `
                        position: absolute;
                        left: 20px;
                        top: 20px;
                        bottom: 40px;
                        border-left: 2px solid #333;
                        display: flex;
                        align-items: center;
                        padding-left: 5px;
                        font-size: 11px;
                        writing-mode: vertical-rl;
                        transform: rotate(180deg);
                        color: #333;
                    `;
                    axisY.textContent = 'UMAP 2';
                    plotArea.appendChild(axisY);
                    
                    // Crear forma de "S" o variedad
                    const numPoints = 100;
                    const spread = p.dist / 20; // Controlar dispersi√≥n
                    
                    for(let i = 0; i < numPoints; i++) {
                        // Crear forma de variedad (S curve)
                        const t = (i / numPoints) * 6 - 3;
                        const x = 50 + Math.sin(t) * 40;
                        const y = 50 + t * 15;
                        
                        // A√±adir ruido controlado por par√°metros
                        const noiseX = (Math.random() - 0.5) * spread;
                        const noiseY = (Math.random() - 0.5) * spread;
                        
                        // Determinar grupo basado en posici√≥n
                        let group;
                        let color;
                        if(i < numPoints/3) {
                            group = 'A';
                            color = '#007acc';
                        } else if(i < 2*numPoints/3) {
                            group = 'B';
                            color = '#4CAF50';
                        } else {
                            group = 'C';
                            color = '#FF9800';
                        }
                        
                        const point = document.createElement('div');
                        point.className = 'dot';
                        point.style.left = (x + noiseX) + '%';
                        point.style.top = (y + noiseY) + '%';
                        point.style.backgroundColor = color;
                        point.style.borderColor = 'white';
                        point.dataset.tooltip = `Grupo: ${group}<br>Posici√≥n en variedad: ${(i/numPoints).toFixed(2)}`;
                        point.onmouseover = showTooltip;
                        point.onmouseout = hideTooltip;
                        
                        plotArea.appendChild(point);
                    }
                    
                    // L√≠nea de variedad subyacente
                    const manifoldLine = document.createElement('div');
                    manifoldLine.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        pointer-events: none;
                    `;
                    
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', '100%');
                    
                    // Dibujar curva de variedad
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let d = 'M ';
                    for(let i = 0; i <= 100; i += 10) {
                        const t = (i / 100) * 6 - 3;
                        const x = 50 + Math.sin(t) * 40;
                        const y = 50 + t * 15;
                        d += `${x}% ${y}% `;
                    }
                    path.setAttribute('d', d);
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke', 'rgba(0,0,0,0.2)');
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('stroke-dasharray', '5,5');
                    
                    svg.appendChild(path);
                    manifoldLine.appendChild(svg);
                    plotArea.appendChild(manifoldLine);
                    
                    // Panel de par√°metros
                    const paramPanel = document.createElement('div');
                    paramPanel.style.cssText = `
                        position: absolute;
                        top: 20px;
                        right: 20px;
                        background: white;
                        padding: 10px 15px;
                        border-radius: 5px;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        font-size: 0.8rem;
                        color: #333;
                        border-left: 3px solid #9C27B0;
                    `;
                    paramPanel.innerHTML = `
                        <b>Par√°metros UMAP:</b><br>
                        ‚Ä¢ n_neighbors: ${p.nn}<br>
                        ‚Ä¢ min_dist: ${(p.dist/100).toFixed(2)}<br>
                        ‚Ä¢ Puntos: ${numPoints}<br>
                        ‚Ä¢ Grupos: A, B, C
                    `;
                    plotArea.appendChild(paramPanel);
                    
                    container.appendChild(plotArea);
                    div.appendChild(container);
                }
            },
            {
                id: 4,
                title: "Tema 4. Clusterizaci√≥n",
                desc: "K-Means vs Jer√°rquico",
                icon: "fa-sitemap",
                controls: [
                    {id: 'k', type: 'range', label: 'N√∫mero K', min: 2, max: 6, val: 3},
                    {id: 'algo', type: 'select', label: 'M√©todo', options: ['K-Means', 'Jer√°rquico (Hclust)']}
                ],
                code: (p) => `
<span class="c-com"># TEMA 4: CLUSTERIZACI√ìN NO SUPERVISADA</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(cluster)
<span class="c-kwd">library</span>(factoextra)
<span class="c-kwd">library</span>(dendextend)

<span class="c-com"># 1. Datos de expresi√≥n g√©nica para clustering</span>
<span class="c-kwd">set.seed</span>(123)
datos_cluster <- <span class="c-fn">matrix</span>(
  <span class="c-fn">c</span>(
    <span class="c-fn">rnorm</span>(100, mean = 10, sd = 2),
    <span class="c-fn">rnorm</span>(100, mean = 20, sd = 2),
    <span class="c-fn">rnorm</span>(100, mean = 15, sd = 2)
  ),
  <span class="c-arg">ncol</span> = 3,
  <span class="c-arg">byrow</span> = TRUE
)
<span class="c-fn">colnames</span>(datos_cluster) <- <span class="c-fn">c</span>(<span class="c-str">"Gen_A"</span>, <span class="c-str">"Gen_B"</span>, <span class="c-str">"Gen_C"</span>)

<span class="c-com"># 2. Escalar datos (importante para clustering)</span>
datos_scaled <- <span class="c-fn">scale</span>(datos_cluster)

<span class="c-kwd">if</span> (<span class="c-str">"${p.algo}"</span> == <span class="c-str">"K-Means"</span>) {
  
  <span class="c-com"># 3. K-MEANS CLUSTERING</span>
  k <- <span class="c-num">${p.k}</span>
  
  <span class="c-com"># Ejecutar k-means con m√∫ltiples inicializaciones</span>
  kmeans_result <- <span class="c-fn">kmeans</span>(
    datos_scaled,
    <span class="c-arg">centers</span> = k,
    <span class="c-arg">nstart</span> = 25,  <span class="c-com"># N√∫mero de inicializaciones aleatorias</span>
    <span class="c-arg">iter.max</span> = 100
  )
  
  <span class="c-com"># 4. M√©tricas de calidad</span>
  wss <- kmeans_result<span class="c-var">$tot.withinss</span>  <span class="c-com"># Within-cluster sum of squares</span>
  bss <- kmeans_result<span class="c-var">$betweenss</span>    <span class="c-com"># Between-cluster sum of squares</span>
  ratio_bw <- <span class="c-fn">round</span>(bss / (bss + wss) * 100, 1)
  
  <span class="c-fn">cat</span>(<span class="c-str">"=== K-MEANS (k="</span>, k, <span class="c-str">") ===\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"Within-cluster SS:"</span>, <span class="c-fn">round</span>(wss, 2), <span class="c-str">"\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"Between-cluster SS:"</span>, <span class="c-fn">round</span>(bss, 2), <span class="c-str">"\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"% varianza explicada:"</span>, ratio_bw, <span class="c-str">"%\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"Tama√±o clusters:"</span>, kmeans_result<span class="c-var">$size</span>, <span class="c-str">"\\n"</span>)
  
  <span class="c-com"># 5. Visualizaci√≥n clusters</span>
  <span class="c-fn">fviz_cluster</span>(
    kmeans_result,
    <span class="c-arg">data</span> = datos_scaled,
    <span class="c-arg">geom</span> = <span class="c-str">"point"</span>,
    <span class="c-arg">ellipse.type</span> = <span class="c-str">"convex"</span>,
    <span class="c-arg">palette</span> = <span class="c-str">"Set2"</span>,
    <span class="c-arg">ggtheme</span> = theme_minimal()
  ) + 
    <span class="c-fn">ggtitle</span>(<span class="c-str">"K-Means Clustering"</span>)
  
} <span class="c-kwd">else</span> {
  
  <span class="c-com"># 6. CLUSTERING JER√ÅRQUICO</span>
  <span class="c-com"># Calcular matriz de distancias</span>
  dist_matrix <- <span class="c-fn">dist</span>(datos_scaled, <span class="c-arg">method</span> = <span class="c-str">"euclidean"</span>)
  
  <span class="c-com"># Ejecutar clustering jer√°rquico</span>
  hc_result <- <span class="c-fn">hclust</span>(
    dist_matrix,
    <span class="c-arg">method</span> = <span class="c-str">"ward.D2"</span>  <span class="c-com"># Minimiza varianza intra-cluster</span>
  )
  
  <span class="c-com"># 7. Cortar dendrograma en k clusters</span>
  k <- <span class="c-num">${p.k}</span>
  clusters_hc <- <span class="c-fn">cutree</span>(hc_result, <span class="c-arg">k</span> = k)
  
  <span class="c-com"># 8. M√©tricas de calidad</span>
  sil_score <- <span class="c-fn">mean</span>(<span class="c-fn">silhouette</span>(clusters_hc, dist_matrix)[,3])
  
  <span class="c-fn">cat</span>(<span class="c-str">"=== CLUSTERING JER√ÅRQUICO ===\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"M√©todo:"</span>, <span class="c-str">"ward.D2"</span>, <span class="c-str">"\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"N√∫mero clusters:"</span>, k, <span class="c-str">"\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"Silhouette score:"</span>, <span class="c-fn">round</span>(sil_score, 3), <span class="c-str">"\\n"</span>)
  
  <span class="c-com"># 9. Visualizaci√≥n dendrograma</span>
  dend <- <span class="c-fn">as.dendrogram</span>(hc_result)
  <span class="c-fn">par</span>(<span class="c-arg">mfrow</span> = <span class="c-fn">c</span>(1, 2))
  
  <span class="c-com"># Dendrograma con colores</span>
  dend_colored <- <span class="c-fn">color_branches</span>(dend, <span class="c-arg">k</span> = k)
  <span class="c-fn">plot</span>(dend_colored,
       <span class="c-arg">main</span> = <span class="c-str">"Dendrograma"</span>,
       <span class="c-arg">xlab</span> = <span class="c-str">"Muestras"</span>,
       <span class="c-arg">ylab</span> = <span class="c-str">"Altura"</span>)
  
  <span class="c-com"># Silhouette plot</span>
  <span class="c-fn">plot</span>(<span class="c-fn">silhouette</span>(clusters_hc, dist_matrix),
       <span class="c-arg">main</span> = <span class="c-str">"Silhouette Plot"</span>,
       <span class="c-arg">col</span> = 1:k)
}`,
                explain: (p) => {
                    const isKMeans = p.algo === 'K-Means';
                    
                    if(isKMeans) {
                        return `
                        <div class="exp-highlight">
                            <b>üéØ K-Means Clustering</b>
                        </div>
                        
                        <p><b>Concepto:</b> Algoritmo de partici√≥n que divide n observaciones en k clusters donde cada observaci√≥n pertenece al cluster con la media m√°s cercana.</p>
                        
                        <p><b>Algoritmo (Lloyd's algorithm):</b></p>
                        <p>1. <b>Inicializaci√≥n:</b> Seleccionar k centroides aleatorios</p>
                        <p>2. <b>Asignaci√≥n:</b> Asignar cada punto al centroide m√°s cercano</p>
                        <p>3. <b>Actualizaci√≥n:</b> Recalcular centroides como media de puntos asignados</p>
                        <p>4. <b>Repetir</b> hasta convergencia</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Par√°metros clave:</b><br>
                            ‚Ä¢ <b>k = ${p.k}</b>: N√∫mero de clusters<br>
                            ‚Ä¢ <b>nstart = 25</b>: N√∫mero de inicializaciones aleatorias<br>
                            ‚Ä¢ <b>iter.max = 100</b>: M√°ximo n√∫mero de iteraciones
                        </div>
                        
                        <p><b>Funci√≥n objetivo (minimizar):</b></p>
                        <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                            J = Œ£·µ¢ Œ£‚±º ||x·µ¢‚±º - Œº‚±º||¬≤
                        </p>
                        <p>Donde Œº‚±º es el centroide del cluster j</p>
                        
                        <div class="exp-highlight">
                            <b>‚ö° Ventajas:</b>
                            <p>‚Ä¢ ‚è±Ô∏è <b>Escalable</b> a grandes conjuntos de datos</p>
                            <p>‚Ä¢ üéØ <b>Simple</b> de implementar y entender</p>
                            <p>‚Ä¢ üîÑ <b>Garantiza convergencia</b> (local)</p>
                        </div>
                        
                        <p><b>‚ö†Ô∏è Limitaciones:</b></p>
                        <ul>
                            <li>üìè Asume clusters esf√©ricos de tama√±o similar</li>
                            <li>üéØ Sensible a inicializaci√≥n (k-means++)</li>
                            <li>üî¢ Necesita especificar k a priori</li>
                            <li>üìä Sensible a outliers</li>
                        </ul>
                        
                        <div class="exp-note">
                            <i class="fas fa-lightbulb"></i> <b>M√©todo del codo (Elbow Method):</b>
                            <p>Graficar WSS (Within-cluster Sum of Squares) vs k. El punto donde la reducci√≥n en WSS se estabiliza sugiere el k √≥ptimo.</p>
                        </div>`;
                    } else {
                        return `
                        <div class="exp-highlight">
                            <b>üå≥ Clustering Jer√°rquico</b>
                        </div>
                        
                        <p><b>Concepto:</b> Construye una jerarqu√≠a de clusters representada como un dendrograma.</p>
                        
                        <p><b>Dos enfoques principales:</b></p>
                        <p>1. <b>Agrupamiento (Agglomerative):</b> Bottom-up, cada punto como cluster individual que se fusiona</p>
                        <p>2. <b>Divisi√≥n (Divisive):</b> Top-down, todo como un cluster que se divide</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>M√©todos de enlace (Linkage):</b><br>
                            ‚Ä¢ <b>ward.D2</b>: Minimiza varianza intra-cluster (usado)<br>
                            ‚Ä¢ <b>complete</b>: Distancia m√°xima entre clusters<br>
                            ‚Ä¢ <b>single</b>: Distancia m√≠nima entre clusters<br>
                            ‚Ä¢ <b>average</b>: Distancia promedio entre clusters
                        </div>
                        
                        <p><b>Matriz de distancia:</b></p>
                        <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                            d(x, y) = ‚àöŒ£·µ¢(x·µ¢ - y·µ¢)¬≤  (euclidiana)
                        </p>
                        
                        <div class="exp-highlight">
                            <b>üìä Interpretaci√≥n del dendrograma:</b>
                            <p>‚Ä¢ <b>Altura:</b> Distancia a la que se fusionan clusters</p>
                            <p>‚Ä¢ <b>Corte (k=${p.k}):</b> Define n√∫mero de clusters</p>
                            <p>‚Ä¢ <b>Longitud ramas:</b> Homogeneidad dentro del cluster</p>
                        </div>
                        
                        <p><b>M√©trica de calidad:</b></p>
                        <p><b>Silhouette Score (${p.k} clusters):</b> Mide cu√°n similar es un objeto a su propio cluster vs otros clusters.</p>
                        <p>Rango: -1 (mal asignado) a +1 (bien asignado)</p>
                        
                        <div class="exp-highlight">
                            <b>üß¨ Aplicaci√≥n en biolog√≠a:</b>
                            <p>1. <b>Filogen√©tica:</b> Construcci√≥n de √°rboles evolutivos</p>
                            <p>2. <b>Taxonom√≠a:</b> Clasificaci√≥n de especies</p>
                            <p>3. <b>Expresi√≥n g√©nica:</b> Identificaci√≥n de patrones</p>
                            <p>4. <b>Tipificaci√≥n molecular:</b> Clasificaci√≥n de subtipos</p>
                        </div>`;
                    }
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    const isKMeans = p.algo === 'K-Means';
                    const k = p.k;
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    `;
                    
                    if(isKMeans) {
                        // Visualizaci√≥n K-Means
                        const kmeansDiv = document.createElement('div');
                        kmeansDiv.style.cssText = `
                            width: 500px;
                            height: 500px;
                            background: white;
                            border-radius: 10px;
                            padding: 20px;
                            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            position: relative;
                        `;
                        
                        // T√≠tulo
                        const title = document.createElement('div');
                        title.innerHTML = `<b style="color:#333; font-size:1rem;">K-Means Clustering (k=${k})</b>`;
                        title.style.cssText = 'margin-bottom: 15px; text-align: center;';
                        kmeansDiv.appendChild(title);
                        
                        // Ejes
                        const axisX = document.createElement('div');
                        axisX.style.cssText = `
                            position: absolute;
                            bottom: 20px;
                            left: 20px;
                            right: 20px;
                            border-top: 2px solid #333;
                            text-align: center;
                            padding-top: 5px;
                            font-size: 11px;
                            color: #333;
                        `;
                        axisX.textContent = 'Dimensi√≥n 1';
                        kmeansDiv.appendChild(axisX);
                        
                        const axisY = document.createElement('div');
                        axisY.style.cssText = `
                            position: absolute;
                            left: 20px;
                            top: 20px;
                            bottom: 40px;
                            border-left: 2px solid #333;
                            display: flex;
                            align-items: center;
                            padding-left: 5px;
                            font-size: 11px;
                            writing-mode: vertical-rl;
                            transform: rotate(180deg);
                            color: #333;
                        `;
                        axisY.textContent = 'Dimensi√≥n 2';
                        kmeansDiv.appendChild(axisY);
                        
                        // Colores para clusters
                        const colors = ['#007acc', '#4CAF50', '#FF9800', '#9C27B0', '#f44336', '#00BCD4'];
                        
                        // Crear centroides iniciales aleatorios
                        const centroids = [];
                        for(let i = 0; i < k; i++) {
                            centroids.push({
                                x: 20 + Math.random() * 60,
                                y: 20 + Math.random() * 60,
                                color: colors[i]
                            });
                        }
                        
                        // Crear puntos
                        const numPoints = 60;
                        for(let i = 0; i < numPoints; i++) {
                            // Generar punto con tendencia hacia alg√∫n centroide
                            const centroidIdx = Math.floor(Math.random() * k);
                            const centroid = centroids[centroidIdx];
                            
                            const x = centroid.x + (Math.random() - 0.5) * 30;
                            const y = centroid.y + (Math.random() - 0.5) * 30;
                            
                            const point = document.createElement('div');
                            point.className = 'dot';
                            point.style.left = x + '%';
                            point.style.top = y + '%';
                            point.style.backgroundColor = centroid.color;
                            point.style.borderColor = 'white';
                            
                            kmeansDiv.appendChild(point);
                        }
                        
                        // Dibujar centroides
                        centroids.forEach((centroid, idx) => {
                            const center = document.createElement('div');
                            center.className = 'cluster-center';
                            center.style.left = centroid.x + '%';
                            center.style.top = centroid.y + '%';
                            center.style.borderColor = centroid.color;
                            center.style.boxShadow = `0 0 0 3px ${centroid.color}33`;
                            center.dataset.tooltip = `Centroide ${idx + 1}<br>Cluster ${idx + 1}`;
                            center.onmouseover = showTooltip;
                            center.onmouseout = hideTooltip;
                            
                            kmeansDiv.appendChild(center);
                        });
                        
                        // Panel de informaci√≥n
                        const infoPanel = document.createElement('div');
                        infoPanel.style.cssText = `
                            position: absolute;
                            bottom: 20px;
                            right: 20px;
                            background: white;
                            padding: 10px 15px;
                            border-radius: 5px;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            font-size: 0.8rem;
                            color: #333;
                            border-left: 3px solid #007acc;
                        `;
                        infoPanel.innerHTML = `
                            <b>K-Means Info:</b><br>
                            ‚Ä¢ k = ${k} clusters<br>
                            ‚Ä¢ nstart = 25<br>
                            ‚Ä¢ Puntos = ${numPoints}<br>
                            ‚Ä¢ Converge en ~10 iteraciones
                        `;
                        kmeansDiv.appendChild(infoPanel);
                        
                        container.appendChild(kmeansDiv);
                    } else {
                        // Visualizaci√≥n clustering jer√°rquico
                        const hcDiv = document.createElement('div');
                        hcDiv.style.cssText = `
                            width: 600px;
                            height: 500px;
                            background: white;
                            border-radius: 10px;
                            padding: 20px;
                            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            position: relative;
                        `;
                        
                        // T√≠tulo
                        const title = document.createElement('div');
                        title.innerHTML = `<b style="color:#333; font-size:1rem;">Clustering Jer√°rquico - Dendrograma</b>`;
                        title.style.cssText = 'margin-bottom: 15px; text-align: center;';
                        hcDiv.appendChild(title);
                        
                        // Crear dendrograma SVG
                        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        svg.setAttribute('width', '100%');
                        svg.setAttribute('height', '80%');
                        
                        // Colores para clusters
                        const colors = ['#007acc', '#4CAF50', '#FF9800', '#9C27B0', '#f44336', '#00BCD4'];
                        
                        // Estructura del dendrograma
                        const dendrogramStructure = [
                            {level: 0, merge: [1, 2], height: 5},
                            {level: 1, merge: [3, 4], height: 15},
                            {level: 2, merge: [5, 6], height: 25},
                            {level: 3, merge: [1, 3], height: 40},
                            {level: 4, merge: [2, 5], height: 60}
                        ];
                        
                        // Posiciones de hojas
                        const leafPositions = [];
                        const numLeaves = 20;
                        const leafSpacing = 95 / (numLeaves - 1);
                        
                        for(let i = 0; i < numLeaves; i++) {
                            leafPositions.push({
                                x: 5 + i * leafSpacing,
                                y: 90,
                                cluster: Math.floor(i / (numLeaves/k))
                            });
                        }
                        
                        // Dibujar l√≠neas del dendrograma
                        dendrogramStructure.forEach(node => {
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            
                            // Posiciones aproximadas
                            const x1 = 20 + node.level * 15;
                            const x2 = 50 + node.level * 10;
                            const y1 = 30 + node.height;
                            const y2 = 70 - node.level * 5;
                            
                            line.setAttribute('x1', `${x1}%`);
                            line.setAttribute('y1', `${y1}%`);
                            line.setAttribute('x2', `${x2}%`);
                            line.setAttribute('y2', `${y2}%`);
                            line.setAttribute('stroke', '#666');
                            line.setAttribute('stroke-width', '2');
                            
                            svg.appendChild(line);
                        });
                        
                        // Dibujar hojas
                        leafPositions.forEach((leaf, idx) => {
                            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            circle.setAttribute('cx', `${leaf.x}%`);
                            circle.setAttribute('cy', `${leaf.y}%`);
                            circle.setAttribute('r', '3');
                            circle.setAttribute('fill', colors[leaf.cluster % colors.length]);
                            circle.setAttribute('stroke', '#333');
                            circle.setAttribute('stroke-width', '1');
                            
                            svg.appendChild(circle);
                        });
                        
                        // L√≠nea de corte
                        const cutLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        cutLine.setAttribute('x1', '5%');
                        cutLine.setAttribute('y1', `${100 - k * 10}%`);
                        cutLine.setAttribute('x2', '95%');
                        cutLine.setAttribute('y2', `${100 - k * 10}%`);
                        cutLine.setAttribute('stroke', '#f44336');
                        cutLine.setAttribute('stroke-width', '2');
                        cutLine.setAttribute('stroke-dasharray', '5,5');
                        svg.appendChild(cutLine);
                        
                        // Texto de corte
                        const cutText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        cutText.setAttribute('x', '50%');
                        cutText.setAttribute('y', `${100 - k * 10 - 2}%`);
                        cutText.setAttribute('text-anchor', 'middle');
                        cutText.setAttribute('fill', '#f44336');
                        cutText.setAttribute('font-size', '12');
                        cutText.textContent = `Corte: k=${k} clusters`;
                        svg.appendChild(cutText);
                        
                        hcDiv.appendChild(svg);
                        
                        // Panel de informaci√≥n
                        const infoPanel = document.createElement('div');
                        infoPanel.style.cssText = `
                            position: absolute;
                            bottom: 20px;
                            right: 20px;
                            background: white;
                            padding: 10px 15px;
                            border-radius: 5px;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            font-size: 0.8rem;
                            color: #333;
                            border-left: 3px solid #4CAF50;
                        `;
                        infoPanel.innerHTML = `
                            <b>Clustering Jer√°rquico:</b><br>
                            ‚Ä¢ M√©todo: ward.D2<br>
                            ‚Ä¢ k = ${k} clusters<br>
                            ‚Ä¢ Hojas: ${numLeaves}<br>
                            ‚Ä¢ Altura corte: ${(100 - k * 10).toFixed(0)}%
                        `;
                        hcDiv.appendChild(infoPanel);
                        
                        // Leyenda de colores
                        const legend = document.createElement('div');
                        legend.style.cssText = `
                            display: flex;
                            justify-content: center;
                            gap: 15px;
                            margin-top: 10px;
                        `;
                        
                        for(let i = 0; i < k; i++) {
                            const legendItem = document.createElement('div');
                            legendItem.style.cssText = `
                                display: flex;
                                align-items: center;
                                gap: 5px;
                                font-size: 0.8rem;
                            `;
                            
                            const colorBox = document.createElement('div');
                            colorBox.style.cssText = `
                                width: 12px;
                                height: 12px;
                                background: ${colors[i % colors.length]};
                                border-radius: 2px;
                            `;
                            
                            legendItem.appendChild(colorBox);
                            legendItem.appendChild(document.createTextNode(`Cluster ${i+1}`));
                            legend.appendChild(legendItem);
                        }
                        
                        hcDiv.appendChild(legend);
                        container.appendChild(hcDiv);
                    }
                    
                    div.appendChild(container);
                }
            },
            {
                id: 5,
                title: "Tema 5. Discriminante",
                desc: "LDA vs QDA",
                icon: "fa-columns",
                controls: [
                    {id: 'mod', type: 'select', label: 'Modelo', options: ['LDA (Lineal)', 'QDA (Cuadr√°tico)']},
                    {id: 'var', type: 'checkbox', label: 'Varianzas Desiguales', value: false}
                ],
                code: (p) => `
<span class="c-com"># TEMA 5: AN√ÅLISIS DISCRIMINANTE</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(MASS)
<span class="c-kwd">library</span>(ggplot2)
<span class="c-kwd">library</span>(klaR)

<span class="c-com"># 1. Datos simulados: diagn√≥stico basado en biomarcadores</span>
<span class="c-kwd">set.seed</span>(123)
n <- 100

<span class="c-com"># Grupo 1: Pacientes sanos (media baja, varianza baja)</span>
grupo1 <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">Biomarcador1</span> = <span class="c-fn">rnorm</span>(n/2, mean = 5, sd = 1),
  <span class="c-arg">Biomarcador2</span> = <span class="c-fn">rnorm</span>(n/2, mean = 5, sd = 1),
  <span class="c-arg">Diagnostico</span> = <span class="c-str">"Sano"</span>
)

<span class="c-com"># Grupo 2: Pacientes enfermos</span>
sd_grupo2 <- ${p.var ? 2.5 : 1}
grupo2 <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">Biomarcador1</span> = <span class="c-fn">rnorm</span>(n/2, mean = 8, sd = sd_grupo2),
  <span class="c-arg">Biomarcador2</span> = <span class="c-fn">rnorm</span>(n/2, mean = 8, sd = sd_grupo2),
  <span class="c-arg">Diagnostico</span> = <span class="c-str">"Enfermo"</span>
)

datos <- <span class="c-fn">rbind</span>(grupo1, grupo2)
datos<span class="c-var">$Diagnostico</span> <- <span class="c-fn">factor</span>(datos<span class="c-var">$Diagnostico</span>)

<span class="c-com"># 2. Divisi√≥n entrenamiento/prueba (70/30)</span>
train_idx <- <span class="c-fn">sample</span>(1:n, n * 0.7)
train <- datos[train_idx, ]
test  <- datos[-train_idx, ]

<span class="c-kwd">if</span> (<span class="c-str">"${p.mod}"</span> == <span class="c-str">"LDA (Lineal)"</span>) {
  
  <span class="c-com"># 3. LINEAR DISCRIMINANT ANALYSIS (LDA)</span>
  <span class="c-com"># Asume varianzas iguales entre grupos (homocedasticidad)</span>
  modelo_lda <- <span class="c-fn">lda</span>(
    Diagnostico ~ Biomarcador1 + Biomarcador2,
    <span class="c-arg">data</span> = train
  )
  
  <span class="c-com"># 4. Predicciones y evaluaci√≥n</span>
  pred_train <- <span class="c-fn">predict</span>(modelo_lda, train)
  pred_test  <- <span class="c-fn">predict</span>(modelo_lda, test)
  
  <span class="c-com"># 5. Matriz de confusi√≥n</span>
  <span class="c-kwd">library</span>(caret)
  cm_test <- <span class="c-fn">confusionMatrix</span>(pred_test<span class="c-var">$class</span>, test<span class="c-var">$Diagnostico</span>)
  
  <span class="c-fn">cat</span>(<span class="c-str">"=== LDA (Linear Discriminant Analysis) ===\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"Prior probabilities:\\n"</span>)
  <span class="c-fn">print</span>(modelo_lda<span class="c-var">$prior</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"\\nGroup means:\\n"</span>)
  <span class="c-fn">print</span>(modelo_lda<span class="c-var">$means</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"\\nAccuracy test:"</span>, <span class="c-fn">round</span>(cm_test<span class="c-var">$overall</span>[1], 3), <span class="c-str">"\\n"</span>)
  
  <span class="c-com"># 6. Visualizaci√≥n frontera lineal</span>
  <span class="c-com"># Crear grid para plot</span>
  grid <- <span class="c-fn">expand.grid</span>(
    <span class="c-arg">Biomarcador1</span> = <span class="c-fn">seq</span>(2, 12, length.out = 100),
    <span class="c-arg">Biomarcador2</span> = <span class="c-fn">seq</span>(2, 12, length.out = 100)
  )
  grid<span class="c-var">$Prediccion</span> <- <span class="c-fn">predict</span>(modelo_lda, grid)<span class="c-var">$class</span>
  
  ggplot(datos, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = Biomarcador1, <span class="c-arg">y</span> = Biomarcador2, 
                   <span class="c-arg">color</span> = Diagnostico)) +
    <span class="c-fn">geom_point</span>(<span class="c-arg">size</span> = 3, <span class="c-arg">alpha</span> = 0.7) +
    <span class="c-fn">geom_contour</span>(<span class="c-fn">aes</span>(<span class="c-arg">z</span> = <span class="c-fn">as.numeric</span>(Prediccion)), 
                  <span class="c-arg">data</span> = grid, <span class="c-arg">color</span> = <span class="c-str">"black"</span>, <span class="c-arg">lwd</span> = 1) +
    <span class="c-fn">theme_minimal</span>() +
    <span class="c-fn">ggtitle</span>(<span class="c-str">"LDA: Frontera Lineal de Decisi√≥n"</span>)
  
} <span class="c-kwd">else</span> {
  
  <span class="c-com"># 7. QUADRATIC DISCRIMINANT ANALYSIS (QDA)</span>
  <span class="c-com"># Permite varianzas diferentes entre grupos</span>
  modelo_qda <- <span class="c-fn">qda</span>(
    Diagnostico ~ Biomarcador1 + Biomarcador2,
    <span class="c-arg">data</span> = train
  )
  
  <span class="c-com"># 8. Predicciones y evaluaci√≥n</span>
  pred_train_qda <- <span class="c-fn">predict</span>(modelo_qda, train)
  pred_test_qda  <- <span class="c-fn">predict</span>(modelo_qda, test)
  
  cm_test_qda <- <span class="c-fn">confusionMatrix</span>(pred_test_qda<span class="c-var">$class</span>, test<span class="c-var">$Diagnostico</span>)
  
  <span class="c-fn">cat</span>(<span class="c-str">"=== QDA (Quadratic Discriminant Analysis) ===\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"Prior probabilities:\\n"</span>)
  <span class="c-fn">print</span>(modelo_qda<span class="c-var">$prior</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"\\nAccuracy test:"</span>, <span class="c-fn">round</span>(cm_test_qda<span class="c-var">$overall</span>[1], 3), <span class="c-str">"\\n"</span>)
  
  <span class="c-com"># 9. Visualizaci√≥n frontera cuadr√°tica</span>
  grid <- <span class="c-fn">expand.grid</span>(
    <span class="c-arg">Biomarcador1</span> = <span class="c-fn">seq</span>(2, 12, length.out = 100),
    <span class="c-arg">Biomarcador2</span> = <span class="c-fn">seq</span>(2, 12, length.out = 100)
  )
  grid<span class="c-var">$Prediccion</span> <- <span class="c-fn">predict</span>(modelo_qda, grid)<span class="c-var">$class</span>
  
  ggplot(datos, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = Biomarcador1, <span class="c-arg">y</span> = Biomarcador2, 
                   <span class="c-arg">color</span> = Diagnostico)) +
    <span class="c-fn">geom_point</span>(<span class="c-arg">size</span> = 3, <span class="c-arg">alpha</span> = 0.7) +
    <span class="c-fn">geom_contour</span>(<span class="c-fn">aes</span>(<span class="c-arg">z</span> = <span class="c-fn">as.numeric</span>(Prediccion)), 
                  <span class="c-arg">data</span> = grid, <span class="c-arg">color</span> = <span class="c-str">"black"</span>, <span class="c-arg">lwd</span> = 1) +
    <span class="c-fn">theme_minimal</span>() +
    <span class="c-fn">ggtitle</span>(<span class="c-str">"QDA: Frontera Cuadr√°tica de Decisi√≥n"</span>)
}

<span class="c-com"># 10. Comparativa LDA vs QDA</span>
<span class="c-fn">cat</span>(<span class="c-str">"\\n=== COMPARATIVA LDA vs QDA ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Situaci√≥n:"</span>, ${p.var ? <span class="c-str">"Varianzas DESIGUALES"</span> : <span class="c-str">"Varianzas iguales"</span>}, <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Modelo seleccionado:"</span>, <span class="c-str">"${p.mod}"</span>, <span class="c-str">"\\n"</span>)`,
                explain: (p) => {
                    const isLDA = p.mod === 'LDA (Lineal)';
                    const hasUnequalVariances = p.var;
                    
                    let warning = '';
                    if(isLDA && hasUnequalVariances) {
                        warning = `
                        <div class="exp-note" style="background: rgba(244, 67, 54, 0.1); border-left-color: #f44336;">
                            <i class="fas fa-exclamation-triangle"></i> <b>¬°ADVERTENCIA!</b>
                            <p>Est√°s usando LDA con datos de varianzas desiguales. LDA asume homocedasticidad, por lo que puede tener bajo rendimiento.</p>
                            <p><b>Recomendaci√≥n:</b> Usa QDA o transforma los datos.</p>
                        </div>`;
                    }
                    
                    if(isLDA) {
                        return warning + `
                        <div class="exp-highlight">
                            <b>üìê LDA (Linear Discriminant Analysis)</b>
                        </div>
                        
                        <p><b>Concepto:</b> M√©todo de clasificaci√≥n que proyecta los datos en una direcci√≥n que maximiza la separaci√≥n entre clases.</p>
                        
                        <p><b>Supuestos:</b></p>
                        <ul>
                            <li>üìè <b>Normalidad multivariada</b> por clase</li>
                            <li>‚öñÔ∏è <b>Homocedasticidad</b> (varianzas iguales)</li>
                            <li>üìä <b>Independencia</b> de observaciones</li>
                        </ul>
                        
                        <p><b>Funci√≥n discriminante lineal:</b></p>
                        <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                            Œ¥‚Çñ(x) = x·µÄŒ£‚Åª¬πŒº‚Çñ - ¬ΩŒº‚Çñ·µÄŒ£‚Åª¬πŒº‚Çñ + log(œÄ‚Çñ)
                        </p>
                        
                        <div class="exp-note">
                            <i class="fas fa-calculator"></i> <b>Interpretaci√≥n:</b>
                            <p>‚Ä¢ Œ£‚Åª¬π: Matriz de covarianza inversa (compartida)</p>
                            <p>‚Ä¢ Œº‚Çñ: Vector de medias de la clase k</p>
                            <p>‚Ä¢ œÄ‚Çñ: Probabilidad a priori de la clase k</p>
                        </div>
                        
                        <div class="exp-highlight">
                            <b>üéØ Objetivo de LDA:</b>
                            <p>Encontrar la combinaci√≥n lineal de caracter√≠sticas que maximice:</p>
                            <p style="text-align: center; color: #6a9955;">
                                J(w) = (w·µÄŒº‚ÇÅ - w·µÄŒº‚ÇÇ)¬≤ / (w·µÄŒ£w)
                            </p>
                            <p><b>Numerador:</b> Separaci√≥n entre medias</p>
                            <p><b>Denominador:</b> Varianza dentro de clases</p>
                        </div>
                        
                        <p><b>üöÄ Ventajas:</b></p>
                        <ul>
                            <li>‚ö° Computacionalmente eficiente</li>
                            <li>üéØ Robust a overfitting en alta dimensi√≥n</li>
                            <li>üìä Interpretaci√≥n probabil√≠stica directa</li>
                            <li>üîç Manejo natural de clases desbalanceadas</li>
                        </ul>
                        
                        <div class="exp-highlight">
                            <b>üß™ Aplicaci√≥n en diagn√≥stico m√©dico:</b>
                            <p>LDA es ideal cuando los biomarcadores tienen distribuciones normales y varianzas similares entre grupos de pacientes.</p>
                        </div>`;
                    } else {
                        return `
                        <div class="exp-highlight">
                            <b>üîÑ QDA (Quadratic Discriminant Analysis)</b>
                        </div>
                        
                        <p><b>Concepto:</b> Extensi√≥n de LDA que permite diferentes matrices de covarianza por clase.</p>
                        
                        <p><b>Supuestos:</b></p>
                        <ul>
                            <li>üìè <b>Normalidad multivariada</b> por clase</li>
                            <li>‚öñÔ∏è <b>Heterocedasticidad permitida</b></li>
                            <li>üìä <b>Independencia</b> de observaciones</li>
                        </ul>
                        
                        <p><b>Funci√≥n discriminante cuadr√°tica:</b></p>
                        <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                            Œ¥‚Çñ(x) = -¬Ωlog|Œ£‚Çñ| - ¬Ω(x-Œº‚Çñ)·µÄŒ£‚Çñ‚Åª¬π(x-Œº‚Çñ) + log(œÄ‚Çñ)
                        </p>
                        
                        ${hasUnequalVariances ? `
                        <div class="exp-note" style="background: rgba(76, 175, 80, 0.1); border-left-color: #4CAF50;">
                            <i class="fas fa-check-circle"></i> <b>¬°SITUACI√ìN IDEAL PARA QDA!</b>
                            <p>Los datos tienen varianzas diferentes entre clases. QDA modelar√° correctamente esta heterocedasticidad.</p>
                        </div>
                        ` : ''}
                        
                        <div class="exp-highlight">
                            <b>üìä Comparaci√≥n LDA vs QDA:</b>
                            <table style="width:100%; border-collapse: collapse; margin: 10px 0;">
                                <tr style="background: rgba(0,122,204,0.1);">
                                    <th style="padding: 8px; border: 1px solid #007acc;">Aspecto</th>
                                    <th style="padding: 8px; border: 1px solid #007acc;">LDA</th>
                                    <th style="padding: 8px; border: 1px solid #007acc;">QDA</th>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333;">Frontera</td>
                                    <td style="padding: 8px; border: 1px solid #333;">Lineal</td>
                                    <td style="padding: 8px; border: 1px solid #333;">Cuadr√°tica</td>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333;">Covarianzas</td>
                                    <td style="padding: 8px; border: 1px solid #333;">Compartida (Œ£)</td>
                                    <td style="padding: 8px; border: 1px solid #333;">Individual (Œ£‚Çñ)</td>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333;">Par√°metros</td>
                                    <td style="padding: 8px; border: 1px solid #333;">Kp + p(p+1)/2</td>
                                    <td style="padding: 8px; border: 1px solid #333;">K[p + p(p+1)/2]</td>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333;">Bias-Variance</td>
                                    <td style="padding: 8px; border: 1px solid #333;">Alto bias, baja varianza</td>
                                    <td style="padding: 8px; border: 1px solid #333;">Bajo bias, alta varianza</td>
                                </tr>
                            </table>
                        </div>
                        
                        <p><b>üìà Trade-off Bias-Variance:</b></p>
                        <p>‚Ä¢ <b>LDA:</b> Menos par√°metros ‚Üí m√°s bias, menos varianza ‚Üí mejor con pocos datos</p>
                        <p>‚Ä¢ <b>QDA:</b> M√°s par√°metros ‚Üí menos bias, m√°s varianza ‚Üí necesita m√°s datos</p>
                        
                        <div class="exp-highlight">
                            <b>üß¨ Aplicaci√≥n en sub-tipificaci√≥n de c√°ncer:</b>
                            <p>QDA es √∫til cuando diferentes subtipos tumorales tienen patrones de expresi√≥n g√©nica con varianzas distintas.</p>
                        </div>`;
                    }
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    const isLDA = p.mod === 'LDA (Lineal)';
                    const hasUnequalVariances = p.var;
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    `;
                    
                    const plotArea = document.createElement('div');
                    plotArea.style.cssText = `
                        width: 500px;
                        height: 500px;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        position: relative;
                    `;
                    
                    // T√≠tulo
                    const title = document.createElement('div');
                    title.innerHTML = `<b style="color:#333; font-size:1rem;">${isLDA ? 'LDA - Frontera Lineal' : 'QDA - Frontera Cuadr√°tica'}</b>`;
                    title.style.cssText = 'margin-bottom: 15px; text-align: center;';
                    plotArea.appendChild(title);
                    
                    // Ejes
                    const axisX = document.createElement('div');
                    axisX.style.cssText = `
                        position: absolute;
                        bottom: 20px;
                        left: 20px;
                        right: 20px;
                        border-top: 2px solid #333;
                        text-align: center;
                        padding-top: 5px;
                        font-size: 11px;
                        color: #333;
                    `;
                    axisX.textContent = 'Biomarcador 1';
                    plotArea.appendChild(axisX);
                    
                    const axisY = document.createElement('div');
                    axisY.style.cssText = `
                        position: absolute;
                        left: 20px;
                        top: 20px;
                        bottom: 40px;
                        border-left: 2px solid #333;
                        display: flex;
                        align-items: center;
                        padding-left: 5px;
                        font-size: 11px;
                        writing-mode: vertical-rl;
                        transform: rotate(180deg);
                        color: #333;
                    `;
                    axisY.textContent = 'Biomarcador 2';
                    plotArea.appendChild(axisY);
                    
                    // Par√°metros de los grupos
                    const group1 = {
                        meanX: 30,
                        meanY: 30,
                        color: '#007acc',
                        label: 'Sano'
                    };
                    
                    const group2 = {
                        meanX: 70,
                        meanY: 70,
                        color: '#f44336',
                        label: 'Enfermo'
                    };
                    
                    // Ajustar varianzas si es necesario
                    const spread1 = 15; // Grupo sano - varianza baja
                    const spread2 = hasUnequalVariances ? 30 : 15; // Grupo enfermo
                    
                    // Crear puntos para grupo 1 (sanos)
                    for(let i = 0; i < 25; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * spread1;
                        const x = group1.meanX + Math.cos(angle) * radius;
                        const y = group1.meanY + Math.sin(angle) * radius;
                        
                        const point = document.createElement('div');
                        point.className = 'dot';
                        point.style.left = x + '%';
                        point.style.top = y + '%';
                        point.style.backgroundColor = group1.color;
                        point.style.borderColor = 'white';
                        point.dataset.tooltip = `Grupo: ${group1.label}`;
                        point.onmouseover = showTooltip;
                        point.onmouseout = hideTooltip;
                        
                        plotArea.appendChild(point);
                    }
                    
                    // Crear puntos para grupo 2 (enfermos)
                    for(let i = 0; i < 25; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * spread2;
                        const x = group2.meanX + Math.cos(angle) * radius;
                        const y = group2.meanY + Math.sin(angle) * radius;
                        
                        const point = document.createElement('div');
                        point.className = 'dot';
                        point.style.left = x + '%';
                        point.style.top = y + '%';
                        point.style.backgroundColor = group2.color;
                        point.style.borderColor = 'white';
                        point.dataset.tooltip = `Grupo: ${group2.label}<br>Varianza: ${hasUnequalVariances ? 'Alta' : 'Normal'}`;
                        point.onmouseover = showTooltip;
                        point.onmouseout = hideTooltip;
                        
                        plotArea.appendChild(point);
                    }
                    
                    // Dibujar frontera de decisi√≥n
                    const boundary = document.createElement('div');
                    boundary.style.cssText = `
                        position: absolute;
                        pointer-events: none;
                    `;
                    
                    if(isLDA) {
                        // Frontera lineal (recta)
                        boundary.style.cssText += `
                            width: 120%;
                            height: 2px;
                            background: #333;
                            top: 50%;
                            left: -10%;
                            transform: rotate(-45deg);
                            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                        `;
                    } else {
                        // Frontera cuadr√°tica (curva)
                        boundary.style.cssText += `
                            width: 50%;
                            height: 50%;
                            border: 2px solid #333;
                            border-radius: 0 0 0 100%;
                            top: 25%;
                            left: 50%;
                            border-right: none;
                            border-top: none;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                        `;
                    }
                    
                    plotArea.appendChild(boundary);
                    
                    // Panel de informaci√≥n
                    const infoPanel = document.createElement('div');
                    const panelColor = isLDA ? '#007acc' : '#9C27B0';
                    infoPanel.style.cssText = `
                        position: absolute;
                        bottom: 20px;
                        right: 20px;
                        background: white;
                        padding: 10px 15px;
                        border-radius: 5px;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        font-size: 0.8rem;
                        color: #333;
                        border-left: 3px solid ${panelColor};
                    `;
                    
                    infoPanel.innerHTML = `
                        <b>${isLDA ? 'LDA' : 'QDA'} Config:</b><br>
                        ‚Ä¢ Modelo: ${isLDA ? 'Lineal' : 'Cuadr√°tico'}<br>
                        ‚Ä¢ Varianzas: ${hasUnequalVariances ? 'Desiguales' : 'Iguales'}<br>
                        ‚Ä¢ Grupos: 2 (50/50)<br>
                        ‚Ä¢ Puntos: 50 total
                    `;
                    
                    plotArea.appendChild(infoPanel);
                    
                    // Leyenda
                    const legend = document.createElement('div');
                    legend.style.cssText = `
                        position: absolute;
                        top: 20px;
                        left: 20px;
                        background: white;
                        padding: 10px 15px;
                        border-radius: 5px;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        font-size: 0.8rem;
                    `;
                    
                    legend.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                            <div style="width: 12px; height: 12px; border-radius: 50%; background: ${group1.color};"></div>
                            <span>${group1.label} (œÉ=${spread1})</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="width: 12px; height: 12px; border-radius: 50%; background: ${group2.color};"></div>
                            <span>${group2.label} (œÉ=${spread2})</span>
                        </div>
                    `;
                    
                    plotArea.appendChild(legend);
                    
                    container.appendChild(plotArea);
                    div.appendChild(container);
                }
            },
            {
                id: 6,
                title: "Tema 6. Superv. I (Tree/SVM)",
                desc: "√Årboles de Decisi√≥n y SVM",
                icon: "fa-tree",
                controls: [
                    {id: 'algo', type: 'select', label: 'Algoritmo', options: ['Arbol (Decision Tree)', 'SVM (Kernel Radial)']},
                    {id: 'param', type: 'range', label: 'Complejidad (cp / Cost)', min: 1, max: 20, val: 5, step: 1},
                    {id: 'depth', type: 'range', label: 'Profundidad M√°x', min: 1, max: 5, val: 3, step: 1}
                ],
                code: (p) => {
                    if(p.algo.startsWith('Arbol')) return `
<span class="c-com"># TEMA 6: √ÅRBOLES DE DECISI√ìN</span>
<span class="c-com"># ============================</span>

<span class="c-kwd">library</span>(caret)
<span class="c-kwd">library</span>(rpart)
<span class="c-kwd">library</span>(rpart.plot)

<span class="c-com"># 1. Preparar datos de ejemplo (C√°ncer de Mama)</span>
<span class="c-kwd">data</span>(<span class="c-str">"PimaIndiansDiabetes"</span>, package = <span class="c-str">"mlbench"</span>)
datos <- PimaIndiansDiabetes

<span class="c-com"># 2. Dividir en entrenamiento (70%) y prueba (30%)</span>
<span class="c-kwd">set.seed</span>(123)
indices <- <span class="c-fn">createDataPartition</span>(datos<span class="c-var">$diabetes</span>, 
                           <span class="c-arg">p</span> = 0.7, 
                           <span class="c-arg">list</span> = FALSE)
train <- datos[indices, ]
test  <- datos[-indices, ]

<span class="c-com"># 3. Configurar validaci√≥n cruzada (10-fold CV)</span>
ctrl <- <span class="c-fn">trainControl</span>(
  <span class="c-arg">method</span> = <span class="c-str">"cv"</span>,
  <span class="c-arg">number</span> = 10,
  <span class="c-arg">classProbs</span> = TRUE,
  <span class="c-arg">summaryFunction</span> = twoClassSummary
)

<span class="c-com"># 4. Entrenar √°rbol de decisi√≥n con par√°metro de complejidad</span>
cp_valor <- <span class="c-num">${(p.param/100).toFixed(3)}</span>
<span class="c-com"># cp controla la poda: valores m√°s altos = √°rbol m√°s simple</span>

modelo_arbol <- <span class="c-fn">train</span>(
  <span class="c-arg">diabetes</span> ~ .,
  <span class="c-arg">data</span> = train,
  <span class="c-arg">method</span> = <span class="c-str">"rpart"</span>,
  <span class="c-arg">trControl</span> = ctrl,
  <span class="c-arg">tuneGrid</span> = <span class="c-fn">data.frame</span>(<span class="c-arg">cp</span> = cp_valor),
  <span class="c-arg">control</span> = <span class="c-fn">rpart.control</span>(
    <span class="c-arg">maxdepth</span> = <span class="c-num">${p.depth}</span>,
    <span class="c-arg">minsplit</span> = 20,
    <span class="c-arg">minbucket</span> = 7
  ),
  <span class="c-arg">metric</span> = <span class="c-str">"ROC"</span>
)

<span class="c-com"># 5. Visualizar el √°rbol</span>
<span class="c-fn">rpart.plot</span>(modelo_arbol<span class="c-var">$finalModel</span>,
           <span class="c-arg">type</span> = 4,
           <span class="c-arg">extra</span> = 101,
           <span class="c-arg">box.palette</span> = <span class="c-str">"Blues"</span>,
           <span class="c-arg">shadow.col</span> = <span class="c-str">"gray"</span>,
           <span class="c-arg">nn</span> = TRUE)

<span class="c-com"># 6. Evaluar en datos de prueba</span>
predicciones <- <span class="c-fn">predict</span>(modelo_arbol, test)
matriz_conf <- <span class="c-fn">confusionMatrix</span>(predicciones, test<span class="c-var">$diabetes</span>)
<span class="c-fn">print</span>(matriz_conf)

<span class="c-com"># 7. Importancia de variables</span>
importancia <- <span class="c-fn">varImp</span>(modelo_arbol)
<span class="c-fn">plot</span>(importancia, <span class="c-arg">main</span> = <span class="c-str">"Importancia de Variables"</span>)`;
                    
                    return `
<span class="c-com"># TEMA 6: SVM (SUPPORT VECTOR MACHINES)</span>
<span class="c-com"># =======================================</span>

<span class="c-kwd">library</span>(caret)
<span class="c-kwd">library</span>(e1071)
<span class="c-kwd">library</span>(kernlab)

<span class="c-com"># 1. Preparar datos (mismo conjunto que para √°rboles)</span>
<span class="c-kwd">data</span>(<span class="c-str">"PimaIndiansDiabetes"</span>, package = <span class="c-str">"mlbench"</span>)
datos <- PimaIndiansDiabetes

<span class="c-kwd">set.seed</span>(123)
indices <- <span class="c-fn">createDataPartition</span>(datos<span class="c-var">$diabetes</span>, 
                           <span class="c-arg">p</span> = 0.7, 
                           <span class="c-arg">list</span> = FALSE)
train <- datos[indices, ]
test  <- datos[-indices, ]

<span class="c-com"># 2. Preprocesar: escalar variables para SVM</span>
<span class="c-com"># SVM es sensible a la escala de las variables</span>
preProc <- <span class="c-fn">preProcess</span>(train[, -9], <span class="c-arg">method</span> = <span class="c-str">"scale"</span>)
train_scaled <- <span class="c-fn">predict</span>(preProc, train)
test_scaled  <- <span class="c-fn">predict</span>(preProc, test)

<span class="c-com"># 3. Configurar validaci√≥n cruzada</span>
ctrl <- <span class="c-fn">trainControl</span>(
  <span class="c-arg">method</span> = <span class="c-str">"cv"</span>,
  <span class="c-arg">number</span> = 10,
  <span class="c-arg">classProbs</span> = TRUE,
  <span class="c-arg">summaryFunction</span> = twoClassSummary
)

<span class="c-com"># 4. Entrenar SVM con kernel radial</span>
<span class="c-com"># Cost (C) = ${p.param}: Controla el trade-off entre margen y errores</span>
<span class="c-com"># C alto = margen peque√±o, pocos errores (riesgo de overfitting)</span>
<span class="c-com"># C bajo = margen grande, m√°s errores permitidos</span>

modelo_svm <- <span class="c-fn">train</span>(
  <span class="c-arg">diabetes</span> ~ .,
  <span class="c-arg">data</span> = train_scaled,
  <span class="c-arg">method</span> = <span class="c-str">"svmRadial"</span>,
  <span class="c-arg">trControl</span> = ctrl,
  <span class="c-arg">tuneGrid</span> = <span class="c-fn">expand.grid</span>(
    <span class="c-arg">sigma</span> = 0.1,  <span class="c-com"># Par√°metro del kernel</span>
    <span class="c-arg">C</span> = <span class="c-num">${p.param}</span>      <span class="c-com"># Par√°metro de costo</span>
  ),
  <span class="c-arg">metric</span> = <span class="c-str">"ROC"</span>
)

<span class="c-com"># 5. Visualizar fronteras de decisi√≥n (2D)</span>
<span class="c-com"># Seleccionar dos variables para visualizaci√≥n</span>
plot_data <- train_scaled[, c(<span class="c-str">"glucose"</span>, <span class="c-str">"mass"</span>, <span class="c-str">"diabetes"</span>)]

<span class="c-kwd">library</span>(ggplot2)
ggplot(plot_data, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = glucose, <span class="c-arg">y</span> = mass, <span class="c-arg">color</span> = diabetes)) +
  <span class="c-fn">geom_point</span>(<span class="c-arg">size</span> = 3) +
  <span class="c-fn">stat_density2d</span>(<span class="c-arg">aes</span>(<span class="c-arg">fill</span> = diabetes), alpha = 0.3) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">ggtitle</span>(<span class="c-str">"Fronteras de Decisi√≥n SVM (Kernel Radial)"</span>)

<span class="c-com"># 6. Evaluar modelo</span>
pred_svm <- <span class="c-fn">predict</span>(modelo_svm, test_scaled)
matriz_svm <- <span class="c-fn">confusionMatrix</span>(pred_svm, test_scaled<span class="c-var">$diabetes</span>)
<span class="c-fn">print</span>(matriz_svm)

<span class="c-com"># 7. Comparar con √°rbol</span>
<span class="c-fn">cat</span>(<span class="c-str">"\\n=== COMPARACI√ìN √ÅRBOL vs SVM ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"√Årbol: "</span>, <span class="c-fn">round</span>(matriz_conf<span class="c-var">$overall</span>[1], 3), 
    <span class="c-str">" accuracy\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"SVM:   "</span>, <span class="c-fn">round</span>(matriz_svm<span class="c-var">$overall</span>[1], 3), 
    <span class="c-str">" accuracy\\n"</span>)`;
                },
                explain: (p) => {
                    if(p.algo.startsWith('Arbol')) {
                        return `
                        <div class="exp-highlight">
                            <b>üå≥ √Årboles de Decisi√≥n (CART - Classification And Regression Trees)</b>
                        </div>
                        
                        <p><b>Concepto:</b> Divide recursivamente el espacio de caracter√≠sticas en regiones rectangulares.</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Par√°metros clave:</b><br>
                            ‚Ä¢ <b>cp = ${(p.param/100).toFixed(3)}</b>: Complexity Parameter. Controla la poda.<br>
                            ‚Ä¢ <b>maxdepth = ${p.depth}</b>: Profundidad m√°xima del √°rbol.<br>
                            ‚Ä¢ <b>minsplit = 20</b>: M√≠nimo de observaciones para dividir un nodo.<br>
                            ‚Ä¢ <b>minbucket = 7</b>: M√≠nimo de observaciones en un nodo terminal.
                        </div>
                        
                        <p><b>Ventajas:</b></p>
                        <ul>
                            <li>üìä F√°cil de interpretar y visualizar</li>
                            <li>‚ö° R√°pido entrenamiento y predicci√≥n</li>
                            <li>üîç Maneja tanto variables num√©ricas como categ√≥ricas</li>
                            <li>üìà No necesita escalado de variables</li>
                        </ul>
                        
                        <p><b>Limitaciones:</b></p>
                        <ul>
                            <li>‚ö†Ô∏è Propenso a overfitting (solucionable con poda)</li>
                            <li>üìè Fronteras de decisi√≥n paralelas a los ejes</li>
                            <li>üéØ Inestable: peque√±os cambios en datos generan √°rboles diferentes</li>
                        </ul>
                        
                        <div class="exp-highlight">
                            <b>üìà Interpretaci√≥n del √°rbol:</b>
                            <p>1. <b>Nodo ra√≠z:</b> Mejor divisi√≥n seg√∫n reducci√≥n de impureza (Gini/Entrop√≠a)</p>
                            <p>2. <b>Nodos internos:</b> Condiciones if-else sobre caracter√≠sticas</p>
                            <p>3. <b>Hojas:</b> Clase predicha y probabilidades</p>
                        </div>`;
                    } else {
                        return `
                        <div class="exp-highlight">
                            <b>‚ö° Support Vector Machines (SVM) - Kernel Radial</b>
                        </div>
                        
                        <p><b>Concepto:</b> Encuentra el hiperplano que maximiza el margen entre clases, usando kernel trick para espacios no lineales.</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Par√°metros clave:</b><br>
                            ‚Ä¢ <b>C = ${p.param}</b>: Par√°metro de regularizaci√≥n.<br>
                            ‚Ä¢ <b>œÉ = 0.1</b>: Par√°metro del kernel radial (ancho).<br>
                            ‚Ä¢ <b>Kernel:</b> Radial Basis Function (RBF).
                        </div>
                        
                        <p><b>Kernel Trick:</b> Mapea datos a espacio dimensional superior donde son linealmente separables:</p>
                        <p style="text-align: center; font-family: 'Fira Code', monospace; color: #6a9955;">
                            K(x, y) = exp(-Œ≥ ||x - y||¬≤)
                        </p>
                        
                        <p><b>Ventajas:</b></p>
                        <ul>
                            <li>üéØ Efectivo en espacios de alta dimensi√≥n</li>
                            <li>üîó Fronteras de decisi√≥n no lineales con kernels</li>
                            <li>üõ°Ô∏è Robustez contra overfitting (controlado por C)</li>
                            <li>‚≠ê Buen rendimiento con datos bien separados</li>
                        </ul>
                        
                        <p><b>Limitaciones:</b></p>
                        <ul>
                            <li>‚ö° Lento con grandes conjuntos de datos</li>
                            <li>üîß Necesita selecci√≥n cuidadosa de kernel y par√°metros</li>
                            <li>üìä Dificil interpretaci√≥n de modelos con kernel</li>
                            <li>‚öñÔ∏è Requiere escalado de variables</li>
                        </ul>
                        
                        <div class="exp-highlight">
                            <b>üéØ Trade-off Bias-Variance:</b>
                            <p>‚Ä¢ <b>C alto (${p.param > 10 ? 'ALTO' : 'MODERADO'}):</b> Margen peque√±o ‚Üí bajo bias, alta variance ‚Üí riesgo de overfitting</p>
                            <p>‚Ä¢ <b>C bajo (${p.param < 5 ? 'BAJO' : 'MODERADO'}):</b> Margen grande ‚Üí alto bias, baja variance ‚Üí riesgo de underfitting</p>
                        </div>`;
                    }
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    
                    if(p.algo.startsWith('Arbol')) {
                        // Visualizaci√≥n de √°rbol interactivo
                        const treeContainer = document.createElement('div');
                        treeContainer.style.cssText = `
                            width: 100%;
                            height: 100%;
                            position: relative;
                            background: white;
                            border-radius: 10px;
                            padding: 20px;
                            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        `;
                        
                        const title = document.createElement('div');
                        title.innerHTML = `<b style="color:#333; font-size:1.1rem;">√Årbol de Decisi√≥n - Visualizaci√≥n Interactiva</b>`;
                        title.style.cssText = 'margin-bottom: 20px; text-align: center;';
                        treeContainer.appendChild(title);
                        
                        // Nodos del √°rbol basados en profundidad
                        const depth = p.depth;
                        const cp = p.param / 100;
                        
                        // Crear estructura de √°rbol
                        const treeWidth = 600;
                        const treeHeight = 400;
                        const nodeWidth = 100;
                        const nodeHeight = 60;
                        
                        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        svg.setAttribute('width', '100%');
                        svg.setAttribute('height', '100%');
                        svg.setAttribute('viewBox', `0 0 ${treeWidth} ${treeHeight}`);
                        
                        // Definir posiciones de nodos
                        const nodePositions = [];
                        const levelHeight = treeHeight / (depth + 1);
                        
                        for(let level = 0; level <= depth; level++) {
                            const nodesAtLevel = Math.pow(2, level);
                            const levelY = (level + 1) * levelHeight;
                            
                            for(let i = 0; i < nodesAtLevel; i++) {
                                const x = (i + 0.5) * (treeWidth / nodesAtLevel);
                                const y = levelY;
                                nodePositions.push({x, y, level, index: i});
                            }
                        }
                        
                        // Dibujar conexiones
                        nodePositions.forEach((node, idx) => {
                            if(node.level < depth) {
                                // Calcular √≠ndices de hijos
                                const childIdx1 = idx * 2 + 1;
                                const childIdx2 = idx * 2 + 2;
                                
                                if(childIdx1 < nodePositions.length) {
                                    const child1 = nodePositions[childIdx1];
                                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                    line.setAttribute('x1', node.x);
                                    line.setAttribute('y1', node.y);
                                    line.setAttribute('x2', child1.x);
                                    line.setAttribute('y2', child1.y);
                                    line.setAttribute('stroke', '#666');
                                    line.setAttribute('stroke-width', '2');
                                    line.setAttribute('stroke-dasharray', cp > 0.15 ? 'none' : '5,5');
                                    svg.appendChild(line);
                                }
                                
                                if(childIdx2 < nodePositions.length) {
                                    const child2 = nodePositions[childIdx2];
                                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                    line.setAttribute('x1', node.x);
                                    line.setAttribute('y1', node.y);
                                    line.setAttribute('x2', child2.x);
                                    line.setAttribute('y2', child2.y);
                                    line.setAttribute('stroke', '#666');
                                    line.setAttribute('stroke-width', '2');
                                    line.setAttribute('stroke-dasharray', cp > 0.15 ? 'none' : '5,5');
                                    svg.appendChild(line);
                                }
                            }
                        });
                        
                        // Dibujar nodos
                        nodePositions.forEach((node, idx) => {
                            if(node.level <= depth) {
                                // Determinar si el nodo est√° podado (basado en cp)
                                const isPruned = node.level > 1 && Math.random() < cp;
                                
                                if(!isPruned || node.level === depth) {
                                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                                    
                                    // C√≠rculo del nodo
                                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                                    circle.setAttribute('cx', node.x);
                                    circle.setAttribute('cy', node.y);
                                    circle.setAttribute('r', node.level === 0 ? 25 : 20);
                                    circle.setAttribute('fill', node.level === 0 ? '#007acc' : 
                                                      node.level === depth ? '#4CAF50' : '#FF9800');
                                    circle.setAttribute('stroke', 'white');
                                    circle.setAttribute('stroke-width', '2');
                                    circle.setAttribute('class', 'tree-node-circle');
                                    circle.dataset.tooltip = `Nivel ${node.level} - ${node.level === depth ? 'Hoja' : 'Nodo Interno'}`;
                                    
                                    // Texto del nodo
                                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                    text.setAttribute('x', node.x);
                                    text.setAttribute('y', node.y + 5);
                                    text.setAttribute('text-anchor', 'middle');
                                    text.setAttribute('fill', 'white');
                                    text.setAttribute('font-size', '10');
                                    text.setAttribute('font-weight', 'bold');
                                    
                                    if(node.level === 0) {
                                        text.textContent = 'Glucose > 127';
                                    } else if(node.level === 1) {
                                        text.textContent = idx % 2 === 0 ? 'BMI ‚â§ 30' : 'Age > 50';
                                    } else if(node.level === depth) {
                                        text.textContent = idx % 2 === 0 ? 'Pos' : 'Neg';
                                    } else {
                                        text.textContent = 'Var X';
                                    }
                                    
                                    g.appendChild(circle);
                                    g.appendChild(text);
                                    svg.appendChild(g);
                                    
                                    // Agregar interactividad
                                    g.onmouseover = (e) => {
                                        const tooltip = document.getElementById('tooltip');
                                        tooltip.innerHTML = `
                                            <b>${node.level === 0 ? 'Nodo Ra√≠z' : node.level === depth ? 'Nodo Hoja' : 'Nodo Interno'}</b><br>
                                            Nivel: ${node.level}<br>
                                            Impureza: ${(Math.random() * 0.5 + 0.3).toFixed(2)}<br>
                                            Muestras: ${Math.round(Math.random() * 100 + 20)}
                                        `;
                                        tooltip.style.opacity = '1';
                                        tooltip.style.left = (e.pageX + 10) + 'px';
                                        tooltip.style.top = (e.pageY - 10) + 'px';
                                    };
                                    
                                    g.onmouseout = () => {
                                        document.getElementById('tooltip').style.opacity = '0';
                                    };
                                }
                            }
                        });
                        
                        treeContainer.appendChild(svg);
                        
                        // Leyenda
                        const legend = document.createElement('div');
                        legend.style.cssText = `
                            position: absolute;
                            bottom: 20px;
                            left: 20px;
                            background: white;
                            padding: 10px;
                            border-radius: 5px;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            font-size: 0.8rem;
                        `;
                        legend.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                                <div style="width: 12px; height: 12px; border-radius: 50%; background: #007acc;"></div>
                                <span>Nodo Ra√≠z</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                                <div style="width: 12px; height: 12px; border-radius: 50%; background: #FF9800;"></div>
                                <span>Nodos Internos</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div style="width: 12px; height: 12px; border-radius: 50%; background: #4CAF50;"></div>
                                <span>Nodos Hoja</span>
                            </div>
                        `;
                        treeContainer.appendChild(legend);
                        
                        // Estad√≠sticas
                        const stats = document.createElement('div');
                        stats.style.cssText = `
                            position: absolute;
                            bottom: 20px;
                            right: 20px;
                            background: white;
                            padding: 10px 15px;
                            border-radius: 5px;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            font-size: 0.8rem;
                            color: #333;
                        `;
                        stats.innerHTML = `
                            <b>Estad√≠sticas del √Årbol:</b><br>
                            ‚Ä¢ Profundidad: ${depth}<br>
                            ‚Ä¢ cp: ${cp.toFixed(3)}<br>
                            ‚Ä¢ Nodos totales: ${Math.pow(2, depth + 1) - 1}<br>
                            ‚Ä¢ Hojas: ${Math.pow(2, depth)}
                        `;
                        treeContainer.appendChild(stats);
                        
                        div.appendChild(treeContainer);
                    } else {
                        // Visualizaci√≥n de SVM
                        const svmContainer = document.createElement('div');
                        svmContainer.style.cssText = `
                            width: 100%;
                            height: 100%;
                            position: relative;
                            background: white;
                            border-radius: 10px;
                            padding: 20px;
                            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        `;
                        
                        const title = document.createElement('div');
                        title.innerHTML = `<b style="color:#333; font-size:1.1rem;">SVM - Fronteras de Decisi√≥n (Kernel Radial)</b>`;
                        title.style.cssText = 'margin-bottom: 20px; text-align: center;';
                        svmContainer.appendChild(title);
                        
                        // Crear gr√°fico de dispersi√≥n con frontera de decisi√≥n
                        const plotArea = document.createElement('div');
                        plotArea.style.cssText = `
                            width: 100%;
                            height: calc(100% - 100px);
                            position: relative;
                            background: #f8f9fa;
                            border-radius: 5px;
                            border: 1px solid #dee2e6;
                        `;
                        
                        // Ejes
                        const xAxis = document.createElement('div');
                        xAxis.style.cssText = `
                            position: absolute;
                            bottom: 0;
                            left: 40px;
                            right: 40px;
                            border-top: 2px solid #333;
                            text-align: center;
                            padding-top: 5px;
                            font-size: 12px;
                            color: #333;
                        `;
                        xAxis.textContent = 'Glucose (mg/dL)';
                        plotArea.appendChild(xAxis);
                        
                        const yAxis = document.createElement('div');
                        yAxis.style.cssText = `
                            position: absolute;
                            left: 0;
                            top: 40px;
                            bottom: 40px;
                            border-left: 2px solid #333;
                            display: flex;
                            align-items: center;
                            padding-left: 5px;
                            font-size: 12px;
                            writing-mode: vertical-rl;
                            transform: rotate(180deg);
                            color: #333;
                        `;
                        yAxis.textContent = 'BMI (kg/m¬≤)';
                        plotArea.appendChild(yAxis);
                        
                        // Frontera de decisi√≥n (c√≠rculos conc√©ntricos)
                        const cost = p.param;
                        const marginWidth = Math.max(5, 20 - cost); // Margen m√°s grande con C peque√±o
                        
                        for(let i = 0; i < 3; i++) {
                            const boundary = document.createElement('div');
                            boundary.className = 'svm-boundary';
                            boundary.style.cssText = `
                                position: absolute;
                                left: 50%;
                                top: 50%;
                                width: ${150 + i * 50}px;
                                height: ${150 + i * 50}px;
                                transform: translate(-50%, -50%);
                                border-color: ${i === 1 ? '#007acc' : 'rgba(0, 122, 204, 0.3)'};
                                border-width: ${i === 1 ? '3px' : '1px'};
                            `;
                            plotArea.appendChild(boundary);
                        }
                        
                        // Puntos de datos
                        const numPoints = 50;
                        const supportVectors = [];
                        
                        for(let i = 0; i < numPoints; i++) {
                            const isClass1 = Math.random() > 0.5;
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 80 + (isClass1 ? 0 : 40);
                            
                            const x = 50 + Math.cos(angle) * distance;
                            const y = 50 + Math.sin(angle) * distance;
                            
                            // Determinar si es vector de soporte (cercano al margen)
                            const distToMargin = Math.abs(distance - 60);
                            const isSupportVector = distToMargin < marginWidth && Math.random() > 0.7;
                            
                            if(isSupportVector) {
                                supportVectors.push({x, y, class: isClass1});
                            }
                            
                            const dot = document.createElement('div');
                            dot.className = 'dot';
                            dot.style.left = x + '%';
                            dot.style.top = y + '%';
                            dot.style.backgroundColor = isClass1 ? '#4CAF50' : '#f44336';
                            dot.style.borderColor = isSupportVector ? '#FFD700' : 'white';
                            dot.style.borderWidth = isSupportVector ? '3px' : '2px';
                            dot.style.boxShadow = isSupportVector ? '0 0 10px #FFD700' : '0 2px 4px rgba(0,0,0,0.2)';
                            dot.style.zIndex = isSupportVector ? '100' : '10';
                            
                            dot.dataset.tooltip = `Clase: ${isClass1 ? 'Positivo' : 'Negativo'}<br>
                                                  Glucose: ${Math.round(x * 2 + 70)}<br>
                                                  BMI: ${Math.round(y * 0.5 + 20)}<br>
                                                  ${isSupportVector ? '‚≠ê Vector de Soporte' : ''}`;
                            dot.onmouseover = showTooltip;
                            dot.onmouseout = hideTooltip;
                            
                            plotArea.appendChild(dot);
                        }
                        
                        // Destacar vectores de soporte
                        supportVectors.forEach(sv => {
                            const highlight = document.createElement('div');
                            highlight.style.cssText = `
                                position: absolute;
                                left: ${sv.x}%;
                                top: ${sv.y}%;
                                width: 25px;
                                height: 25px;
                                transform: translate(-50%, -50%);
                                border: 2px solid #FFD700;
                                border-radius: 50%;
                                animation: pulse 2s infinite;
                                pointer-events: none;
                            `;
                            plotArea.appendChild(highlight);
                        });
                        
                        svmContainer.appendChild(plotArea);
                        
                        // Panel de informaci√≥n
                        const infoPanel = document.createElement('div');
                        infoPanel.style.cssText = `
                            display: flex;
                            justify-content: space-between;
                            margin-top: 15px;
                            gap: 20px;
                        `;
                        
                        const costInfo = document.createElement('div');
                        costInfo.style.cssText = `
                            flex: 1;
                            background: ${cost > 15 ? '#ffebee' : cost > 10 ? '#fff3e0' : '#e8f5e8'};
                            padding: 10px;
                            border-radius: 5px;
                            border-left: 4px solid ${cost > 15 ? '#f44336' : cost > 10 ? '#FF9800' : '#4CAF50'};
                        `;
                        costInfo.innerHTML = `
                            <b>Par√°metro C = ${cost}</b><br>
                            <small>${cost > 15 ? 'Alto riesgo de overfitting' : 
                                    cost > 10 ? 'Balanceado' : 
                                    'Bajo riesgo de underfitting'}</small>
                        `;
                        
                        const svInfo = document.createElement('div');
                        svInfo.style.cssText = `
                            flex: 1;
                            background: #e3f2fd;
                            padding: 10px;
                            border-radius: 5px;
                            border-left: 4px solid #2196F3;
                        `;
                        svInfo.innerHTML = `
                            <b>Vectores de Soporte: ${supportVectors.length}</b><br>
                            <small>Puntos que definen el margen</small>
                        `;
                        
                        const kernelInfo = document.createElement('div');
                        kernelInfo.style.cssText = `
                            flex: 1;
                            background: #f3e5f5;
                            padding: 10px;
                            border-radius: 5px;
                            border-left: 4px solid #9C27B0;
                        `;
                        kernelInfo.innerHTML = `
                            <b>Kernel: RBF</b><br>
                            <small>œÉ = 0.1 (ancho del kernel)</small>
                        `;
                        
                        infoPanel.appendChild(costInfo);
                        infoPanel.appendChild(svInfo);
                        infoPanel.appendChild(kernelInfo);
                        svmContainer.appendChild(infoPanel);
                        
                        div.appendChild(svmContainer);
                    }
                }
            },
            {
                id: 7,
                title: "Tema 7. Superv. II (Ensemble)",
                desc: "Random Forest & Boosting",
                icon: "fa-layer-group",
                controls: [
                    {id: 'ntree', type: 'range', label: 'Num. √Årboles', min: 10, max: 500, val: 50},
                    {id: 'mtry', type: 'range', label: 'Variables por split', min: 1, max: 10, val: 3}
                ],
                code: (p) => `
<span class="c-com"># TEMA 7: M√âTODOS ENSEMBLE - RANDOM FOREST</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(randomForest)
<span class="c-kwd">library</span>(caret)
<span class="c-kwd">library</span>(ggplot2)

<span class="c-com"># 1. Datos de c√°ncer de mama (Wisconsin)</span>
<span class="c-kwd">data</span>(<span class="c-str">"BreastCancer"</span>, package = <span class="c-str">"mlbench"</span>)
datos <- BreastCancer[, -1]  <span class="c-com"># Eliminar ID</span>
datos <- <span class="c-fn">na.omit</span>(datos)  <span class="c-com"># Eliminar NAs</span>

<span class="c-com"># 2. Convertir variables a num√©ricas</span>
datos[, 1:9] <- <span class="c-fn">sapply</span>(datos[, 1:9], <span class="c-arg">as.numeric</span>)
datos<span class="c-var">$Class</span> <- <span class="c-fn">factor</span>(datos<span class="c-var">$Class</span>)

<span class="c-com"># 3. Divisi√≥n entrenamiento/prueba</span>
<span class="c-kwd">set.seed</span>(123)
indices <- <span class="c-fn">createDataPartition</span>(datos<span class="c-var">$Class</span>, <span class="c-arg">p</span> = 0.7, <span class="c-arg">list</span> = FALSE)
train <- datos[indices, ]
test  <- datos[-indices, ]

<span class="c-com"># 4. Configurar Random Forest</span>
ntrees <- <span class="c-num">${p.ntree}</span>
mtry_val <- <span class="c-num">${p.mtry}</span>

<span class="c-com"># 5. Entrenar Random Forest</span>
rf_model <- <span class="c-fn">randomForest</span>(
  Class ~ .,
  <span class="c-arg">data</span> = train,
  <span class="c-arg">ntree</span> = ntrees,
  <span class="c-arg">mtry</span> = mtry_val,
  <span class="c-arg">importance</span> = TRUE,
  <span class="c-arg">proximity</span> = TRUE,
  <span class="c-arg">na.action</span> = na.omit
)

<span class="c-com"># 6. Evaluar modelo</span>
rf_pred <- <span class="c-fn">predict</span>(rf_model, test)
rf_cm <- <span class="c-fn">confusionMatrix</span>(rf_pred, test<span class="c-var">$Class</span>)

<span class="c-fn">cat</span>(<span class="c-str">"=== RANDOM FOREST ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"N√∫mero √°rboles:"</span>, ntrees, <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"mtry (variables por split):"</span>, mtry_val, <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"OOB error:"</span>, <span class="c-fn">round</span>(rf_model<span class="c-var">$err.rate</span>[ntrees, 1], 4), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Accuracy test:"</span>, <span class="c-fn">round</span>(rf_cm<span class="c-var">$overall</span>[1], 3), <span class="c-str">"\\n"</span>)

<span class="c-com"># 7. Importancia de variables</span>
importance_df <- <span class="c-fn">as.data.frame</span>(rf_model<span class="c-var">$importance</span>)
importance_df<span class="c-var">$Variable</span> <- <span class="c-fn">rownames</span>(importance_df)

ggplot(importance_df, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = reorder(Variable, MeanDecreaseGini), 
                       <span class="c-arg">y</span> = MeanDecreaseGini)) +
  <span class="c-fn">geom_bar</span>(<span class="c-arg">stat</span> = <span class="c-str">"identity"</span>, <span class="c-arg">fill</span> = <span class="c-str">"steelblue"</span>) +
  <span class="c-fn">coord_flip</span>() +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">labs</span>(<span class="c-arg">title</span> = <span class="c-str">"Importancia de Variables (MeanDecreaseGini)"</span>,
       <span class="c-arg">x</span> = <span class="c-str">"Variable"</span>,
       <span class="c-arg">y</span> = <span class="c-str">"Mean Decrease Gini"</span>)

<span class="c-com"># 8. Error vs n√∫mero de √°rboles</span>
error_df <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">Trees</span> = 1:ntrees,
  <span class="c-arg">OOB_Error</span> = rf_model<span class="c-var">$err.rate</span>[,1]
)

ggplot(error_df, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = Trees, <span class="c-arg">y</span> = OOB_Error)) +
  <span class="c-fn">geom_line</span>(<span class="c-arg">color</span> = <span class="c-str">"steelblue"</span>, <span class="c-arg">lwd</span> = 1) +
  <span class="c-fn">geom_hline</span>(<span class="c-fn">aes</span>(<span class="c-arg">yintercept</span> = <span class="c-fn">min</span>(OOB_Error)), 
             <span class="c-arg">linetype</span> = <span class="c-str">"dashed"</span>, <span class="c-arg">color</span> = <span class="c-str">"red"</span>) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">labs</span>(<span class="c-arg">title</span> = <span class="c-str">"Error OOB vs N√∫mero de √Årboles"</span>,
       <span class="c-arg">x</span> = <span class="c-str">"N√∫mero de √Årboles"</span>,
       <span class="c-arg">y</span> = <span class="c-str">"Error OOB"</span>)

<span class="c-com"># 9. Comparar con √°rbol simple</span>
<span class="c-kwd">library</span>(rpart)
single_tree <- <span class="c-fn">rpart</span>(Class ~ ., <span class="c-arg">data</span> = train, <span class="c-arg">method</span> = <span class="c-str">"class"</span>)
tree_pred <- <span class="c-fn">predict</span>(single_tree, test, <span class="c-arg">type</span> = <span class="c-str">"class"</span>)
tree_cm <- <span class="c-fn">confusionMatrix</span>(tree_pred, test<span class="c-var">$Class</span>)

<span class="c-fn">cat</span>(<span class="c-str">"\\n=== COMPARACI√ìN √ÅRBOL SIMPLE vs RANDOM FOREST ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"√Årbol simple accuracy:"</span>, <span class="c-fn">round</span>(tree_cm<span class="c-var">$overall</span>[1], 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Random Forest accuracy:"</span>, <span class="c-fn">round</span>(rf_cm<span class="c-var">$overall</span>[1], 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Mejora:"</span>, <span class="c-fn">round</span>((rf_cm<span class="c-var">$overall</span>[1] - tree_cm<span class="c-var">$overall</span>[1]) * 100, 1), <span class="c-str">"%\\n"</span>)`,
                explain: (p) => {
                    return `
                        <div class="exp-highlight">
                            <b>üå≤ Random Forest - M√©todos Ensemble</b>
                        </div>
                        
                        <p><b>Concepto:</b> M√©todo de ensemble que combina m√∫ltiples √°rboles de decisi√≥n mediante bagging y aleatorizaci√≥n.</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Par√°metros clave:</b><br>
                            ‚Ä¢ <b>ntree = ${p.ntree}</b>: N√∫mero de √°rboles en el bosque<br>
                            ‚Ä¢ <b>mtry = ${p.mtry}</b>: Variables consideradas en cada split<br>
                            ‚Ä¢ <b>nodesize = 1</b>: Tama√±o m√≠nimo de nodos terminales<br>
                            ‚Ä¢ <b>maxnodes = NULL</b>: Sin l√≠mite de nodos
                        </div>
                        
                        <p><b>Dos fuentes de aleatorizaci√≥n:</b></p>
                        <p>1. <b>Bagging (Bootstrap Aggregating):</b> Muestreo con reemplazo de observaciones</p>
                        <p>2. <b>Feature Randomization:</b> Selecci√≥n aleatoria de variables en cada split</p>
                        
                        <div class="exp-highlight">
                            <b>üìä Error Out-of-Bag (OOB):</b>
                            <p>Error estimado usando observaciones no incluidas en el bootstrap sample de cada √°rbol.</p>
                            <p><b>Ventaja:</b> No necesita conjunto de validaci√≥n separado.</p>
                        </div>
                        
                        <p><b>Importancia de variables:</b></p>
                        <p>1. <b>MeanDecreaseAccuracy:</b> Reducci√≥n en accuracy al permutar la variable</p>
                        <p>2. <b>MeanDecreaseGini:</b> Reducci√≥n total en impureza (Gini) debida a la variable</p>
                        
                        <div class="exp-highlight">
                            <b>‚ö° Ventajas sobre √°rboles individuales:</b>
                            <p>‚Ä¢ üõ°Ô∏è <b>Reducci√≥n de varianza</b> (menos overfitting)</p>
                            <p>‚Ä¢ üîß <b>Robustez a outliers</b> y ruido</p>
                            <p>‚Ä¢ üìà <b>Mejor generalizaci√≥n</b></p>
                            <p>‚Ä¢ üéØ <b>Estimaci√≥n de importancia</b> de variables</p>
                            <p>‚Ä¢ üìä <b>Error OOB</b> para validaci√≥n</p>
                        </div>
                        
                        <p><b>üìâ Ley de rendimientos decrecientes:</b></p>
                        <p>El error OOB disminuye r√°pidamente al principio y luego se estabiliza. Con ${p.ntree} √°rboles:</p>
                        <p>‚Ä¢ ${p.ntree < 50 ? '‚ùå Muy pocos √°rboles: alta varianza' : 
                            p.ntree < 200 ? '‚úÖ Cantidad adecuada' : 
                            '‚ö†Ô∏è Muchos √°rboles: costo computacional innecesario'}</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-lightbulb"></i> <b>Regla pr√°ctica para mtry:</b>
                            <p>‚Ä¢ Clasificaci√≥n: mtry = ‚àöp (${p.mtry} variables)</p>
                            <p>‚Ä¢ Regresi√≥n: mtry = p/3</p>
                            <p>Donde p = n√∫mero total de variables predictoras</p>
                        </div>
                        
                        <div class="exp-highlight">
                            <b>üß¨ Aplicaci√≥n en GWAS y QTL mapping:</b>
                            <p>Random Forest es excelente para detectar interacciones g√©nicas (epistasis) en estudios de asociaci√≥n gen√≥mica.</p>
                        </div>`;
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        flex-direction: column;
                        gap: 20px;
                        padding: 20px;
                    `;
                    
                    // Secci√≥n superior: Visualizaci√≥n del bosque
                    const forestSection = document.createElement('div');
                    forestSection.style.cssText = `
                        flex: 2;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        position: relative;
                        overflow: hidden;
                    `;
                    
                    const forestTitle = document.createElement('div');
                    forestTitle.innerHTML = `<b style="color:#333; font-size:1rem;">Random Forest - ${p.ntree} √Årboles</b>`;
                    forestTitle.style.cssText = 'margin-bottom: 15px; text-align: center;';
                    forestSection.appendChild(forestTitle);
                    
                    // Crear representaci√≥n visual de m√∫ltiples √°rboles
                    const forestViz = document.createElement('div');
                    forestViz.style.cssText = `
                        width: 100%;
                        height: calc(100% - 40px);
                        position: relative;
                        display: flex;
                        flex-wrap: wrap;
                        gap: 10px;
                        justify-content: center;
                        align-items: center;
                    `;
                    
                    // Crear mini-√°rboles
                    const numTreesToShow = Math.min(p.ntree, 20); // M√°ximo 20 √°rboles visibles
                    const treeColors = ['#007acc', '#4CAF50', '#FF9800', '#9C27B0', '#00BCD4'];
                    
                    for(let i = 0; i < numTreesToShow; i++) {
                        const treeContainer = document.createElement('div');
                        treeContainer.style.cssText = `
                            width: ${100 / Math.ceil(Math.sqrt(numTreesToShow)) - 2}%;
                            height: ${100 / Math.ceil(Math.sqrt(numTreesToShow)) - 2}%;
                            position: relative;
                            border: 1px solid #dee2e6;
                            border-radius: 5px;
                            padding: 5px;
                            background: ${i % 2 === 0 ? '#f8f9fa' : 'white'};
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            justify-content: center;
                        `;
                        
                        // Representaci√≥n simplificada de un √°rbol
                        const treeSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        treeSvg.setAttribute('width', '100%');
                        treeSvg.setAttribute('height', '80%');
                        
                        // Dibujar √°rbol simplificado
                        const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line1.setAttribute('x1', '50%');
                        line1.setAttribute('y1', '20%');
                        line1.setAttribute('x2', '30%');
                        line1.setAttribute('y2', '50%');
                        line1.setAttribute('stroke', treeColors[i % treeColors.length]);
                        line1.setAttribute('stroke-width', '1');
                        
                        const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line2.setAttribute('x1', '50%');
                        line2.setAttribute('y1', '20%');
                        line2.setAttribute('x2', '70%');
                        line2.setAttribute('y2', '50%');
                        line2.setAttribute('stroke', treeColors[i % treeColors.length]);
                        line2.setAttribute('stroke-width', '1');
                        
                        const line3 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line3.setAttribute('x1', '30%');
                        line3.setAttribute('y1', '50%');
                        line3.setAttribute('x2', '20%');
                        line3.setAttribute('y2', '80%');
                        line3.setAttribute('stroke', treeColors[i % treeColors.length]);
                        line3.setAttribute('stroke-width', '1');
                        
                        const line4 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line4.setAttribute('x1', '30%');
                        line4.setAttribute('y1', '50%');
                        line4.setAttribute('x2', '40%');
                        line4.setAttribute('y2', '80%');
                        line4.setAttribute('stroke', treeColors[i % treeColors.length]);
                        line4.setAttribute('stroke-width', '1');
                        
                        const line5 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line5.setAttribute('x1', '70%');
                        line5.setAttribute('y1', '50%');
                        line5.setAttribute('x2', '60%');
                        line5.setAttribute('y2', '80%');
                        line5.setAttribute('stroke', treeColors[i % treeColors.length]);
                        line5.setAttribute('stroke-width', '1');
                        
                        const line6 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line6.setAttribute('x1', '70%');
                        line6.setAttribute('y1', '50%');
                        line6.setAttribute('x2', '80%');
                        line6.setAttribute('y2', '80%');
                        line6.setAttribute('stroke', treeColors[i % treeColors.length]);
                        line6.setAttribute('stroke-width', '1');
                        
                        treeSvg.appendChild(line1);
                        treeSvg.appendChild(line2);
                        treeSvg.appendChild(line3);
                        treeSvg.appendChild(line4);
                        treeSvg.appendChild(line5);
                        treeSvg.appendChild(line6);
                        
                        treeContainer.appendChild(treeSvg);
                        
                        // Etiqueta del √°rbol
                        const treeLabel = document.createElement('div');
                        treeLabel.style.cssText = `
                            font-size: 0.6rem;
                            color: #666;
                            text-align: center;
                            margin-top: 2px;
                        `;
                        treeLabel.textContent = `√Årbol ${i+1}`;
                        treeContainer.appendChild(treeLabel);
                        
                        forestViz.appendChild(treeContainer);
                    }
                    
                    forestSection.appendChild(forestViz);
                    
                    // Secci√≥n inferior: Importancia de variables y m√©tricas
                    const metricsSection = document.createElement('div');
                    metricsSection.style.cssText = `
                        flex: 1;
                        display: flex;
                        gap: 20px;
                    `;
                    
                    // Gr√°fico de importancia
                    const importanceDiv = document.createElement('div');
                    importanceDiv.style.cssText = `
                        flex: 2;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    `;
                    
                    const importanceTitle = document.createElement('div');
                    importanceTitle.innerHTML = `<b style="color:#333; font-size:0.9rem;">Importancia de Variables</b>`;
                    importanceTitle.style.cssText = 'margin-bottom: 15px; text-align: center;';
                    importanceDiv.appendChild(importanceTitle);
                    
                    // Barras de importancia
                    const barContainer = document.createElement('div');
                    barContainer.className = 'bar-container';
                    
                    const variables = [
                        {name: 'ClumpThickness', value: 95},
                        {name: 'CellSize', value: 88},
                        {name: 'CellShape', value: 85},
                        {name: 'MargAdhesion', value: 72},
                        {name: 'EpithCellSize', value: 68},
                        {name: 'BareNuclei', value: 65},
                        {name: 'BlandChromatin', value: 58},
                        {name: 'NormalNucleoli', value: 52},
                        {name: 'Mitoses', value: 45}
                    ];
                    
                    // A√±adir ruido basado en mtry
                    variables.forEach(v => {
                        v.value += (Math.random() - 0.5) * (10 - p.mtry);
                        v.value = Math.max(30, Math.min(100, v.value));
                    });
                    
                    // Ordenar por importancia
                    variables.sort((a, b) => b.value - a.value);
                    
                    variables.forEach(v => {
                        const barRow = document.createElement('div');
                        barRow.className = 'bar-row';
                        
                        const barLabel = document.createElement('div');
                        barLabel.className = 'bar-label';
                        barLabel.textContent = v.name;
                        
                        const barBg = document.createElement('div');
                        barBg.className = 'bar-bg';
                        
                        const barFill = document.createElement('div');
                        barFill.className = 'bar-fill';
                        barFill.style.width = '0%';
                        barFill.dataset.width = v.value;
                        
                        const barValue = document.createElement('div');
                        barValue.className = 'bar-value';
                        barValue.textContent = Math.round(v.value);
                        
                        barBg.appendChild(barFill);
                        barRow.appendChild(barLabel);
                        barRow.appendChild(barBg);
                        barRow.appendChild(barValue);
                        barContainer.appendChild(barRow);
                    });
                    
                    importanceDiv.appendChild(barContainer);
                    
                    // Panel de m√©tricas
                    const metricsDiv = document.createElement('div');
                    metricsDiv.style.cssText = `
                        flex: 1;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                    `;
                    
                    const metricsTitle = document.createElement('div');
                    metricsTitle.innerHTML = `<b style="color:#333; font-size:0.9rem;">M√©tricas del Modelo</b>`;
                    metricsTitle.style.cssText = 'margin-bottom: 15px; text-align: center;';
                    metricsDiv.appendChild(metricsTitle);
                    
                    const metricsContent = document.createElement('div');
                    metricsContent.style.cssText = `
                        display: flex;
                        flex-direction: column;
                        gap: 10px;
                    `;
                    
                    const nTreesMetric = document.createElement('div');
                    nTreesMetric.style.cssText = `
                        background: ${p.ntree < 50 ? '#fff3e0' : p.ntree < 200 ? '#e8f5e8' : '#e3f2fd'};
                        padding: 10px;
                        border-radius: 5px;
                        border-left: 4px solid ${p.ntree < 50 ? '#FF9800' : p.ntree < 200 ? '#4CAF50' : '#2196F3'};
                    `;
                    nTreesMetric.innerHTML = `
                        <b>√Årboles: ${p.ntree}</b><br>
                        <small>${p.ntree < 50 ? 'Pocos: alta varianza' : 
                                p.ntree < 200 ? '√ìptimo' : 
                                'Muchos: coste computacional'}</small>
                    `;
                    
                    const mtryMetric = document.createElement('div');
                    mtryMetric.style.cssText = `
                        background: ${p.mtry < 3 ? '#fff3e0' : p.mtry < 6 ? '#e8f5e8' : '#e3f2fd'};
                        padding: 10px;
                        border-radius: 5px;
                        border-left: 4px solid ${p.mtry < 3 ? '#FF9800' : p.mtry < 6 ? '#4CAF50' : '#2196F3'};
                    `;
                    mtryMetric.innerHTML = `
                        <b>mtry: ${p.mtry}</b><br>
                        <small>Variables por split</small>
                    `;
                    
                    const oobError = document.createElement('div');
                    const errorValue = 0.05 + (500 - p.ntree) / 5000;
                    oobError.style.cssText = `
                        background: ${errorValue > 0.1 ? '#ffebee' : errorValue > 0.05 ? '#fff3e0' : '#e8f5e8'};
                        padding: 10px;
                        border-radius: 5px;
                        border-left: 4px solid ${errorValue > 0.1 ? '#f44336' : errorValue > 0.05 ? '#FF9800' : '#4CAF50'};
                    `;
                    oobError.innerHTML = `
                        <b>Error OOB: ${errorValue.toFixed(4)}</b><br>
                        <small>Out-of-Bag error estimate</small>
                    `;
                    
                    const accuracy = document.createElement('div');
                    const accuracyValue = 0.95 - (500 - p.ntree) / 1000;
                    accuracy.style.cssText = `
                        background: ${accuracyValue < 0.85 ? '#ffebee' : accuracyValue < 0.9 ? '#fff3e0' : '#e8f5e8'};
                        padding: 10px;
                        border-radius: 5px;
                        border-left: 4px solid ${accuracyValue < 0.85 ? '#f44336' : accuracyValue < 0.9 ? '#FF9800' : '#4CAF50'};
                    `;
                    accuracy.innerHTML = `
                        <b>Accuracy: ${accuracyValue.toFixed(3)}</b><br>
                        <small>Precisi√≥n estimada</small>
                    `;
                    
                    metricsContent.appendChild(nTreesMetric);
                    metricsContent.appendChild(mtryMetric);
                    metricsContent.appendChild(oobError);
                    metricsContent.appendChild(accuracy);
                    metricsDiv.appendChild(metricsContent);
                    
                    metricsSection.appendChild(importanceDiv);
                    metricsSection.appendChild(metricsDiv);
                    
                    container.appendChild(forestSection);
                    container.appendChild(metricsSection);
                    div.appendChild(container);
                    
                    // Animar barras despu√©s de un delay
                    setTimeout(() => {
                        const fills = barContainer.querySelectorAll('.bar-fill');
                        fills.forEach(b => {
                            b.style.width = b.dataset.width + '%';
                        });
                    }, 100);
                }
            },
            {
                id: 8,
                title: "Tema 8. Evaluaci√≥n",
                desc: "ROC & Confusion Matrix",
                icon: "fa-check-double",
                controls: [
                    {id: 'th', type: 'range', label: 'Umbral Corte', min: 10, max: 90, val: 50},
                    {id: 'prevalence', type: 'range', label: 'Prevalencia (%)', min: 5, max: 50, val: 25}
                ],
                code: (p) => `
<span class="c-com"># TEMA 8: EVALUACI√ìN DE MODELOS - CURVA ROC</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(pROC)
<span class="c-kwd">library</span>(caret)
<span class="c-kwd">library</span>(ggplot2)
<span class="c-kwd">library</span>(plotROC)

<span class="c-com"># 1. Datos simulados: probabilidades predichas vs reales</span>
<span class="c-kwd">set.seed</span>(123)
n <- 200
prevalencia <- <span class="c-num">${p.prevalence / 100}</span>

<span class="c-com"># Generar etiquetas reales (con cierta prevalencia)</span>
y_real <- <span class="c-fn">c</span>(
  <span class="c-fn">rep</span>(0, <span class="c-fn">round</span>(n * (1 - prevalencia))),
  <span class="c-fn">rep</span>(1, <span class="c-fn">round</span>(n * prevalencia))
)

<span class="c-com"># Generar probabilidades predichas (con cierto grado de separaci√≥n)</span>
y_prob <- <span class="c-fn">c</span>(
  <span class="c-fn">rbeta</span>(<span class="c-fn">round</span>(n * (1 - prevalencia)), 2, 5),  <span class="c-com"># Clase 0</span>
  <span class="c-fn">rbeta</span>(<span class="c-fn">round</span>(n * prevalencia), 5, 2)     <span class="c-com"># Clase 1</span>
)

datos <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">real</span> = <span class="c-fn">factor</span>(y_real, <span class="c-arg">levels</span> = <span class="c-fn">c</span>(0, 1), <span class="c-arg">labels</span> = <span class="c-fn">c</span>(<span class="c-str">"Negativo"</span>, <span class="c-str">"Positivo"</span>)),
  <span class="c-arg">prob</span> = y_prob
)

<span class="c-com"># 2. Aplicar umbral de corte</span>
umbral <- <span class="c-num">${p.th / 100}</span>
datos<span class="c-var">$pred</span> <- <span class="c-fn">factor</span>(
  <span class="c-fn">ifelse</span>(datos<span class="c-var">$prob</span> > umbral, 1, 0),
  <span class="c-arg">levels</span> = <span class="c-fn">c</span>(0, 1),
  <span class="c-arg">labels</span> = <span class="c-fn">c</span>(<span class="c-str">"Negativo"</span>, <span class="c-str">"Positivo"</span>)
)

<span class="c-com"># 3. Matriz de confusi√≥n</span>
cm <- <span class="c-fn">confusionMatrix</span>(datos<span class="c-var">$pred</span>, datos<span class="c-var">$real</span>, <span class="c-arg">positive</span> = <span class="c-str">"Positivo"</span>)

<span class="c-fn">cat</span>(<span class="c-str">"=== MATRIZ DE CONFUSI√ìN ===\\n"</span>)
<span class="c-fn">print</span>(cm<span class="c-var">$table</span>)
<span class="c-fn">cat</span>(<span class="c-str">"\\n=== M√âTRICAS ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Umbral:"</span>, umbral, <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Accuracy:"</span>, <span class="c-fn">round</span>(cm<span class="c-var">$overall</span>[1], 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Sensitivity (Recall):"</span>, <span class="c-fn">round</span>(cm<span class="c-var">$byClass</span>[1], 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Specificity:"</span>, <span class="c-fn">round</span>(cm<span class="c-var">$byClass</span>[2], 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Precision (PPV):"</span>, <span class="c-fn">round</span>(cm<span class="c-var">$byClass</span>[3], 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"F1-Score:"</span>, <span class="c-fn">round</span>(cm<span class="c-var">$byClass</span>[7], 3), <span class="c-str">"\\n"</span>)

<span class="c-com"># 4. Curva ROC</span>
roc_obj <- <span class="c-fn">roc</span>(
  <span class="c-arg">response</span> = datos<span class="c-var">$real</span>,
  <span class="c-arg">predictor</span> = datos<span class="c-var">$prob</span>,
  <span class="c-arg">levels</span> = <span class="c-fn">c</span>(<span class="c-str">"Negativo"</span>, <span class="c-str">"Positivo"</span>),
  <span class="c-arg">direction</span> = <span class="c-str">"<"</span>
)

<span class="c-com"># 5. AUC y punto √≥ptimo (Youden's J statistic)</span>
auc_val <- <span class="c-fn">auc</span>(roc_obj)
optimal_point <- <span class="c-fn">coords</span>(
  roc_obj,
  <span class="c-arg">x</span> = <span class="c-str">"best"</span>,
  <span class="c-arg">ret</span> = <span class="c-fn">c</span>(<span class="c-str">"threshold"</span>, <span class="c-str">"specificity"</span>, <span class="c-str">"sensitivity"</span>)
)

<span class="c-fn">cat</span>(<span class="c-str">"\\n=== CURVA ROC ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"AUC:"</span>, <span class="c-fn">round</span>(auc_val, 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Punto √≥ptimo (Youden):\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"  Threshold:"</span>, <span class="c-fn">round</span>(optimal_point<span class="c-var">$threshold</span>, 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"  Sensitivity:"</span>, <span class="c-fn">round</span>(optimal_point<span class="c-var">$sensitivity</span>, 3), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"  Specificity:"</span>, <span class="c-fn">round</span>(optimal_point<span class="c-var">$specificity</span>, 3), <span class="c-str">"\\n"</span>)

<span class="c-com"># 6. Visualizaci√≥n curva ROC</span>
roc_plot <- <span class="c-fn">ggplot</span>(datos, <span class="c-fn">aes</span>(<span class="c-arg">d</span> = real, <span class="c-arg">m</span> = prob)) +
  <span class="c-fn">geom_roc</span>(<span class="c-arg">n.cuts</span> = 20, <span class="c-arg">labels</span> = FALSE) +
  <span class="c-fn">geom_abline</span>(<span class="c-arg">slope</span> = 1, <span class="c-arg">intercept</span> = 0, 
                <span class="c-arg">linetype</span> = <span class="c-str">"dashed"</span>, <span class="c-arg">alpha</span> = 0.7) +
  <span class="c-fn">geom_point</span>(<span class="c-arg">data</span> = <span class="c-fn">data.frame</span>(
    <span class="c-arg">x</span> = 1 - optimal_point<span class="c-var">$specificity</span>,
    <span class="c-arg">y</span> = optimal_point<span class="c-var">$sensitivity</span>
  ), <span class="c-fn">aes</span>(<span class="c-arg">x</span> = x, <span class="c-arg">y</span> = y), 
  <span class="c-arg">color</span> = <span class="c-str">"red"</span>, <span class="c-arg">size</span> = 3) +
  <span class="c-fn">geom_point</span>(<span class="c-arg">data</span> = <span class="c-fn">data.frame</span>(
    <span class="c-arg">x</span> = 1 - cm<span class="c-var">$byClass</span>[2],  <span class="c-com"># 1 - specificity</span>
    <span class="c-arg">y</span> = cm<span class="c-var">$byClass</span>[1]        <span class="c-com"># sensitivity</span>
  ), <span class="c-fn">aes</span>(<span class="c-arg">x</span> = x, <span class="c-arg">y</span> = y), 
  <span class="c-arg">color</span> = <span class="c-str">"blue"</span>, <span class="c-arg">size</span> = 3) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">labs</span>(<span class="c-arg">title</span> = <span class="c-str">"Curva ROC"</span>,
       <span class="c-arg">subtitle</span> = <span class="c-fn">paste</span>(<span class="c-str">"AUC ="</span>, <span class="c-fn">round</span>(auc_val, 3)),
       <span class="c-arg">x</span> = <span class="c-str">"1 - Specificity (False Positive Rate)"</span>,
       <span class="c-arg">y</span> = <span class="c-str">"Sensitivity (True Positive Rate)"</span>) +
  <span class="c-fn">annotate</span>(<span class="c-str">"text"</span>, <span class="c-arg">x</span> = 0.7, <span class="c-arg">y</span> = 0.3,
           <span class="c-arg">label</span> = <span class="c-fn">paste</span>(<span class="c-str">"Umbral actual:"</span>, umbral), 
           <span class="c-arg">color</span> = <span class="c-str">"blue"</span>) +
  <span class="c-fn">annotate</span>(<span class="c-str">"text"</span>, <span class="c-arg">x</span> = 0.7, <span class="c-arg">y</span> = 0.2,
           <span class="c-arg">label</span> = <span class="c-fn">paste</span>(<span class="c-str">"Umbral √≥ptimo:"</span>, <span class="c-fn">round</span>(optimal_point<span class="c-var">$threshold</span>, 3)), 
           <span class="c-arg">color</span> = <span class="c-str">"red"</span>)

<span class="c-com"># 7. Distribuci√≥n de probabilidades por clase</span>
dist_plot <- <span class="c-fn">ggplot</span>(datos, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = prob, <span class="c-arg">fill</span> = real)) +
  <span class="c-fn">geom_density</span>(<span class="c-arg">alpha</span> = 0.5) +
  <span class="c-fn">geom_vline</span>(<span class="c-arg">xintercept</span> = umbral, <span class="c-arg">linetype</span> = <span class="c-str">"dashed"</span>, <span class="c-arg">color</span> = <span class="c-str">"blue"</span>) +
  <span class="c-fn">geom_vline</span>(<span class="c-arg">xintercept</span> = optimal_point<span class="c-var">$threshold</span>, 
                <span class="c-arg">linetype</span> = <span class="c-str">"dashed"</span>, <span class="c-arg">color</span> = <span class="c-str">"red"</span>) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">labs</span>(<span class="c-arg">title</span> = <span class="c-str">"Distribuci√≥n de Probabilidades"</span>,
       <span class="c-arg">x</span> = <span class="c-str">"Probabilidad Predicha"</span>,
       <span class="c-arg">y</span> = <span class="c-str">"Densidad"</span>,
       <span class="c-arg">fill</span> = <span class="c-str">"Clase Real"</span>)

<span class="c-com"># 8. Mostrar ambas visualizaciones</span>
<span class="c-fn">library</span>(gridExtra)
<span class="c-fn">grid.arrange</span>(roc_plot, dist_plot, <span class="c-arg">ncol</span> = 2)`,
                explain: (p) => {
                    const threshold = p.th / 100;
                    const prevalence = p.prevalence / 100;
                    
                    return `
                        <div class="exp-highlight">
                            <b>üìä Evaluaci√≥n de Modelos de Clasificaci√≥n</b>
                        </div>
                        
                        <p><b>Concepto:</b> Medir el rendimiento de un modelo de clasificaci√≥n usando diversas m√©tricas y visualizaciones.</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Par√°metros:</b><br>
                            ‚Ä¢ <b>Umbral = ${threshold.toFixed(2)}</b>: Punto de corte para clasificaci√≥n<br>
                            ‚Ä¢ <b>Prevalencia = ${(prevalence * 100).toFixed(1)}%</b>: Proporci√≥n de casos positivos
                        </div>
                        
                        <div class="exp-highlight">
                            <b>üß© Matriz de Confusi√≥n (2√ó2):</b>
                            <table style="width:100%; border-collapse: collapse; margin: 10px 0;">
                                <tr style="background: rgba(0,122,204,0.1);">
                                    <th style="padding: 8px; border: 1px solid #007acc;"></th>
                                    <th style="padding: 8px; border: 1px solid #007acc;" colspan="2">Real</th>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333;"></td>
                                    <td style="padding: 8px; border: 1px solid #333; background: #e8f5e8;">Positivo</td>
                                    <td style="padding: 8px; border: 1px solid #333; background: #ffebee;">Negativo</td>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333; background: #e8f5e8;">Positivo</td>
                                    <td style="padding: 8px; border: 1px solid #333; text-align: center;">TP</td>
                                    <td style="padding: 8px; border: 1px solid #333; text-align: center;">FP</td>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333; background: #ffebee;">Negativo</td>
                                    <td style="padding: 8px; border: 1px solid #333; text-align: center;">FN</td>
                                    <td style="padding: 8px; border: 1px solid #333; text-align: center;">TN</td>
                                </tr>
                            </table>
                        </div>
                        
                        <p><b>M√©tricas derivadas:</b></p>
                        <p>‚Ä¢ <b>Accuracy</b> = (TP+TN)/(TP+FP+FN+TN) ‚Üí Exactitud global</p>
                        <p>‚Ä¢ <b>Sensitivity/Recall</b> = TP/(TP+FN) ‚Üí Capacidad de detectar positivos</p>
                        <p>‚Ä¢ <b>Specificity</b> = TN/(TN+FP) ‚Üí Capacidad de detectar negativos</p>
                        <p>‚Ä¢ <b>Precision</b> = TP/(TP+FP) ‚Üí Calidad de predicciones positivas</p>
                        <p>‚Ä¢ <b>F1-Score</b> = 2√ó(Precision√óRecall)/(Precision+Recall) ‚Üí Media arm√≥nica</p>
                        
                        <div class="exp-highlight">
                            <b>üìà Curva ROC (Receiver Operating Characteristic)</b>
                            <p>Grafica Sensitivity (TPR) vs 1-Specificity (FPR) para todos los umbrales posibles.</p>
                        </div>
                        
                        <p><b>Interpretaci√≥n ROC:</b></p>
                        <p>‚Ä¢ <b>AUC = 0.5</b>: Modelo aleatorio (diagonal)</p>
                        <p>‚Ä¢ <b>AUC = 0.7-0.8</b>: Modelo aceptable</p>
                        <p>‚Ä¢ <b>AUC = 0.8-0.9</b>: Modelo bueno</p>
                        <p>‚Ä¢ <b>AUC > 0.9</b>: Modelo excelente</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-balance-scale"></i> <b>Trade-off Sensibilidad vs Especificidad:</b>
                            <p>‚Ä¢ <b>Umbral bajo (${threshold < 0.3 ? '‚Üì' : '‚Üë'})</b>: Alta sensibilidad, baja especificidad ‚Üí muchos FP</p>
                            <p>‚Ä¢ <b>Umbral alto (${threshold > 0.7 ? '‚Üë' : '‚Üì'})</b>: Baja sensibilidad, alta especificidad ‚Üí muchos FN</p>
                            <p>‚Ä¢ <b>Umbral √≥ptimo</b>: Maximiza J = Sensitivity + Specificity - 1 (Youden's J)</p>
                        </div>
                        
                        <div class="exp-highlight">
                            <b>üéØ Contexto cl√≠nico:</b>
                            <p>La elecci√≥n del umbral depende del costo de los errores:</p>
                            <p>‚Ä¢ <b>Cribado</b>: Umbral bajo ‚Üí no pasar por alto casos (alta sensibilidad)</p>
                            <p>‚Ä¢ <b>Confirmaci√≥n</b>: Umbral alto ‚Üí evitar falsos positivos (alta especificidad)</p>
                        </div>
                        
                        <p><b>üìä Prevalencia y valor predictivo:</b></p>
                            <p>‚Ä¢ <b>PPV</b> (Positive Predictive Value) = TP/(TP+FP) ‚Üí depende de prevalencia</p>
                            <p>‚Ä¢ <b>NPV</b> (Negative Predictive Value) = TN/(TN+FN) ‚Üí depende de prevalencia</p>
                            <p>Con prevalencia ${(prevalence * 100).toFixed(1)}%, incluso un test perfecto tiene limitaciones en PPV.</p>`;
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        flex-direction: column;
                        gap: 20px;
                        padding: 20px;
                    `;
                    
                    // Secci√≥n superior: Matriz de confusi√≥n
                    const matrixSection = document.createElement('div');
                    matrixSection.style.cssText = `
                        flex: 1;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                    `;
                    
                    const matrixTitle = document.createElement('div');
                    matrixTitle.innerHTML = `<b style="color:#333; font-size:1rem;">Matriz de Confusi√≥n</b>`;
                    matrixTitle.style.cssText = 'margin-bottom: 20px; text-align: center;';
                    matrixSection.appendChild(matrixTitle);
                    
                    // Crear matriz de confusi√≥n
                    const confusionMatrix = document.createElement('div');
                    confusionMatrix.style.cssText = `
                        display: grid;
                        grid-template-columns: 100px 150px 150px;
                        grid-template-rows: 50px 150px 150px;
                        gap: 2px;
                        margin-bottom: 20px;
                    `;
                    
                    // Cabeceras
                    const emptyCell = document.createElement('div');
                    emptyCell.style.cssText = 'background: #f8f9fa; border: 1px solid #dee2e6; display: flex; align-items: center; justify-content: center;';
                    
                    const realPosHeader = document.createElement('div');
                    realPosHeader.style.cssText = 'background: #e8f5e8; border: 1px solid #dee2e6; display: flex; align-items: center; justify-content: center; font-weight: bold;';
                    realPosHeader.textContent = 'Real Positivo';
                    
                    const realNegHeader = document.createElement('div');
                    realNegHeader.style.cssText = 'background: #ffebee; border: 1px solid #dee2e6; display: flex; align-items: center; justify-content: center; font-weight: bold;';
                    realNegHeader.textContent = 'Real Negativo';
                    
                    const predPosHeader = document.createElement('div');
                    predPosHeader.style.cssText = 'background: #e8f5e8; border: 1px solid #dee2e6; display: flex; align-items: center; justify-content: center; font-weight: bold; writing-mode: vertical-rl; transform: rotate(180deg);';
                    predPosHeader.textContent = 'Predicho Positivo';
                    
                    const predNegHeader = document.createElement('div');
                    predNegHeader.style.cssText = 'background: #ffebee; border: 1px solid #dee2e6; display: flex; align-items: center; justify-content: center; font-weight: bold; writing-mode: vertical-rl; transform: rotate(180deg);';
                    predNegHeader.textContent = 'Predicho Negativo';
                    
                    // Calcular valores basados en el umbral y prevalencia
                    const prevalence = p.prevalence / 100;
                    const threshold = p.th / 100;
                    
                    // Simular valores
                    const total = 200;
                    const realPos = Math.round(total * prevalence);
                    const realNeg = total - realPos;
                    
                    // TP: correctamente predicho como positivo (depende del umbral)
                    const tp = Math.round(realPos * (0.8 - (threshold - 0.5) * 0.6));
                    const fn = realPos - tp;
                    
                    // TN: correctamente predicho como negativo
                    const tn = Math.round(realNeg * (0.7 + (threshold - 0.5) * 0.6));
                    const fp = realNeg - tn;
                    
                    // Celdas de la matriz
                    const tpCell = document.createElement('div');
                    tpCell.style.cssText = 'background: #c8e6c9; border: 1px solid #dee2e6; display: flex; flex-direction: column; align-items: center; justify-content: center;';
                    tpCell.innerHTML = `<b style="font-size: 1.5rem;">${tp}</b><div style="font-size: 0.8rem;">TP</div>`;
                    
                    const fpCell = document.createElement('div');
                    fpCell.style.cssText = 'background: #ffcdd2; border: 1px solid #dee2e6; display: flex; flex-direction: column; align-items: center; justify-content: center;';
                    fpCell.innerHTML = `<b style="font-size: 1.5rem;">${fp}</b><div style="font-size: 0.8rem;">FP</div>`;
                    
                    const fnCell = document.createElement('div');
                    fnCell.style.cssText = 'background: #ffcdd2; border: 1px solid #dee2e6; display: flex; flex-direction: column; align-items: center; justify-content: center;';
                    fnCell.innerHTML = `<b style="font-size: 1.5rem;">${fn}</b><div style="font-size: 0.8rem;">FN</div>`;
                    
                    const tnCell = document.createElement('div');
                    tnCell.style.cssText = 'background: #c8e6c9; border: 1px solid #dee2e6; display: flex; flex-direction: column; align-items: center; justify-content: center;';
                    tnCell.innerHTML = `<b style="font-size: 1.5rem;">${tn}</b><div style="font-size: 0.8rem;">TN</div>`;
                    
                    // Construir grid
                    confusionMatrix.appendChild(emptyCell.cloneNode());
                    confusionMatrix.appendChild(realPosHeader);
                    confusionMatrix.appendChild(realNegHeader);
                    
                    confusionMatrix.appendChild(predPosHeader);
                    confusionMatrix.appendChild(tpCell);
                    confusionMatrix.appendChild(fpCell);
                    
                    confusionMatrix.appendChild(predNegHeader);
                    confusionMatrix.appendChild(fnCell);
                    confusionMatrix.appendChild(tnCell);
                    
                    matrixSection.appendChild(confusionMatrix);
                    
                    // M√©tricas calculadas
                    const accuracy = (tp + tn) / total;
                    const sensitivity = tp / realPos;
                    const specificity = tn / realNeg;
                    const precision = tp / (tp + fp);
                    const f1 = 2 * (precision * sensitivity) / (precision + sensitivity);
                    
                    const metricsDiv = document.createElement('div');
                    metricsDiv.style.cssText = `
                        display: flex;
                        gap: 15px;
                        flex-wrap: wrap;
                        justify-content: center;
                    `;
                    
                    const createMetricBox = (label, value, color) => {
                        const box = document.createElement('div');
                        box.style.cssText = `
                            background: ${color}20;
                            border-left: 4px solid ${color};
                            padding: 10px 15px;
                            border-radius: 5px;
                            min-width: 120px;
                            text-align: center;
                        `;
                        box.innerHTML = `
                            <div style="font-size: 0.8rem; color: #666;">${label}</div>
                            <div style="font-size: 1.2rem; font-weight: bold; color: ${color};">${value.toFixed(3)}</div>
                        `;
                        return box;
                    };
                    
                    metricsDiv.appendChild(createMetricBox('Accuracy', accuracy, '#4CAF50'));
                    metricsDiv.appendChild(createMetricBox('Sensitivity', sensitivity, '#2196F3'));
                    metricsDiv.appendChild(createMetricBox('Specificity', specificity, '#FF9800'));
                    metricsDiv.appendChild(createMetricBox('Precision', precision, '#9C27B0'));
                    metricsDiv.appendChild(createMetricBox('F1-Score', f1, '#00BCD4'));
                    
                    matrixSection.appendChild(metricsDiv);
                    
                    // Secci√≥n inferior: Curva ROC
                    const rocSection = document.createElement('div');
                    rocSection.style.cssText = `
                        flex: 1;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        position: relative;
                    `;
                    
                    const rocTitle = document.createElement('div');
                    rocTitle.innerHTML = `<b style="color:#333; font-size:1rem;">Curva ROC - Umbral: ${threshold.toFixed(2)}</b>`;
                    rocTitle.style.cssText = 'margin-bottom: 20px; text-align: center;';
                    rocSection.appendChild(rocTitle);
                    
                    // Crear SVG para la curva ROC
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', '80%');
                    
                    // Ejes
                    const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    xAxis.setAttribute('x1', '10%');
                    xAxis.setAttribute('y1', '90%');
                    xAxis.setAttribute('x2', '90%');
                    xAxis.setAttribute('y2', '90%');
                    xAxis.setAttribute('stroke', '#333');
                    xAxis.setAttribute('stroke-width', '2');
                    
                    const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    yAxis.setAttribute('x1', '10%');
                    yAxis.setAttribute('y1', '10%');
                    yAxis.setAttribute('x2', '10%');
                    yAxis.setAttribute('y2', '90%');
                    yAxis.setAttribute('stroke', '#333');
                    yAxis.setAttribute('stroke-width', '2');
                    
                    // L√≠nea diagonal (modelo aleatorio)
                    const diagonal = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    diagonal.setAttribute('x1', '10%');
                    diagonal.setAttribute('y1', '90%');
                    diagonal.setAttribute('x2', '90%');
                    diagonal.setAttribute('y2', '10%');
                    diagonal.setAttribute('stroke', '#999');
                    diagonal.setAttribute('stroke-width', '1');
                    diagonal.setAttribute('stroke-dasharray', '5,5');
                    
                    // Curva ROC
                    const rocCurve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let pathData = 'M 10% 90% '; // Comienza en (0,0) -> (10%,90%)
                    
                    // Generar puntos de la curva ROC
                    const points = [];
                    for(let i = 0; i <= 10; i++) {
                        const fpr = i / 10; // False Positive Rate
                        // AUC aproximada basada en el umbral
                        const baseAUC = 0.85 + (threshold - 0.5) * 0.1;
                        const tpr = 1 - Math.pow(1 - fpr, 1/baseAUC); // Curva ROC t√≠pica
                        
                        points.push({
                            x: 10 + fpr * 80,
                            y: 90 - tpr * 80
                        });
                        
                        pathData += `L ${10 + fpr * 80}% ${90 - tpr * 80}% `;
                    }
                    
                    rocCurve.setAttribute('d', pathData);
                    rocCurve.setAttribute('fill', 'none');
                    rocCurve.setAttribute('stroke', '#007acc');
                    rocCurve.setAttribute('stroke-width', '3');
                    
                    // Punto actual (basado en el umbral)
                    const currentFPR = 1 - specificity; // 1 - specificity
                    const currentTPR = sensitivity;
                    
                    const currentPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    currentPoint.setAttribute('cx', `${10 + currentFPR * 80}%`);
                    currentPoint.setAttribute('cy', `${90 - currentTPR * 80}%`);
                    currentPoint.setAttribute('r', '6');
                    currentPoint.setAttribute('fill', '#2196F3');
                    currentPoint.setAttribute('stroke', 'white');
                    currentPoint.setAttribute('stroke-width', '2');
                    
                    // Punto √≥ptimo (Youden)
                    const optimalFPR = 0.2; // Ejemplo
                    const optimalTPR = 0.8; // Ejemplo
                    
                    const optimalPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    optimalPoint.setAttribute('cx', `${10 + optimalFPR * 80}%`);
                    optimalPoint.setAttribute('cy', `${90 - optimalTPR * 80}%`);
                    optimalPoint.setAttribute('r', '6');
                    optimalPoint.setAttribute('fill', '#f44336');
                    optimalPoint.setAttribute('stroke', 'white');
                    optimalPoint.setAttribute('stroke-width', '2');
                    
                    // Etiquetas
                    const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    xLabel.setAttribute('x', '50%');
                    xLabel.setAttribute('y', '95%');
                    xLabel.setAttribute('text-anchor', 'middle');
                    xLabel.setAttribute('fill', '#333');
                    xLabel.setAttribute('font-size', '12');
                    xLabel.textContent = '1 - Specificity (False Positive Rate)';
                    
                    const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    yLabel.setAttribute('x', '5%');
                    yLabel.setAttribute('y', '50%');
                    yLabel.setAttribute('text-anchor', 'middle');
                    yLabel.setAttribute('fill', '#333');
                    yLabel.setAttribute('font-size', '12');
                    yLabel.setAttribute('transform', 'rotate(-90 5,50)');
                    yLabel.textContent = 'Sensitivity (True Positive Rate)';
                    
                    const aucText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    aucText.setAttribute('x', '70%');
                    aucText.setAttribute('y', '30%');
                    aucText.setAttribute('text-anchor', 'middle');
                    aucText.setAttribute('fill', '#007acc');
                    aucText.setAttribute('font-size', '14');
                    aucText.setAttribute('font-weight', 'bold');
                    aucText.textContent = `AUC = ${(0.85 + (threshold - 0.5) * 0.1).toFixed(3)}`;
                    
                    // Leyenda
                    const legend = document.createElement('div');
                    legend.style.cssText = `
                        display: flex;
                        justify-content: center;
                        gap: 20px;
                        margin-top: 10px;
                    `;
                    
                    const currentLegend = document.createElement('div');
                    currentLegend.style.cssText = 'display: flex; align-items: center; gap: 5px; font-size: 0.8rem;';
                    currentLegend.innerHTML = `
                        <div style="width: 12px; height: 12px; border-radius: 50%; background: #2196F3;"></div>
                        <span>Umbral actual (${threshold.toFixed(2)})</span>
                    `;
                    
                    const optimalLegend = document.createElement('div');
                    optimalLegend.style.cssText = 'display: flex; align-items: center; gap: 5px; font-size: 0.8rem;';
                    optimalLegend.innerHTML = `
                        <div style="width: 12px; height: 12px; border-radius: 50%; background: #f44336;"></div>
                        <span>Umbral √≥ptimo (Youden)</span>
                    `;
                    
                    legend.appendChild(currentLegend);
                    legend.appendChild(optimalLegend);
                    
                    svg.appendChild(xAxis);
                    svg.appendChild(yAxis);
                    svg.appendChild(diagonal);
                    svg.appendChild(rocCurve);
                    svg.appendChild(currentPoint);
                    svg.appendChild(optimalPoint);
                    svg.appendChild(xLabel);
                    svg.appendChild(yLabel);
                    svg.appendChild(aucText);
                    
                    rocSection.appendChild(svg);
                    rocSection.appendChild(legend);
                    
                    container.appendChild(matrixSection);
                    container.appendChild(rocSection);
                    div.appendChild(container);
                }
            },
            {
                id: 9,
                title: "Tema 9. Deep Learning I",
                desc: "Arquitectura de Red",
                icon: "fa-network-wired",
                controls: [
                    {id: 'layers', type: 'range', label: 'Capas Ocultas', min: 0, max: 3, val: 1},
                    {id: 'act', type: 'select', label: 'Activaci√≥n', options: ['relu', 'sigmoid', 'tanh']},
                    {id: 'neurons', type: 'range', label: 'Neuronas por capa', min: 4, max: 32, val: 8}
                ],
                code: (p) => `
<span class="c-com"># TEMA 9: REDES NEURONALES - ARQUITECTURA</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(keras)
<span class="c-kwd">library</span>(tensorflow)
<span class="c-kwd">library</span>(ggplot2)

<span class="c-com"># 1. Configurar backend de TensorFlow</span>
<span class="c-fn">use_session_with_seed</span>(123)

<span class="c-com"># 2. Datos de ejemplo: MNIST (d√≠gitos manuscritos)</span>
mnist <- <span class="c-fn">dataset_mnist</span>()
x_train <- mnist<span class="c-var">$train</span><span class="c-var">$x</span>
y_train <- mnist<span class="c-var">$train</span><span class="c-var">$y</span>
x_test  <- mnist<span class="c-var">$test</span><span class="c-var">$x</span>
y_test  <- mnist<span class="c-var">$test</span><span class="c-var">$y</span>

<span class="c-com"># 3. Preprocesamiento</span>
<span class="c-com"># Redimensionar y normalizar</span>
x_train <- <span class="c-fn">array_reshape</span>(x_train, <span class="c-fn">c</span>(<span class="c-fn">nrow</span>(x_train), 784)) / 255
x_test  <- <span class="c-fn">array_reshape</span>(x_test, <span class="c-fn">c</span>(<span class="c-fn">nrow</span>(x_test), 784)) / 255

<span class="c-com"># Convertir etiquetas a one-hot encoding</span>
y_train <- <span class="c-fn">to_categorical</span>(y_train, 10)
y_test  <- <span class="c-fn">to_categorical</span>(y_test, 10)

<span class="c-com"># 4. Configurar arquitectura de la red</span>
n_layers <- <span class="c-num">${p.layers}</span>
activation <- <span class="c-str">"${p.act}"</span>
n_neurons <- <span class="c-num">${p.neurons}</span>

model <- <span class="c-fn">keras_model_sequential</span>()

<span class="c-com"># Capa de entrada</span>
model %>% 
  <span class="c-fn">layer_dense</span>(
    <span class="c-arg">units</span> = n_neurons,
    <span class="c-arg">activation</span> = activation,
    <span class="c-arg">input_shape</span> = <span class="c-fn">c</span>(784)
  )

<span class="c-com"># Capas ocultas adicionales</span>
<span class="c-kwd">if</span> (n_layers >= 1) {
  model %>% <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span> = n_neurons, <span class="c-arg">activation</span> = activation)
}

<span class="c-kwd">if</span> (n_layers >= 2) {
  model %>% <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span> = n_neurons, <span class="c-arg">activation</span> = activation)
}

<span class="c-kwd">if</span> (n_layers >= 3) {
  model %>% <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span> = n_neurons, <span class="c-arg">activation</span> = activation)
}

<span class="c-com"># Capa de salida (10 clases para d√≠gitos 0-9)</span>
model %>% 
  <span class="c-fn">layer_dense</span>(
    <span class="c-arg">units</span> = 10,
    <span class="c-arg">activation</span> = <span class="c-str">"softmax"</span>
  )

<span class="c-com"># 5. Compilar modelo</span>
model %>% <span class="c-fn">compile</span>(
  <span class="c-arg">loss</span> = <span class="c-str">"categorical_crossentropy"</span>,
  <span class="c-arg">optimizer</span> = <span class="c-fn">optimizer_adam</span>(<span class="c-arg">lr</span> = 0.001),
  <span class="c-arg">metrics</span> = <span class="c-str">"accuracy"</span>
)

<span class="c-com"># 6. Resumen de la arquitectura</span>
<span class="c-fn">summary</span>(model)

<span class="c-com"># 7. Entrenamiento (solo unas pocas √©pocas para demo)</span>
history <- model %>% <span class="c-fn">fit</span>(
  x_train, y_train,
  <span class="c-arg">epochs</span> = 5,
  <span class="c-arg">batch_size</span> = 128,
  <span class="c-arg">validation_split</span> = 0.2,
  <span class="c-arg">verbose</span> = 1
)

<span class="c-com"># 8. Evaluaci√≥n</span>
evaluation <- model %>% <span class="c-fn">evaluate</span>(x_test, y_test, <span class="c-arg">verbose</span> = 0)
<span class="c-fn">cat</span>(<span class="c-str">"\\n=== EVALUACI√ìN ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Test loss:"</span>, <span class="c-fn">round</span>(evaluation[1], 4), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Test accuracy:"</span>, <span class="c-fn">round</span>(evaluation[2], 4), <span class="c-str">"\\n"</span>)

<span class="c-com"># 9. Visualizaci√≥n del entrenamiento</span>
plot_data <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">epoch</span> = <span class="c-fn">rep</span>(1:5, 2),
  <span class="c-arg">value</span> = <span class="c-fn">c</span>(history<span class="c-var">$metrics</span><span class="c-var">$loss</span>, history<span class="c-var">$metrics</span><span class="c-var">$val_loss</span>),
  <span class="c-arg">type</span> = <span class="c-fn">rep</span>(<span class="c-fn">c</span>(<span class="c-str">"Training"</span>, <span class="c-str">"Validation"</span>), each = 5)
)

ggplot(plot_data, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = epoch, <span class="c-arg">y</span> = value, <span class="c-arg">color</span> = type)) +
  <span class="c-fn">geom_line</span>(<span class="c-arg">lwd</span> = 1) +
  <span class="c-fn">geom_point</span>(<span class="c-arg">size</span> = 3) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">labs</span>(
    <span class="c-arg">title</span> = <span class="c-str">"P√©rdida durante el Entrenamiento"</span>,
    <span class="c-arg">subtitle</span> = <span class="c-fn">paste</span>(<span class="c-str">"Arquitectura:"</span>, n_layers, <span class="c-str">"capas ocultas,"</span>, 
                       n_neurons, <span class="c-str">"neuronas,"</span>, activation),
    <span class="c-arg">x</span> = <span class="c-str">"√âpoca"</span>,
    <span class="c-arg">y</span> = <span class="c-str">"Loss"</span>,
    <span class="c-arg">color</span> = <span class="c-str">""</span>
  )

<span class="c-com"># 10. Visualizaci√≥n de activaciones</span>
<span class="c-com"># Obtener salidas de capas intermedias</span>
layer_outputs <- <span class="c-fn">lapply</span>(model<span class="c-var">$layers</span>, <span class="c-kwd">function</span>(layer) layer<span class="c-var">$output</span>)
activation_model <- <span class="c-fn">keras_model</span>(<span class="c-arg">inputs</span> = model<span class="c-var">$input</span>, 
                                <span class="c-arg">outputs</span> = layer_outputs)

<span class="c-com"># Predecir activaciones para una muestra</span>
sample_idx <- 1
activations <- <span class="c-fn">predict</span>(activation_model, x_train[sample_idx,, drop = FALSE])

<span class="c-com"># Visualizar activaciones de primera capa oculta</span>
first_layer_activations <- activations[[1]][1, ]
activations_df <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">neuron</span> = 1:length(first_layer_activations),
  <span class="c-arg">activation</span> = first_layer_activations
)

ggplot(activations_df, <span class="c-fn">aes</span>(<span class="c-arg">x</span> = neuron, <span class="c-arg">y</span> = activation)) +
  <span class="c-fn">geom_bar</span>(<span class="c-arg">stat</span> = <span class="c-str">"identity"</span>, <span class="c-arg">fill</span> = <span class="c-str">"steelblue"</span>) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">labs</span>(
    <span class="c-arg">title</span> = <span class="c-str">"Activaciones de Neuronas (Primera Capa)"</span>,
    <span class="c-arg">x</span> = <span class="c-str">"Neurona"</span>,
    <span class="c-arg">y</span> = <span class="c-str">"Activaci√≥n"</span>
  )`,
                explain: (p) => {
                    const nLayers = p.layers;
                    const activation = p.act;
                    const nNeurons = p.neurons;
                    
                    return `
                        <div class="exp-highlight">
                            <b>üß† Redes Neuronales Artificiales - Arquitectura</b>
                        </div>
                        
                        <p><b>Concepto:</b> Modelos computacionales inspirados en el cerebro biol√≥gico, compuestos de neuronas artificiales interconectadas.</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Configuraci√≥n actual:</b><br>
                            ‚Ä¢ <b>Capas ocultas:</b> ${nLayers}<br>
                            ‚Ä¢ <b>Neuronas por capa:</b> ${nNeurons}<br>
                            ‚Ä¢ <b>Funci√≥n de activaci√≥n:</b> ${activation}<br>
                            ‚Ä¢ <b>Total capas:</b> ${nLayers + 2} (entrada + ${nLayers} ocultas + salida)
                        </div>
                        
                        <div class="exp-highlight">
                            <b>üèóÔ∏è Arquitectura de capas:</b>
                            <p>1. <b>Capa de entrada:</b> 784 neuronas (28√ó28 p√≠xeles de MNIST)</p>
                            <p>2. <b>Capas ocultas (${nLayers}):</b> ${nNeurons} neuronas cada una, activaci√≥n ${activation}</p>
                            <p>3. <b>Capa de salida:</b> 10 neuronas (d√≠gitos 0-9), activaci√≥n softmax</p>
                        </div>
                        
                        <p><b>üî¢ C√°lculo en una neurona:</b></p>
                        <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                            z = Œ£·µ¢(w·µ¢¬∑x·µ¢) + b<br>
                            a = f(z)
                        </p>
                        <p>Donde f() es la funci√≥n de activaci√≥n (${activation})</p>
                        
                        <div class="exp-highlight">
                            <b>‚ö° Funciones de activaci√≥n:</b>
                            <table style="width:100%; border-collapse: collapse; margin: 10px 0;">
                                <tr style="background: rgba(0,122,204,0.1);">
                                    <th style="padding: 8px; border: 1px solid #007acc;">Funci√≥n</th>
                                    <th style="padding: 8px; border: 1px solid #007acc;">F√≥rmula</th>
                                    <th style="padding: 8px; border: 1px solid #007acc;">Rango</th>
                                    <th style="padding: 8px; border: 1px solid #007acc;">Uso</th>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333;">ReLU</td>
                                    <td style="padding: 8px; border: 1px solid #333; font-family: 'Fira Code';">max(0, x)</td>
                                    <td style="padding: 8px; border: 1px solid #333;">[0, ‚àû)</td>
                                    <td style="padding: 8px; border: 1px solid #333;">${activation === 'relu' ? '‚úÖ ACTUAL' : 'Capas ocultas'}</td>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333;">Sigmoid</td>
                                    <td style="padding: 8px; border: 1px solid #333; font-family: 'Fira Code';">1/(1+e‚ÅªÀ£)</td>
                                    <td style="padding: 8px; border: 1px solid #333;">(0, 1)</td>
                                    <td style="padding: 8px; border: 1px solid #333;">${activation === 'sigmoid' ? '‚úÖ ACTUAL' : 'Salida binaria'}</td>
                                </tr>
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #333;">Tanh</td>
                                    <td style="padding: 8px; border: 1px solid #333; font-family: 'Fira Code';">(eÀ£-e‚ÅªÀ£)/(eÀ£+e‚ÅªÀ£)</td>
                                    <td style="padding: 8px; border: 1px solid #333;">(-1, 1)</td>
                                    <td style="padding: 8px; border: 1px solid #333;">${activation === 'tanh' ? '‚úÖ ACTUAL' : 'Capas ocultas'}</td>
                                </tr>
                            </table>
                        </div>
                        
                        <p><b>üìä Par√°metros del modelo:</b></p>
                        <p>‚Ä¢ <b>Capa entrada‚Üíoculta1:</b> (784 √ó ${nNeurons}) + ${nNeurons} = ${784 * nNeurons + nNeurons}</p>
                        ${nLayers >= 1 ? `<p>‚Ä¢ <b>Capa oculta1‚Üíoculta2:</b> (${nNeurons} √ó ${nNeurons}) + ${nNeurons} = ${nNeurons * nNeurons + nNeurons}</p>` : ''}
                        ${nLayers >= 2 ? `<p>‚Ä¢ <b>Capa oculta2‚Üíoculta3:</b> (${nNeurons} √ó ${nNeurons}) + ${nNeurons} = ${nNeurons * nNeurons + nNeurons}</p>` : ''}
                        ${nLayers >= 3 ? `<p>‚Ä¢ <b>Capa oculta3‚Üíoculta4:</b> (${nNeurons} √ó ${nNeurons}) + ${nNeurons} = ${nNeurons * nNeurons + nNeurons}</p>` : ''}
                        <p>‚Ä¢ <b>Capa final‚Üísalida:</b> (${nNeurons} √ó 10) + 10 = ${nNeurons * 10 + 10}</p>
                        <p><b>Total par√°metros:</b> ~${(784 * nNeurons + nNeurons + (nLayers * (nNeurons * nNeurons + nNeurons)) + (nNeurons * 10 + 10)).toLocaleString()}</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-exclamation-triangle"></i> <b>Trade-off capacidad vs overfitting:</b>
                            <p>‚Ä¢ <b>Pocas capas/neuronas (${nLayers <= 1 && nNeurons <= 8 ? '‚Üì' : '‚Üë'})</b>: Baja capacidad ‚Üí riesgo de underfitting</p>
                            <p>‚Ä¢ <b>Muchas capas/neuronas (${nLayers >= 3 && nNeurons >= 24 ? '‚Üë' : '‚Üì'})</b>: Alta capacidad ‚Üí riesgo de overfitting</p>
                            <p>‚Ä¢ <b>Equilibrio</b>: Regularizaci√≥n (dropout, L2) + validaci√≥n cruzada</p>
                        </div>
                        
                        <div class="exp-highlight">
                            <b>üîç Forward Propagation:</b>
                            <p>1. Entrada ‚Üí transformaci√≥n lineal (W¬∑x + b)</p>
                            <p>2. Aplicar funci√≥n de activaci√≥n no lineal</p>
                            <p>3. Repetir para cada capa</p>
                            <p>4. Salida ‚Üí probabilidades con softmax</p>
                        </div>`;
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        flex-direction: column;
                        gap: 20px;
                        padding: 20px;
                    `;
                    
                    // Secci√≥n superior: Visualizaci√≥n de la arquitectura
                    const archSection = document.createElement('div');
                    archSection.style.cssText = `
                        flex: 2;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        position: relative;
                        overflow: auto;
                    `;
                    
                    const archTitle = document.createElement('div');
                    archTitle.innerHTML = `<b style="color:#333; font-size:1rem;">Arquitectura de la Red Neuronal</b>`;
                    archTitle.style.cssText = 'margin-bottom: 20px; text-align: center;';
                    archSection.appendChild(archTitle);
                    
                    // Crear visualizaci√≥n de la red neuronal
                    const networkViz = document.createElement('div');
                    networkViz.style.cssText = `
                        width: 100%;
                        height: calc(100% - 40px);
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        position: relative;
                    `;
                    
                    // Configurar capas
                    const layers = [
                        {type: 'input', neurons: 784, label: 'Entrada', color: '#bbdefb'},
                        ...Array.from({length: p.layers}, (_, i) => ({
                            type: 'hidden',
                            neurons: p.neurons,
                            label: `Oculta ${i+1}`,
                            color: i % 2 === 0 ? '#c8e6c9' : '#ffcdd2'
                        })),
                        {type: 'output', neurons: 10, label: 'Salida', color: '#fff3e0'}
                    ];
                    
                    // Crear contenedor para capas
                    const layersContainer = document.createElement('div');
                    layersContainer.style.cssText = `
                        display: flex;
                        height: 80%;
                        width: 90%;
                        justify-content: space-around;
                        align-items: center;
                    `;
                    
                    // Crear cada capa
                    layers.forEach((layer, layerIndex) => {
                        const layerDiv = document.createElement('div');
                        layerDiv.style.cssText = `
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            gap: 5px;
                            height: 100%;
                            justify-content: center;
                        `;
                        
                        // Etiqueta de la capa
                        const layerLabel = document.createElement('div');
                        layerLabel.style.cssText = `
                            font-size: 0.8rem;
                            font-weight: bold;
                            color: #333;
                            margin-bottom: 10px;
                            text-align: center;
                        `;
                        layerLabel.textContent = layer.label;
                        layerDiv.appendChild(layerLabel);
                        
                        // Contenedor de neuronas
                        const neuronsContainer = document.createElement('div');
                        neuronsContainer.style.cssText = `
                            display: flex;
                            flex-direction: column;
                            gap: 8px;
                            align-items: center;
                        `;
                        
                        // N√∫mero limitado de neuronas visibles
                        const neuronsToShow = Math.min(layer.neurons, 15);
                        const neuronScale = Math.max(0.3, 15 / neuronsToShow);
                        
                        for(let i = 0; i < neuronsToShow; i++) {
                            const neuron = document.createElement('div');
                            neuron.style.cssText = `
                                width: ${30 * neuronScale}px;
                                height: ${30 * neuronScale}px;
                                border-radius: 50%;
                                background: ${layer.color};
                                border: 2px solid #333;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-size: ${0.7 * neuronScale}rem;
                                color: #333;
                                position: relative;
                            `;
                            
                            // Mostrar n√∫mero solo si es peque√±o
                            if(neuronsToShow <= 10) {
                                neuron.textContent = i+1;
                            }
                            
                            // Tooltip con informaci√≥n
                            neuron.dataset.tooltip = `Capa ${layer.label}<br>Neurona ${i+1}/${layer.neurons}<br>Tipo: ${layer.type}`;
                            neuron.onmouseover = showTooltip;
                            neuron.onmouseout = hideTooltip;
                            
                            neuronsContainer.appendChild(neuron);
                        }
                        
                        // Mostrar contador si hay m√°s neuronas
                        if(layer.neurons > neuronsToShow) {
                            const moreNeurons = document.createElement('div');
                            moreNeurons.style.cssText = `
                                font-size: 0.7rem;
                                color: #666;
                                margin-top: 5px;
                            `;
                            moreNeurons.textContent = `... +${layer.neurons - neuronsToShow} m√°s`;
                            neuronsContainer.appendChild(moreNeurons);
                        }
                        
                        layerDiv.appendChild(neuronsContainer);
                        layersContainer.appendChild(layerDiv);
                        
                        // Conectar con la siguiente capa
                        if(layerIndex < layers.length - 1) {
                            const connector = document.createElement('div');
                            connector.style.cssText = `
                                width: 50px;
                                display: flex;
                                flex-direction: column;
                                align-items: center;
                                justify-content: center;
                                height: 100%;
                            `;
                            
                            // L√≠neas de conexi√≥n
                            const linesContainer = document.createElement('div');
                            linesContainer.style.cssText = `
                                width: 100%;
                                height: 100%;
                                position: relative;
                            `;
                            
                            // Dibujar algunas l√≠neas representativas
                            const numLines = 5;
                            for(let i = 0; i < numLines; i++) {
                                const line = document.createElement('div');
                                const y1 = (i / (numLines - 1)) * 80 + 10;
                                line.style.cssText = `
                                    position: absolute;
                                    width: 100%;
                                    height: 1px;
                                    background: #666;
                                    top: ${y1}%;
                                    transform-origin: left center;
                                    transform: perspective(100px) rotateY(20deg);
                                    opacity: 0.3;
                                `;
                                linesContainer.appendChild(line);
                            }
                            
                            connector.appendChild(linesContainer);
                            layersContainer.appendChild(connector);
                        }
                    });
                    
                    networkViz.appendChild(layersContainer);
                    archSection.appendChild(networkViz);
                    
                    // Secci√≥n inferior: Informaci√≥n y m√©tricas
                    const infoSection = document.createElement('div');
                    infoSection.style.cssText = `
                        flex: 1;
                        display: flex;
                        gap: 20px;
                    `;
                    
                    // Panel de informaci√≥n de la arquitectura
                    const archInfoDiv = document.createElement('div');
                    archInfoDiv.style.cssText = `
                        flex: 1;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    `;
                    
                    const archInfoTitle = document.createElement('div');
                    archInfoTitle.innerHTML = `<b style="color:#333; font-size:0.9rem;">Especificaciones de la Arquitectura</b>`;
                    archInfoTitle.style.cssText = 'margin-bottom: 15px; text-align: center;';
                    archInfoDiv.appendChild(archInfoTitle);
                    
                    // Calcular par√°metros
                    const inputNeurons = 784;
                    const hiddenNeurons = p.neurons;
                    const outputNeurons = 10;
                    const hiddenLayers = p.layers;
                    
                    let totalParams = 0;
                    let paramDetails = '';
                    
                    // Entrada -> Primera oculta
                    const inputToFirst = inputNeurons * hiddenNeurons + hiddenNeurons;
                    totalParams += inputToFirst;
                    paramDetails += `Entrada‚ÜíOculta1: ${(inputNeurons * hiddenNeurons).toLocaleString()} + ${hiddenNeurons} = ${inputToFirst.toLocaleString()}<br>`;
                    
                    // Conexiones entre capas ocultas
                    for(let i = 0; i < hiddenLayers - 1; i++) {
                        const hiddenToHidden = hiddenNeurons * hiddenNeurons + hiddenNeurons;
                        totalParams += hiddenToHidden;
                        paramDetails += `Oculta${i+1}‚ÜíOculta${i+2}: ${(hiddenNeurons * hiddenNeurons).toLocaleString()} + ${hiddenNeurons} = ${hiddenToHidden.toLocaleString()}<br>`;
                    }
                    
                    // √öltima oculta -> Salida
                    const lastToOutput = hiddenNeurons * outputNeurons + outputNeurons;
                    totalParams += lastToOutput;
                    paramDetails += `Oculta${hiddenLayers}‚ÜíSalida: ${(hiddenNeurons * outputNeurons).toLocaleString()} + ${outputNeurons} = ${lastToOutput.toLocaleString()}<br>`;
                    
                    const archInfoContent = document.createElement('div');
                    archInfoContent.style.cssText = `
                        font-size: 0.8rem;
                        line-height: 1.6;
                        color: #333;
                    `;
                    archInfoContent.innerHTML = `
                        <b>Configuraci√≥n:</b><br>
                        ‚Ä¢ Capas totales: ${hiddenLayers + 2}<br>
                        ‚Ä¢ Capas ocultas: ${hiddenLayers}<br>
                        ‚Ä¢ Neuronas por capa oculta: ${hiddenNeurons}<br>
                        ‚Ä¢ Funci√≥n de activaci√≥n: ${p.act}<br>
                        <br>
                        <b>Par√°metros por capa:</b><br>
                        ${paramDetails}
                        <br>
                        <b>Total par√°metros:</b> ${totalParams.toLocaleString()}<br>
                        <br>
                        <b>Optimizador:</b> Adam (lr=0.001)<br>
                        <b>Loss:</b> Categorical Crossentropy<br>
                        <b>M√©trica:</b> Accuracy
                    `;
                    
                    archInfoDiv.appendChild(archInfoContent);
                    
                    // Panel de funci√≥n de activaci√≥n
                    const activationDiv = document.createElement('div');
                    activationDiv.style.cssText = `
                        flex: 1;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        display: flex;
                        flex-direction: column;
                    `;
                    
                    const activationTitle = document.createElement('div');
                    activationTitle.innerHTML = `<b style="color:#333; font-size:0.9rem;">Funci√≥n de Activaci√≥n: ${p.act}</b>`;
                    activationTitle.style.cssText = 'margin-bottom: 15px; text-align: center;';
                    activationDiv.appendChild(activationTitle);
                    
                    // Gr√°fico de la funci√≥n de activaci√≥n
                    const activationPlot = document.createElement('div');
                    activationPlot.style.cssText = `
                        flex: 1;
                        position: relative;
                        background: #f8f9fa;
                        border-radius: 5px;
                        border: 1px solid #dee2e6;
                    `;
                    
                    // Crear SVG para el gr√°fico
                    const activationSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    activationSvg.setAttribute('width', '100%');
                    activationSvg.setAttribute('height', '100%');
                    
                    // Ejes
                    const axAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    axAxis.setAttribute('x1', '10%');
                    axAxis.setAttribute('y1', '50%');
                    axAxis.setAttribute('x2', '90%');
                    axAxis.setAttribute('y2', '50%');
                    axAxis.setAttribute('stroke', '#333');
                    axAxis.setAttribute('stroke-width', '1');
                    
                    const ayAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    ayAxis.setAttribute('x1', '50%');
                    ayAxis.setAttribute('y1', '10%');
                    ayAxis.setAttribute('x2', '50%');
                    ayAxis.setAttribute('y2', '90%');
                    ayAxis.setAttribute('stroke', '#333');
                    ayAxis.setAttribute('stroke-width', '1');
                    
                    // Dibujar funci√≥n de activaci√≥n
                    const activationPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let pathData = '';
                    
                    // Definir la funci√≥n seg√∫n el tipo
                    const activationFunctions = {
                        'relu': (x) => Math.max(0, x),
                        'sigmoid': (x) => 1 / (1 + Math.exp(-x)),
                        'tanh': (x) => Math.tanh(x)
                    };
                    
                    const func = activationFunctions[p.act];
                    
                    for(let x = -5; x <= 5; x += 0.1) {
                        const y = func(x);
                        // Escalar coordenadas
                        const svgX = 50 + (x / 5) * 40; // -5 ‚Üí 10%, 5 ‚Üí 90%
                        const svgY = 50 - (y / (p.act === 'relu' ? 5 : 1)) * 40; // Invertir eje Y
                        
                        if(x === -5) {
                            pathData = `M ${svgX}% ${svgY}% `;
                        } else {
                            pathData += `L ${svgX}% ${svgY}% `;
                        }
                    }
                    
                    activationPath.setAttribute('d', pathData);
                    activationPath.setAttribute('fill', 'none');
                    activationPath.setAttribute('stroke', '#007acc');
                    activationPath.setAttribute('stroke-width', '2');
                    
                    // Etiquetas
                    const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    xLabel.setAttribute('x', '50%');
                    xLabel.setAttribute('y', '95%');
                    xLabel.setAttribute('text-anchor', 'middle');
                    xLabel.setAttribute('fill', '#333');
                    xLabel.setAttribute('font-size', '10');
                    xLabel.textContent = 'z (entrada)';
                    
                    const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    yLabel.setAttribute('x', '5%');
                    yLabel.setAttribute('y', '50%');
                    yLabel.setAttribute('text-anchor', 'middle');
                    yLabel.setAttribute('fill', '#333');
                    yLabel.setAttribute('font-size', '10');
                    yLabel.setAttribute('transform', 'rotate(-90 5,50)');
                    yLabel.textContent = `f(z) = ${p.act}(z)`;
                    
                    activationSvg.appendChild(axAxis);
                    activationSvg.appendChild(ayAxis);
                    activationSvg.appendChild(activationPath);
                    activationSvg.appendChild(xLabel);
                    activationSvg.appendChild(yLabel);
                    
                    activationPlot.appendChild(activationSvg);
                    activationDiv.appendChild(activationPlot);
                    
                    infoSection.appendChild(archInfoDiv);
                    infoSection.appendChild(activationDiv);
                    
                    container.appendChild(archSection);
                    container.appendChild(infoSection);
                    div.appendChild(container);
                }
            },
            {
                id: 10,
                title: "Tema 10. Deep Learning II",
                desc: "Entrenamiento (Loss)",
                icon: "fa-rocket",
                controls: [
                    {id: 'lr', type: 'select', label: 'Learning Rate', options: ['0.01 (√ìptimo)', '0.0001 (Lento)', '1.5 (Muy Alto)']},
                    {id: 'ep', type: 'range', label: '√âpocas', min: 10, max: 100, val: 50},
                    {id: 'batch', type: 'range', label: 'Batch Size', min: 16, max: 256, val: 64}
                ],
                code: (p) => `
<span class="c-com"># TEMA 10: ENTRENAMIENTO DE REDES NEURONALES</span>
<span class="c-com"># =========================================</span>

<span class="c-kwd">library</span>(keras)
<span class="c-kwd">library</span>(ggplot2)
<span class="c-kwd">library</span>(tensorflow)

<span class="c-com"># 1. Configurar par√°metros de entrenamiento</span>
learning_rate <- <span class="c-num">${parseFloat(p.lr.split(' ')[0])}</span>
epochs <- <span class="c-num">${p.ep}</span>
batch_size <- <span class="c-num">${p.batch}</span>

<span class="c-com"># 2. Cargar y preparar datos (MNIST simplificado)</span>
<span class="c-kwd">set.seed</span>(123)
<span class="c-fn">use_session_with_seed</span>(123)

mnist <- <span class="c-fn">dataset_mnist</span>()
x_train <- mnist<span class="c-var">$train</span><span class="c-var">$x</span>[1:10000,,]  <span class="c-com"># Usar subconjunto para demo r√°pida</span>
y_train <- mnist<span class="c-var">$train</span><span class="c-var">$y</span>[1:10000]
x_test <- mnist<span class="c-var">$test</span><span class="c-var">$x</span>[1:2000,,]
y_test <- mnist<span class="c-var">$test</span><span class="c-var">$y</span>[1:2000]

<span class="c-com"># Preprocesamiento</span>
x_train <- <span class="c-fn">array_reshape</span>(x_train, <span class="c-fn">c</span>(<span class="c-fn">nrow</span>(x_train), 784)) / 255
x_test  <- <span class="c-fn">array_reshape</span>(x_test, <span class="c-fn">c</span>(<span class="c-fn">nrow</span>(x_test), 784)) / 255
y_train <- <span class="c-fn">to_categorical</span>(y_train, 10)
y_test  <- <span class="c-fn">to_categorical</span>(y_test, 10)

<span class="c-com"># 3. Definir modelo simple</span>
model <- <span class="c-fn">keras_model_sequential</span>() %>%
  <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span> = 128, <span class="c-arg">activation</span> = <span class="c-str">"relu"</span>, <span class="c-arg">input_shape</span> = <span class="c-fn">c</span>(784)) %>%
  <span class="c-fn">layer_dropout</span>(<span class="c-arg">rate</span> = 0.3) %>%
  <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span> = 64, <span class="c-arg">activation</span> = <span class="c-str">"relu"</span>) %>%
  <span class="c-fn">layer_dropout</span>(<span class="c-arg">rate</span> = 0.3) %>%
  <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span> = 10, <span class="c-arg">activation</span> = <span class="c-str">"softmax"</span>)

<span class="c-com"># 4. Compilar modelo con learning rate espec√≠fico</span>
model %>% <span class="c-fn">compile</span>(
  <span class="c-arg">loss</span> = <span class="c-str">"categorical_crossentropy"</span>,
  <span class="c-arg">optimizer</span> = <span class="c-fn">optimizer_adam</span>(<span class="c-arg">lr</span> = learning_rate),
  <span class="c-arg">metrics</span> = <span class="c-str">"accuracy"</span>
)

<span class="c-com"># 5. Callbacks para monitorear entrenamiento</span>
callbacks <- <span class="c-fn">list</span>(
  <span class="c-com"># Early stopping si no mejora en 5 √©pocas</span>
  <span class="c-fn">callback_early_stopping</span>(
    <span class="c-arg">monitor</span> = <span class="c-str">"val_loss"</span>,
    <span class="c-arg">patience</span> = 5,
    <span class="c-arg">restore_best_weights</span> = TRUE
  ),
  <span class="c-com"># Reduce learning rate si se estanca</span>
  <span class="c-fn">callback_reduce_lr_on_plateau</span>(
    <span class="c-arg">monitor</span> = <span class="c-str">"val_loss"</span>,
    <span class="c-arg">factor</span> = 0.5,
    <span class="c-arg">patience</span> = 3,
    <span class="c-arg">min_lr</span> = 0.00001
  )
)

<span class="c-com"># 6. Entrenar modelo</span>
history <- model %>% <span class="c-fn">fit</span>(
  x_train, y_train,
  <span class="c-arg">epochs</span> = epochs,
  <span class="c-arg">batch_size</span> = batch_size,
  <span class="c-arg">validation_split</span> = 0.2,
  <span class="c-arg">callbacks</span> = callbacks,
  <span class="c-arg">verbose</span> = 1
)

<span class="c-com"># 7. Evaluar modelo</span>
evaluation <- model %>% <span class="c-fn">evaluate</span>(x_test, y_test, <span class="c-arg">verbose</span> = 0)
<span class="c-fn">cat</span>(<span class="c-str">"\\n=== EVALUACI√ìN FINAL ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Learning rate:"</span>, learning_rate, <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Batch size:"</span>, batch_size, <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"√âpocas entrenadas:"</span>, <span class="c-fn">length</span>(history<span class="c-var">$metrics</span><span class="c-var">$loss</span>), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Test loss:"</span>, <span class="c-fn">round</span>(evaluation[1], 4), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Test accuracy:"</span>, <span class="c-fn">round</span>(evaluation[2], 4), <span class="c-str">"\\n"</span>)

<span class="c-com"># 8. Visualizar curvas de aprendizaje</span>
plot_data <- <span class="c-fn">data.frame</span>(
  <span class="c-arg">epoch</span> = 1:<span class="c-fn">length</span>(history<span class="c-var">$metrics</span><span class="c-var">$loss</span>),
  <span class="c-arg">train_loss</span> = history<span class="c-var">$metrics</span><span class="c-var">$loss</span>,
  <span class="c-arg">val_loss</span> = history<span class="c-var">$metrics</span><span class="c-var">$val_loss</span>,
  <span class="c-arg">train_acc</span> = history<span class="c-var">$metrics</span><span class="c-var">$accuracy</span>,
  <span class="c-arg">val_acc</span> = history<span class="c-var">$metrics</span><span class="c-var">$val_accuracy</span>
)

<span class="c-com"># Gr√°fico de p√©rdida</span>
loss_plot <- <span class="c-fn">ggplot</span>(plot_data) +
  <span class="c-fn">geom_line</span>(<span class="c-fn">aes</span>(<span class="c-arg">x</span> = epoch, <span class="c-arg">y</span> = train_loss, <span class="c-arg">color</span> = <span class="c-str">"Training"</span>), <span class="c-arg">lwd</span> = 1) +
  <span class="c-fn">geom_line</span>(<span class="c-fn">aes</span>(<span class="c-arg">x</span> = epoch, <span class="c-arg">y</span> = val_loss, <span class="c-arg">color</span> = <span class="c-str">"Validation"</span>), <span class="c-arg">lwd</span> = 1) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">labs</span>(
    <span class="c-arg">title</span> = <span class="c-str">"Curva de P√©rdida durante el Entrenamiento"</span>,
    <span class="c-arg">subtitle</span> = <span class="c-fn">paste</span>(<span class="c-str">"LR ="</span>, learning_rate, 
                       <span class="c-str">"Batch ="</span>, batch_size),
    <span class="c-arg">x</span> = <span class="c-str">"√âpoca"</span>,
    <span class="c-arg">y</span> = <span class="c-str">"Loss"</span>,
    <span class="c-arg">color</span> = <span class="c-str">""</span>
  ) +
  <span class="c-fn">scale_color_manual</span>(<span class="c-arg">values</span> = <span class="c-fn">c</span>(<span class="c-str">"Training"</span> = <span class="c-str">"steelblue"</span>, 
                                    <span class="c-str">"Validation"</span> = <span class="c-str">"orange"</span>))

<span class="c-com"># Gr√°fico de accuracy</span>
acc_plot <- <span class="c-fn">ggplot</span>(plot_data) +
  <span class="c-fn">geom_line</span>(<span class="c-fn">aes</span>(<span class="c-arg">x</span> = epoch, <span class="c-arg">y</span> = train_acc, <span class="c-arg">color</span> = <span class="c-str">"Training"</span>), <span class="c-arg">lwd</span> = 1) +
  <span class="c-fn">geom_line</span>(<span class="c-fn">aes</span>(<span class="c-arg">x</span> = epoch, <span class="c-arg">y</span> = val_acc, <span class="c-arg">color</span> = <span class="c-str">"Validation"</span>), <span class="c-arg">lwd</span> = 1) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">labs</span>(
    <span class="c-arg">title</span> = <span class="c-str">"Accuracy durante el Entrenamiento"</span>,
    <span class="c-arg">x</span> = <span class="c-str">"√âpoca"</span>,
    <span class="c-arg">y</span> = <span class="c-str">"Accuracy"</span>,
    <span class="c-arg">color</span> = <span class="c-str">""</span>
  ) +
  <span class="c-fn">ylim</span>(0, 1) +
  <span class="c-fn">scale_color_manual</span>(<span class="c-arg">values</span> = <span class="c-fn">c</span>(<span class="c-str">"Training"</span> = <span class="c-str">"steelblue"</span>, 
                                    <span class="c-str">"Validation"</span> = <span class="c-str">"orange"</span>))

<span class="c-com"># 9. Mostrar ambos gr√°ficos</span>
<span class="c-kwd">library</span>(gridExtra)
<span class="c-fn">grid.arrange</span>(loss_plot, acc_plot, <span class="c-arg">ncol</span> = 2)

<span class="c-com"># 10. Analizar gradientes (conceptualmente)</span>
<span class="c-fn">cat</span>(<span class="c-str">"\\n=== AN√ÅLISIS DE GRADIENTES ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Learning rate actual:"</span>, learning_rate, <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Comportamiento esperado:\\n"</span>)
<span class="c-kwd">if</span> (learning_rate > 1) {
  <span class="c-fn">cat</span>(<span class="c-str">"  - LR demasiado alto: riesgo de divergencia\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"  - P√©rdida puede oscilar o aumentar\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"  - Gradientes pueden explotar (exploding gradients)\\n"</span>)
} <span class="c-kwd">else if</span> (learning_rate < 0.001) {
  <span class="c-fn">cat</span>(<span class="c-str">"  - LR demasiado bajo: convergencia lenta\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"  - Puede quedar atrapado en m√≠nimos locales\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"  - Gradientes pueden desaparecer (vanishing gradients)\\n"</span>)
} <span class="c-kwd">else</span> {
  <span class="c-fn">cat</span>(<span class="c-str">"  - LR adecuado: convergencia estable\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"  - P√©rdida disminuye suavemente\\n"</span>)
  <span class="c-fn">cat</span>(<span class="c-str">"  - Gradientes bien comportados\\n"</span>)
}`,
                explain: (p) => {
                    const lr = parseFloat(p.lr.split(' ')[0]);
                    const epochs = p.ep;
                    const batchSize = p.batch;
                    
                    let lrWarning = '';
                    if(lr > 1) {
                        lrWarning = `
                        <div class="exp-note" style="background: rgba(244, 67, 54, 0.1); border-left-color: #f44336;">
                            <i class="fas fa-exclamation-triangle"></i> <b>¬°ALERTA! Learning Rate demasiado alto</b>
                            <p>LR = ${lr} puede causar divergencia en el entrenamiento. Los pasos de gradiente son demasiado grandes.</p>
                            <p><b>S√≠ntomas esperados:</b> P√©rdida que oscila o aumenta, gradientes que explotan.</p>
                        </div>`;
                    } else if(lr < 0.001) {
                        lrWarning = `
                        <div class="exp-note" style="background: rgba(255, 152, 0, 0.1); border-left-color: #FF9800;">
                            <i class="fas fa-exclamation-triangle"></i> <b>Learning Rate muy bajo</b>
                            <p>LR = ${lr} puede causar convergencia extremadamente lenta.</p>
                            <p><b>S√≠ntomas esperados:</b> P√©rdida que disminuye muy lentamente, riesgo de quedar atrapado en m√≠nimos locales.</p>
                        </div>`;
                    } else {
                        lrWarning = `
                        <div class="exp-note" style="background: rgba(76, 175, 80, 0.1); border-left-color: #4CAF50;">
                            <i class="fas fa-check-circle"></i> <b>Learning Rate adecuado</b>
                            <p>LR = ${lr} est√° en el rango recomendado para la mayor√≠a de problemas.</p>
                            <p><b>Comportamiento esperado:</b> Convergencia estable, p√©rdida que disminuye suavemente.</p>
                        </div>`;
                    }
                    
                    return lrWarning + `
                        <div class="exp-highlight">
                            <b>üöÄ Entrenamiento de Redes Neuronales</b>
                        </div>
                        
                        <p><b>Concepto:</b> Proceso de ajuste de los pesos de la red mediante optimizaci√≥n basada en gradientes.</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Hiperpar√°metros de entrenamiento:</b><br>
                            ‚Ä¢ <b>Learning Rate:</b> ${lr}<br>
                            ‚Ä¢ <b>√âpocas:</b> ${epochs}<br>
                            ‚Ä¢ <b>Batch Size:</b> ${batchSize}<br>
                            ‚Ä¢ <b>Optimizador:</b> Adam<br>
                            ‚Ä¢ <b>Loss:</b> Categorical Crossentropy
                        </div>
                        
                        <div class="exp-highlight">
                            <b>üîÑ Algoritmo de entrenamiento (backpropagation):</b>
                            <p>1. <b>Forward pass:</b> Calcular predicciones y p√©rdida</p>
                            <p>2. <b>Backward pass:</b> Calcular gradientes ‚àÇL/‚àÇw usando regla de la cadena</p>
                            <p>3. <b>Actualizar pesos:</b> w ‚Üê w - Œ∑¬∑‚àáw (descenso de gradiente)</p>
                            <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                                Œîw = -Œ∑ ¬∑ ‚àÇL/‚àÇw
                            </p>
                        </div>
                        
                        <p><b>üìä Batch Size Trade-off:</b></p>
                        <p>‚Ä¢ <b>Batch peque√±o (${batchSize <= 32 ? '‚Üì' : '‚Üë'})</b>: M√°s ruido en gradientes, m√°s actualizaciones por √©poca</p>
                        <p>‚Ä¢ <b>Batch grande (${batchSize >= 128 ? '‚Üë' : '‚Üì'})</b>: Gradientes m√°s estables, menos ruido</p>
                        <p>‚Ä¢ <b>Batch = dataset completo</b>: Gradiente exacto, pero computacionalmente costoso</p>
                        
                        <div class="exp-highlight">
                            <b>üìà Interpretaci√≥n de curvas de aprendizaje:</b>
                            <table style="width:100%; border-collapse: collapse; margin: 10px 0;">
                                <tr style="background: rgba(0,122,204,0.1);">
                                    <th style="padding: 8px; border: 1px solid #007acc;">Patr√≥n</th>
                                    <th style="padding: 8px; border: 1px solid #007acc;">Diagn√≥stico</th>
                                    <th style="padding:
<span class="c-fn">cat</span>(<span class="c-str">"Test accuracy:"</span>, <span class="c-fn">round</span>(evaluation[2], 4), <span class="c-str">"\\n"</span>)

<span class="c-com"># 9. Visualizar historial de entrenamiento</span>
plot(history) +
  <span class="c-fn">theme_minimal</span>() +
  <span class="c-fn">ggtitle</span>(<span class="c-str">"Historial de Entrenamiento"</span>)
`,
                explain: (p) => {
                    return `
                        <div class="exp-highlight">
                            <b>üß† Redes Neuronales Artificiales - Arquitectura</b>
                        </div>
                        
                        <p><b>Concepto:</b> Modelo computacional inspirado en el cerebro biol√≥gico, compuesto por unidades (neuronas) organizadas en capas.</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Par√°metros de la arquitectura:</b><br>
                            ‚Ä¢ <b>Capas ocultas = ${p.layers}</b><br>
                            ‚Ä¢ <b>Activaci√≥n = ${p.act}</b><br>
                            ‚Ä¢ <b>Neuronas por capa = ${p.neurons}</b>
                        </div>
                        
                        <p><b>Componentes clave:</b></p>
                        <p>1. <b>Capas:</b> Entrada ‚Üí Ocultas ‚Üí Salida</p>
                        <p>2. <b>Pesos (W):</b> Par√°metros aprendidos</p>
                        <p>3. <b>Sesgos (b):</b> T√©rminos de interceptaci√≥n</p>
                        <p>4. <b>Funci√≥n de activaci√≥n:</b> Introduce no-linealidad</p>
                        
                        <div class="exp-highlight">
                            <b>‚ö° Funciones de activaci√≥n:</b>
                            <p><b>ReLU:</b> max(0, x) ‚Üí R√°pida convergencia, evita vanishing gradient</p>
                            <p><b>Sigmoid:</b> 1/(1+e‚ÅªÀ£) ‚Üí [0,1], para probabilidades</p>
                            <p><b>Tanh:</b> (eÀ£-e‚ÅªÀ£)/(eÀ£+e‚ÅªÀ£) ‚Üí [-1,1], centrada en cero</p>
                        </div>
                        
                        <p><b>Forward propagation:</b></p>
                        <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                            z‚Å± = W‚Å±¬∑a‚Å±‚Åª¬π + b‚Å±<br>
                            a‚Å± = œÉ(z‚Å±)
                        </p>
                        
                        <div class="exp-note">
                            <i class="fas fa-lightbulb"></i> <b>Capacidad de aproximaci√≥n universal:</b>
                            <p>Una red con al menos una capa oculta y activaci√≥n no lineal puede aproximar cualquier funci√≥n continua.</p>
                        </div>
                        
                        <div class="exp-highlight">
                            <b>‚öôÔ∏è Entrenamiento con Backpropagation:</b>
                            <p>1. <b>Forward pass:</b> Calcular predicci√≥n y error</p>
                            <p>2. <b>Backward pass:</b> Propagaci√≥n inversa del error</p>
                            <p>3. <b>Actualizaci√≥n de pesos:</b> Descenso de gradiente</p>
                            <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                                W‚Å± = W‚Å± - Œ∑¬∑‚àÇL/‚àÇW‚Å±
                            </p>
                        </div>
                        
                        <p><b>üß¨ Aplicaci√≥n en bioinform√°tica:</b></p>
                        <p>‚Ä¢ Predicci√≥n de estructura de prote√≠nas</p>
                        <p>‚Ä¢ An√°lisis de secuencias de ADN/ARN</p>
                        <p>‚Ä¢ Clasificaci√≥n de im√°genes m√©dicas</p>
                        <p>‚Ä¢ Descubrimiento de f√°rmacos</p>
                    `;
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        flex-direction: column;
                        gap: 20px;
                        padding: 20px;
                    `;
                    
                    // Visualizaci√≥n de la arquitectura
                    const archSection = document.createElement('div');
                    archSection.style.cssText = `
                        flex: 2;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        position: relative;
                    `;
                    
                    const archTitle = document.createElement('div');
                    archTitle.innerHTML = `<b style="color:#333; font-size:1rem;">Arquitectura de la Red Neuronal</b>`;
                    archTitle.style.cssText = 'margin-bottom: 20px; text-align: center;';
                    archSection.appendChild(archTitle);
                    
                    // Crear visualizaci√≥n de capas
                    const layersViz = document.createElement('div');
                    layersViz.style.cssText = `
                        display: flex;
                        justify-content: space-around;
                        align-items: center;
                        height: 200px;
                    `;
                    
                    const layers = [
                        { type: 'input', neurons: 784, label: 'Entrada (784)' },
                        { type: 'hidden', neurons: p.neurons, label: `Oculta 1 (${p.neurons})` }
                    ];
                    
                    // A√±adir capas ocultas adicionales
                    for(let i = 1; i <= p.layers; i++) {
                        layers.push({
                            type: 'hidden',
                            neurons: p.neurons,
                            label: `Oculta ${i+1} (${p.neurons})`
                        });
                    }
                    
                    layers.push({ type: 'output', neurons: 10, label: 'Salida (10)' });
                    
                    layers.forEach((layer, idx) => {
                        const layerDiv = document.createElement('div');
                        layerDiv.style.cssText = `
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            gap: 10px;
                        `;
                        
                        // Representaci√≥n de la capa
                        const layerRep = document.createElement('div');
                        layerRep.style.cssText = `
                            width: 80px;
                            height: ${Math.max(50, layer.neurons * 3)}px;
                            background: ${layer.type === 'input' ? '#007acc' : 
                                       layer.type === 'output' ? '#4CAF50' : '#FF9800'};
                            border-radius: 10px;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            justify-content: space-around;
                            padding: 10px 0;
                        `;
                        
                        // A√±adir "neuronas" como puntos
                        const neuronsToShow = Math.min(layer.neurons, 8);
                        for(let i = 0; i < neuronsToShow; i++) {
                            const neuron = document.createElement('div');
                            neuron.style.cssText = `
                                width: 10px;
                                height: 10px;
                                border-radius: 50%;
                                background: white;
                            `;
                            layerRep.appendChild(neuron);
                        }
                        
                        if(layer.neurons > 8) {
                            const dots = document.createElement('div');
                            dots.innerHTML = '...';
                            dots.style.cssText = 'color: white; font-size: 0.8rem;';
                            layerRep.appendChild(dots);
                        }
                        
                        // Etiqueta
                        const label = document.createElement('div');
                        label.style.cssText = `
                            font-size: 0.8rem;
                            text-align: center;
                            color: #333;
                            margin-top: 5px;
                        `;
                        label.textContent = layer.label;
                        
                        layerDiv.appendChild(layerRep);
                        layerDiv.appendChild(label);
                        layersViz.appendChild(layerDiv);
                        
                        // A√±adir flechas entre capas
                        if(idx < layers.length - 1) {
                            const arrow = document.createElement('div');
                            arrow.innerHTML = '‚Üí';
                            arrow.style.cssText = `
                                font-size: 1.5rem;
                                color: #666;
                                margin: 0 10px;
                            `;
                            layersViz.appendChild(arrow);
                        }
                    });
                    
                    archSection.appendChild(layersViz);
                    
                    // Funci√≥n de activaci√≥n
                    const activationDiv = document.createElement('div');
                    activationDiv.style.cssText = `
                        display: flex;
                        justify-content: center;
                        margin-top: 20px;
                    `;
                    
                    const activationBox = document.createElement('div');
                    activationBox.style.cssText = `
                        background: #f3e5f5;
                        border-left: 4px solid #9C27B0;
                        padding: 10px 20px;
                        border-radius: 5px;
                        font-size: 0.9rem;
                    `;
                    activationBox.innerHTML = `<b>Funci√≥n de activaci√≥n: ${p.act.toUpperCase()}</b>`;
                    activationDiv.appendChild(activationBox);
                    
                    archSection.appendChild(activationDiv);
                    
                    // Estad√≠sticas
                    const statsDiv = document.createElement('div');
                    statsDiv.style.cssText = `
                        display: flex;
                        justify-content: center;
                        gap: 20px;
                        margin-top: 20px;
                    `;
                    
                    const totalLayers = p.layers + 2; // + entrada y salida
                    const totalParams = 784 * p.neurons + p.neurons * 10; // Simplificado
                    
                    const stats = [
                        {label: 'Capas totales', value: totalLayers},
                        {label: 'Par√°metros', value: totalParams.toLocaleString()},
                        {label: 'Funci√≥n de p√©rdida', value: 'Cross-entropy'},
                        {label: 'Optimizador', value: 'Adam'}
                    ];
                    
                    stats.forEach(stat => {
                        const statBox = document.createElement('div');
                        statBox.style.cssText = `
                            background: #e3f2fd;
                            padding: 10px 15px;
                            border-radius: 5px;
                            text-align: center;
                            border-left: 3px solid #2196F3;
                        `;
                        statBox.innerHTML = `
                            <div style="font-size: 0.8rem; color: #666;">${stat.label}</div>
                            <div style="font-size: 1rem; font-weight: bold;">${stat.value}</div>
                        `;
                        statsDiv.appendChild(statBox);
                    });
                    
                    archSection.appendChild(statsDiv);
                    
                    // Gr√°fico de p√©rdida y accuracy
                    const metricsSection = document.createElement('div');
                    metricsSection.style.cssText = `
                        flex: 1;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        display: flex;
                        justify-content: space-between;
                        gap: 20px;
                    `;
                    
                    const lossDiv = document.createElement('div');
                    lossDiv.style.cssText = `
                        flex: 1;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                    `;
                    
                    const lossTitle = document.createElement('div');
                    lossTitle.innerHTML = `<b style="color:#333; font-size:0.9rem;">P√©rdida durante entrenamiento</b>`;
                    lossTitle.style.cssText = 'margin-bottom: 10px;';
                    lossDiv.appendChild(lossTitle);
                    
                    // Gr√°fico simplificado de p√©rdida
                    const lossChart = document.createElement('div');
                    lossChart.style.cssText = `
                        width: 100%;
                        height: 120px;
                        background: #f8f9fa;
                        border-radius: 5px;
                        position: relative;
                        border: 1px solid #dee2e6;
                    `;
                    
                    // L√≠nea de p√©rdida
                    const lossLine = document.createElement('div');
                    lossLine.style.cssText = `
                        position: absolute;
                        top: 20px;
                        left: 0;
                        right: 0;
                        height: 2px;
                        background: #f44336;
                    `;
                    
                    // Puntos de p√©rdida
                    for(let i = 0; i < 5; i++) {
                        const point = document.createElement('div');
                        const x = (i * 20) + 10;
                        const y = 20 + Math.random() * 60;
                        point.style.cssText = `
                            position: absolute;
                            left: ${x}%;
                            top: ${y}px;
                            width: 8px;
                            height: 8px;
                            border-radius: 50%;
                            background: #f44336;
                            transform: translate(-50%, -50%);
                        `;
                        lossChart.appendChild(point);
                    }
                    
                    lossChart.appendChild(lossLine);
                    lossDiv.appendChild(lossChart);
                    
                    const accuracyDiv = document.createElement('div');
                    accuracyDiv.style.cssText = `
                        flex: 1;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                    `;
                    
                    const accuracyTitle = document.createElement('div');
                    accuracyTitle.innerHTML = `<b style="color:#333; font-size:0.9rem;">Accuracy durante entrenamiento</b>`;
                    accuracyTitle.style.cssText = 'margin-bottom: 10px;';
                    accuracyDiv.appendChild(accuracyTitle);
                    
                    // Gr√°fico simplificado de accuracy
                    const accChart = document.createElement('div');
                    accChart.style.cssText = `
                        width: 100%;
                        height: 120px;
                        background: #f8f9fa;
                        border-radius: 5px;
                        position: relative;
                        border: 1px solid #dee2e6;
                    `;
                    
                    // L√≠nea de accuracy
                    const accLine = document.createElement('div');
                    accLine.style.cssText = `
                        position: absolute;
                        top: 80px;
                        left: 0;
                        right: 0;
                        height: 2px;
                        background: #4CAF50;
                    `;
                    
                    // Puntos de accuracy
                    for(let i = 0; i < 5; i++) {
                        const point = document.createElement('div');
                        const x = (i * 20) + 10;
                        const y = 80 - Math.random() * 40;
                        point.style.cssText = `
                            position: absolute;
                            left: ${x}%;
                            top: ${y}px;
                            width: 8px;
                            height: 8px;
                            border-radius: 50%;
                            background: #4CAF50;
                            transform: translate(-50%, -50%);
                        `;
                        accChart.appendChild(point);
                    }
                    
                    accChart.appendChild(accLine);
                    accuracyDiv.appendChild(accChart);
                    
                    metricsSection.appendChild(lossDiv);
                    metricsSection.appendChild(accuracyDiv);
                    
                    container.appendChild(archSection);
                    container.appendChild(metricsSection);
                    div.appendChild(container);
                }
            },
            {
                id: 10,
                title: "Tema 10. Deep Learning II",
                desc: "Redes Convolucionales (CNN)",
                icon: "fa-filter",
                controls: [
                    {id: 'filters1', type: 'range', label: 'Filtros Capa 1', min: 8, max: 32, val: 16},
                    {id: 'filters2', type: 'range', label: 'Filtros Capa 2', min: 16, max: 64, val: 32},
                    {id: 'kernel', type: 'range', label: 'Tama√±o Kernel', min: 3, max: 7, val: 5, step: 2}
                ],
                code: (p) => `
<span class="c-com"># TEMA 10: REDES NEURONALES CONVOLUCIONALES (CNN)</span>
<span class="c-com"># ===============================================</span>

<span class="c-kwd">library</span>(keras)
<span class="c-kwd">library</span>(tensorflow)
<span class="c-kwd">library</span>(ggplot2)

<span class="c-com"># 1. Configurar backend</span>
<span class="c-fn">use_session_with_seed</span>(123)

<span class="c-com"># 2. Cargar datos MNIST (im√°genes 28x28 p√≠xeles)</span>
mnist <- <span class="c-fn">dataset_mnist</span>()
x_train <- mnist<span class="c-var">$train</span><span class="c-var">$x</span>
y_train <- mnist<span class="c-var">$train</span><span class="c-var">$y</span>
x_test  <- mnist<span class="c-var">$test</span><span class="c-var">$x</span>
y_test  <- mnist<span class="c-var">$test</span><span class="c-var">$y</span>

<span class="c-com"># 3. Preprocesamiento para CNN</span>
<span class="c-com"># Reformatear a (muestras, alto, ancho, canales)</span>
x_train <- <span class="c-fn">array_reshape</span>(x_train, <span class="c-fn">c</span>(<span class="c-fn">nrow</span>(x_train), 28, 28, 1)) / 255
x_test  <- <span class="c-fn">array_reshape</span>(x_test, <span class="c-fn">c</span>(<span class="c-fn">nrow</span>(x_test), 28, 28, 1)) / 255

<span class="c-com"># One-hot encoding de etiquetas</span>
y_train <- <span class="c-fn">to_categorical</span>(y_train, 10)
y_test  <- <span class="c-fn">to_categorical</span>(y_test, 10)

<span class="c-com"># 4. Definir arquitectura CNN</span>
filters1 <- <span class="c-num">${p.filters1}</span>
filters2 <- <span class="c-num">${p.filters2}</span>
kernel_size <- <span class="c-num">${p.kernel}</span>

model <- <span class="c-fn">keras_model_sequential</span>() %>%
  
  <span class="c-com"># Primera capa convolucional + pooling</span>
  <span class="c-fn">layer_conv_2d</span>(
    <span class="c-arg">filters</span> = filters1,
    <span class="c-arg">kernel_size</span> = <span class="c-fn">c</span>(kernel_size, kernel_size),
    <span class="c-arg">activation</span> = <span class="c-str">"relu"</span>,
    <span class="c-arg">input_shape</span> = <span class="c-fn">c</span>(28, 28, 1)
  ) %>%
  <span class="c-fn">layer_max_pooling_2d</span>(<span class="c-arg">pool_size</span> = <span class="c-fn">c</span>(2, 2)) %>%
  
  <span class="c-com"># Segunda capa convolucional + pooling</span>
  <span class="c-fn">layer_conv_2d</span>(
    <span class="c-arg">filters</span> = filters2,
    <span class="c-arg">kernel_size</span> = <span class="c-fn">c</span>(kernel_size, kernel_size),
    <span class="c-arg">activation</span> = <span class="c-str">"relu"</span>
  ) %>%
  <span class="c-fn">layer_max_pooling_2d</span>(<span class="c-arg">pool_size</span> = <span class="c-fn">c</span>(2, 2)) %>%
  
  <span class="c-com"># Aplanar para capas densas</span>
  <span class="c-fn">layer_flatten</span>() %>%
  
  <span class="c-com"># Capa densa oculta</span>
  <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span> = 64, <span class="c-arg">activation</span> = <span class="c-str">"relu"</span>) %>%
  
  <span class="c-com"># Capa de salida</span>
  <span class="c-fn">layer_dense</span>(<span class="c-arg">units</span> = 10, <span class="c-arg">activation</span> = <span class="c-str">"softmax"</span>)

<span class="c-com"># 5. Compilar modelo</span>
model %>% <span class="c-fn">compile</span>(
  <span class="c-arg">loss</span> = <span class="c-str">"categorical_crossentropy"</span>,
  <span class="c-arg">optimizer</span> = <span class="c-fn">optimizer_adam</span>(<span class="c-arg">lr</span> = 0.001),
  <span class="c-arg">metrics</span> = <span class="c-str">"accuracy"</span>
)

<span class="c-com"># 6. Resumen de arquitectura</span>
<span class="c-fn">summary</span>(model)

<span class="c-com"># 7. Entrenamiento</span>
history <- model %>% <span class="c-fn">fit</span>(
  x_train, y_train,
  <span class="c-arg">epochs</span> = 5,
  <span class="c-arg">batch_size</span> = 128,
  <span class="c-arg">validation_split</span> = 0.2,
  <span class="c-arg">verbose</span> = 1
)

<span class="c-com"># 8. Evaluaci√≥n</span>
evaluation <- model %>% <span class="c-fn">evaluate</span>(x_test, y_test, <span class="c-arg">verbose</span> = 0)
<span class="c-fn">cat</span>(<span class="c-str">"\\n=== EVALUACI√ìN CNN ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Test loss:"</span>, <span class="c-fn">round</span>(evaluation[1], 4), <span class="c-str">"\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Test accuracy:"</span>, <span class="c-fn">round</span>(evaluation[2], 4), <span class="c-str">"\\n"</span>)

<span class="c-com"># 9. Visualizar feature maps (primeras capas)</span>
<span class="c-com"># Crear modelo para extraer activaciones</span>
layer_outputs <- <span class="c-fn">lapply</span>(model<span class="c-var">$layers</span>[1:2], <span class="c-kwd">function</span>(layer) layer<span class="c-var">$output</span>)
activation_model <- <span class="c-fn">keras_model</span>(<span class="c-arg">inputs</span> = model<span class="c-var">$input</span>, 
                                  <span class="c-arg">outputs</span> = layer_outputs)
                                  
<span class="c-com"># Predecir en una imagen de ejemplo</span>
activations <- <span class="c-fn">predict</span>(activation_model, x_test[1:1,,,, drop = FALSE])

<span class="c-com"># 10. Comparar con red fully connected</span>
<span class="c-fn">cat</span>(<span class="c-str">"\\n=== CNN vs MLP ===\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"CNN aprovecha la estructura espacial de las im√°genes\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Par√°metros reducidos mediante convoluciones\\n"</span>)
<span class="c-fn">cat</span>(<span class="c-str">"Invariante a traslaciones\\n"</span>)`,
                explain: (p) => {
                    return `
                        <div class="exp-highlight">
                            <b>üñºÔ∏è Redes Neuronales Convolucionales (CNN)</b>
                        </div>
                        
                        <p><b>Concepto:</b> Arquitectura especializada para datos con estructura de grid (im√°genes, series temporales).</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-cog"></i> <b>Par√°metros CNN:</b><br>
                            ‚Ä¢ <b>Filtros Capa 1 = ${p.filters1}</b><br>
                            ‚Ä¢ <b>Filtros Capa 2 = ${p.filters2}</b><br>
                            ‚Ä¢ <b>Tama√±o Kernel = ${p.kernel}√ó${p.kernel}</b>
                        </div>
                        
                        <p><b>Componentes principales:</b></p>
                        <p>1. <b>Capa convolucional:</b> Aplica filtros para detectar caracter√≠sticas</p>
                        <p>2. <b>Capa de pooling:</b> Reduce dimensionalidad (max-pooling)</p>
                        <p>3. <b>Capa flatten:</b> Aplana para capas densas</p>
                        <p>4. <b>Capas densas:</b> Clasificaci√≥n final</p>
                        
                        <div class="exp-highlight">
                            <b>üéØ Convoluci√≥n 2D:</b>
                            <p>Operaci√≥n matem√°tica que aplica un kernel sobre la imagen:</p>
                            <p style="font-family: 'Fira Code', monospace; color: #6a9955;">
                                (I * K)[i,j] = Œ£‚Çò Œ£‚Çô I[i+m, j+n]¬∑K[m, n]
                            </p>
                            <p><b>Kernel ${p.kernel}√ó${p.kernel}:</b> Detecta bordes, texturas, patrones</p>
                        </div>
                        
                        <p><b>üîç Ventajas sobre MLP para im√°genes:</b></p>
                        <ul>
                            <li>üìè <b>Invariante a traslaciones</b></li>
                            <li>‚ö° <b>Menos par√°metros</b> (weight sharing)</li>
                            <li>üéØ <b>Captura relaciones espaciales</b></li>
                            <li>üìä <b>Jerarqu√≠a de caracter√≠sticas</b> (bordes ‚Üí formas ‚Üí objetos)</li>
                        </ul>
                        
                        <div class="exp-highlight">
                            <b>üìà Arquitectura t√≠pica:</b>
                            <p>Entrada ‚Üí [Conv ‚Üí ReLU ‚Üí Pooling]√óN ‚Üí Flatten ‚Üí Dense ‚Üí Softmax</p>
                            <p><b>Feature hierarchy:</b> Bordes simples ‚Üí combinaciones ‚Üí partes ‚Üí objetos</p>
                        </div>
                        
                        <p><b>üß¨ Aplicaciones en bioim√°genes:</b></p>
                        <p>‚Ä¢ Detecci√≥n de c√©lulas en microscop√≠a</p>
                        <p>‚Ä¢ Segmentaci√≥n de tejidos en histolog√≠a</p>
                        <p>‚Ä¢ Diagn√≥stico por imagen (MRI, CT, RX)</p>
                        <p>‚Ä¢ An√°lisis de Western Blots</p>
                        
                        <div class="exp-note">
                            <i class="fas fa-lightbulb"></i> <b>Transfer Learning:</b>
                            <p>Usar CNNs pre-entrenadas (ImageNet) y fine-tuning para problemas espec√≠ficos de bioim√°genes.</p>
                        </div>
                    `;
                },
                render: (p, div) => {
                    div.innerHTML = '';
                    
                    const container = document.createElement('div');
                    container.style.cssText = `
                        width: 100%;
                        height: 100%;
                        display: flex;
                        flex-direction: column;
                        gap: 20px;
                        padding: 20px;
                    `;
                    
                    // Visualizaci√≥n de la arquitectura CNN
                    const cnnSection = document.createElement('div');
                    cnnSection.style.cssText = `
                        flex: 2;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    `;
                    
                    const cnnTitle = document.createElement('div');
                    cnnTitle.innerHTML = `<b style="color:#333; font-size:1rem;">Arquitectura CNN para MNIST</b>`;
                    cnnTitle.style.cssText = 'margin-bottom: 20px; text-align: center;';
                    cnnSection.appendChild(cnnTitle);
                    
                    // Diagrama de la CNN
                    const cnnDiagram = document.createElement('div');
                    cnnDiagram.style.cssText = `
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        height: 200px;
                        position: relative;
                    `;
                    
                    // Capas de la CNN
                    const layers = [
                        { type: 'input', label: 'Entrada\n28√ó28√ó1', color: '#007acc', width: 60, height: 60 },
                        { type: 'conv', label: `Conv2D\n${p.filters1} filtros\n${p.kernel}√ó${p.kernel}`, color: '#FF9800', width: 80, height: 80 },
                        { type: 'pool', label: 'MaxPool\n2√ó2', color: '#4CAF50', width: 40, height: 40 },
                        { type: 'conv', label: `Conv2D\n${p.filters2} filtros\n${p.kernel}√ó${p.kernel}`, color: '#FF9800', width: 60, height: 60 },
                        { type: 'pool', label: 'MaxPool\n2√ó2', color: '#4CAF50', width: 30, height: 30 },
                        { type: 'flatten', label: 'Flatten', color: '#9C27B0', width: 100, height: 20 },
                        { type: 'dense', label: 'Dense\n64 neuronas', color: '#00BCD4', width: 120, height: 40 },
                        { type: 'output', label: 'Salida\n10 clases', color: '#f44336', width: 100, height: 60 }
                    ];
                    
                    layers.forEach((layer, idx) => {
                        const layerContainer = document.createElement('div');
                        layerContainer.style.cssText = `
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            gap: 10px;
                        `;
                        
                        // Representaci√≥n visual de la capa
                        const layerVisual = document.createElement('div');
                        layerVisual.style.cssText = `
                            width: ${layer.width}px;
                            height: ${layer.height}px;
                            background: ${layer.color};
                            border-radius: ${layer.type === 'flatten' ? '5px' : '10px'};
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            color: white;
                            font-size: 0.7rem;
                            text-align: center;
                            padding: 5px;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                        `;
                        layerVisual.textContent = layer.label;
                        
                        layerContainer.appendChild(layerVisual);
                        
                        // A√±adir flecha entre capas
                        if(idx < layers.length - 1) {
                            const arrow = document.createElement('div');
                            arrow.innerHTML = '‚Üí';
                            arrow.style.cssText = `
                                font-size: 1.5rem;
                                color: #666;
                                margin: 0 5px;
                            `;
                            cnnDiagram.appendChild(arrow);
                        }
                        
                        cnnDiagram.appendChild(layerContainer);
                    });
                    
                    cnnSection.appendChild(cnnDiagram);
                    
                    // Explicaci√≥n visual de la convoluci√≥n
                    const convExplanation = document.createElement('div');
                    convExplanation.style.cssText = `
                        margin-top: 20px;
                        padding: 15px;
                        background: #f8f9fa;
                        border-radius: 5px;
                        border-left: 4px solid #FF9800;
                    `;
                    
                    convExplanation.innerHTML = `
                        <b style="color:#333;">Explicaci√≥n de la convoluci√≥n:</b>
                        <div style="display: flex; align-items: center; gap: 20px; margin-top: 10px;">
                            <div style="font-size: 0.9rem;">
                                Kernel ${p.kernel}√ó${p.kernel} desliz√°ndose sobre la imagen<br>
                                Cada filtro detecta un patr√≥n diferente (bordes, texturas)<br>
                                ${p.filters1} filtros en la primera capa ‚Üí ${p.filters1} mapas de caracter√≠sticas
                            </div>
                        </div>
                    `;
                    
                    cnnSection.appendChild(convExplanation);
                    
                    // Feature maps visualizados
                    const featureMapsSection = document.createElement('div');
                    featureMapsSection.style.cssText = `
                        flex: 1;
                        background: white;
                        border-radius: 10px;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    `;
                    
                    const fmTitle = document.createElement('div');
                    fmTitle.innerHTML = `<b style="color:#333; font-size:1rem;">Mapas de Caracter√≠sticas (Feature Maps)</b>`;
                    fmTitle.style.cssText = 'margin-bottom: 15px; text-align: center;';
                    featureMapsSection.appendChild(fmTitle);
                    
                    // Grid de feature maps
                    const fmGrid = document.createElement('div');
                    fmGrid.style.cssText = `
                        display: grid;
                        grid-template-columns: repeat(4, 1fr);
                        gap: 10px;
                    `;
                    
                    // Crear feature maps simulados
                    for(let i = 0; i < 8; i++) {
                        const fmContainer = document.createElement('div');
                        fmContainer.style.cssText = `
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            gap: 5px;
                        `;
                        
                        const fmCanvas = document.createElement('div');
                        fmCanvas.style.cssText = `
                            width: 60px;
                            height: 60px;
                            background: linear-gradient(45deg, #f0f0f0 25%, #fff 25%, #fff 50%, #f0f0f0 50%, #f0f0f0 75%, #fff 75%, #fff);
                            background-size: 10px 10px;
                            border: 1px solid #dee2e6;
                            position: relative;
                            overflow: hidden;
                        `;
                        
                        // Patr√≥n de activaci√≥n aleatorio
                        for(let j = 0; j < 10; j++) {
                            const activation = document.createElement('div');
                            activation.style.cssText = `
                                position: absolute;
                                width: 10px;
                                height: 10px;
                                background: #${Math.floor(Math.random()*16777215).toString(16)};
                                opacity: 0.7;
                                left: ${Math.random() * 50}px;
                                top: ${Math.random() * 50}px;
                            `;
                            fmCanvas.appendChild(activation);
                        }
                        
                        const fmLabel = document.createElement('div');
                        fmLabel.style.cssText = 'font-size: 0.7rem; color: #666;';
                        fmLabel.textContent = `Filtro ${i+1}`;
                        
                        fmContainer.appendChild(fmCanvas);
                        fmContainer.appendChild(fmLabel);
                        fmGrid.appendChild(fmContainer);
                    }
                    
                    featureMapsSection.appendChild(fmGrid);
                    
                    // Estad√≠sticas comparativas
                    const statsDiv = document.createElement('div');
                    statsDiv.style.cssText = `
                        display: flex;
                        justify-content: center;
                        gap: 20px;
                        margin-top: 15px;
                    `;
                    
                    const stats = [
                        {label: 'Par√°metros CNN', value: `${Math.round((p.filters1 * p.kernel * p.kernel + p.filters2 * p.filters1 * p.kernel * p.kernel + 64 * 7 * 7 * p.filters2 + 64 * 10) / 1000)}K`},
                        {label: 'Par√°metros MLP', value: '550K'},
                        {label: 'Reducci√≥n', value: `${Math.round(((550 - (p.filters1 * p.kernel * p.kernel + p.filters2 * p.filters1 * p.kernel * p.kernel + 64 * 7 * 7 * p.filters2 + 64 * 10) / 1000) / 550) * 100)}%`},
                        {label: 'Accuracy estimada', value: '98.5%'}
                    ];
                    
                    stats.forEach(stat => {
                        const statBox = document.createElement('div');
                        statBox.style.cssText = `
                            background: #e3f2fd;
                            padding: 10px 15px;
                            border-radius: 5px;
                            text-align: center;
                            border-left: 3px solid #2196F3;
                        `;
                        statBox.innerHTML = `
                            <div style="font-size: 0.8rem; color: #666;">${stat.label}</div>
                            <div style="font-size: 1rem; font-weight: bold;">${stat.value}</div>
                        `;
                        statsDiv.appendChild(statBox);
                    });
                    
                    featureMapsSection.appendChild(statsDiv);
                    
                    container.appendChild(cnnSection);
                    container.appendChild(featureMapsSection);
                    div.appendChild(container);
                }
            }
        ];

        // --- FUNCIONES GLOBALES PARA TOOLTIPS ---
        function showTooltip(e) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = e.target.dataset.tooltip || 'Sin informaci√≥n';
            tooltip.style.opacity = '1';
            tooltip.style.left = (e.pageX + 10) + 'px';
            tooltip.style.top = (e.pageY - 10) + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.opacity = '0';
        }

        // --- INICIALIZACI√ìN DE LA APLICACI√ìN ---
        let currentLesson = 1;
        let params = {};

        function initApp() {
            renderMenu();
            loadLesson(currentLesson);
        }

        function renderMenu() {
            const menu = document.getElementById('menuList');
            menu.innerHTML = '';
            
            lessons.forEach(lesson => {
                const item = document.createElement('a');
                item.className = `menu-item ${lesson.id === currentLesson ? 'active' : ''}`;
                item.href = '#';
                item.onclick = () => loadLesson(lesson.id);
                
                item.innerHTML = `
                    <div class="menu-icon">
                        <i class="fas ${lesson.icon}"></i>
                    </div>
                    <div class="menu-text">
                        <h4>${lesson.title}</h4>
                        <p>${lesson.desc}</p>
                    </div>
                `;
                
                menu.appendChild(item);
            });
        }

        function loadLesson(id) {
            currentLesson = id;
            const lesson = lessons.find(l => l.id === id);
            
            // Actualizar men√∫
            renderMenu();
            
            // Inicializar par√°metros si no existen
            if (!params[id]) {
                params[id] = {};
                lesson.controls.forEach(control => {
                    params[id][control.id] = control.val !== undefined ? control.val : 
                                            control.value !== undefined ? control.value : 
                                            control.options ? control.options[0] : 0;
                });
            }
            
            // Renderizar controles
            renderControls(lesson);
            
            // Renderizar c√≥digo
            renderCode(lesson);
            
            // Renderizar visualizaci√≥n
            renderVisualization(lesson);
            
            // Renderizar explicaci√≥n
            renderExplanation(lesson);
        }

        function renderControls(lesson) {
            const controlsDiv = document.getElementById('controlsArea');
            controlsDiv.innerHTML = '';
            
            lesson.controls.forEach(control => {
                const group = document.createElement('div');
                group.className = 'control-group';
                
                const label = document.createElement('span');
                label.className = 'control-label';
                label.textContent = control.label;
                
                let input;
                
                switch(control.type) {
                    case 'select':
                        input = document.createElement('select');
                        control.options.forEach(option => {
                            const opt = document.createElement('option');
                            opt.value = option;
                            opt.textContent = option;
                            input.appendChild(opt);
                        });
                        input.value = params[lesson.id][control.id];
                        break;
                        
                    case 'range':
                        input = document.createElement('input');
                        input.type = 'range';
                        input.min = control.min;
                        input.max = control.max;
                        input.step = control.step || 1;
                        input.value = params[lesson.id][control.id];
                        
                        const valueSpan = document.createElement('span');
                        valueSpan.style.cssText = 'font-size: 0.8rem; font-weight: 600; color: #495057;';
                        valueSpan.textContent = input.value;
                        
                        input.oninput = function() {
                            valueSpan.textContent = this.value;
                            params[lesson.id][control.id] = Number(this.value);
                            updateLesson(lesson);
                        };
                        
                        group.appendChild(label);
                        group.appendChild(input);
                        group.appendChild(valueSpan);
                        controlsDiv.appendChild(group);
                        return;
                        
                    case 'checkbox':
                        input = document.createElement('input');
                        input.type = 'checkbox';
                        input.checked = params[lesson.id][control.id];
                        break;
                }
                
                input.onchange = function() {
                    params[lesson.id][control.id] = control.type === 'checkbox' ? this.checked : this.value;
                    updateLesson(lesson);
                };
                
                group.appendChild(label);
                group.appendChild(input);
                controlsDiv.appendChild(group);
            });
        }

        function renderCode(lesson) {
            const editor = document.getElementById('codeEditor');
            editor.innerHTML = lesson.code(params[lesson.id]);
        }

        function renderVisualization(lesson) {
            const plotContent = document.getElementById('plotContent');
            plotContent.innerHTML = '';
            lesson.render(params[lesson.id], plotContent);
        }

        function renderExplanation(lesson) {
            const explanation = document.getElementById('explanationText');
            explanation.innerHTML = lesson.explain(params[lesson.id]);
        }

        function updateLesson(lesson) {
            renderCode(lesson);
            renderVisualization(lesson);
            renderExplanation(lesson);
        }

        // Inicializar cuando el DOM est√© listo
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>